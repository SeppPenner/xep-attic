<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JEP-0116: Encrypted Sessions</title>
<link rel="stylesheet" type="text/css" href="jep.css">
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
<meta name="DC.Title" content="Encrypted Sessions">
<meta name="DC.Creator" content="Ian Paterson">
<meta name="DC.Creator" content="Peter Saint-Andre">
<meta name="DC.Creator" content="Dave Smith">
<meta name="DC.Description" content="This JEP specifies a protocol for session-based, end-to-end encryption of XMPP communications.">
<meta name="DC.Publisher" content="Jabber Software Foundation">
<meta name="DC.Contributor" content="JEP Editor">
<meta name="DC.Date" content="2005-11-29">
<meta name="DC.Type" content="Jabber Enhancement Proposal">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="JEP-0116">
<meta name="DC.Language" content="en">
<meta name="DC.Rights" content="This Jabber Enhancement Proposal is copyright 1999 - 2005 by the Jabber Software Foundation (JSF) and is in full conformance with the JSF's Intellectual Property Rights Policy &lt;http://www.jabber.org/jsf/ipr-policy.shtml&gt;. This material may be distributed only subject to the terms and conditions set forth in the Creative Commons Attribution License (&lt;http://creativecommons.org/licenses/by/2.5/&gt;).">
</head>
<body>
<h1>JEP-0116: Encrypted Sessions</h1>
<p>This JEP specifies a protocol for session-based, end-to-end encryption of XMPP communications.</p>
<p><hr></p>
<p style="color:red">WARNING: This Standards-Track JEP is Experimental. Publication as a Jabber Enhancement Proposal does not imply approval of this proposal by the Jabber Software Foundation. Implementation of the protocol described herein is encouraged in exploratory implementations, but production systems should not deploy implementations of this protocol until it advances to a status of Draft.</p>
<p><hr></p>
<h2>JEP Information</h2>
<p class="indent">
            Status: Experimental<br>
            Type: Standards Track<br>
            Number: 0116<br>
            Version: 0.9<br>
            Last Updated: 2005-11-29<br>
            JIG: Standards JIG<br>
                Approving Body: Jabber Council<br>Dependencies: XMPP Core, RFC 2104, RFC 2409, RFC 3526, RFC 3548, xml-c14n, JEP-0004, JEP-0020, JEP-0030, JEP-0068, JEP-0079, JEP-0155, JEP-0163<br>
                Supersedes: None<br>
                Superseded By: None<br>
            Short Name: esession<br>
              Wiki Page: &lt;<a href="http://wiki.jabber.org/index.php/Encrypted%20Sessions%20(JEP-0116)">http://wiki.jabber.org/index.php/Encrypted Sessions (JEP-0116)</a>&gt;
            </p>
<h2>Author Information</h2>
<div class="indent">
<h3>Ian Paterson</h3>
<p class="indent">
        Email: ian.paterson@clientside.co.uk<br>
        JID: ian@zoofy.com</p>
<h3>Peter Saint-Andre</h3>
<p class="indent">
        Email: stpeter@jabber.org<br>
        JID: stpeter@jabber.org</p>
<h3>Dave Smith</h3>
<p class="indent">
        Email: dizzyd@jabber.org<br>
        JID: dizzyd@jabber.org</p>
</div>
<h2>Legal Notice</h2>
<p class="indent">This Jabber Enhancement Proposal is copyright 1999 - 2005 by the <a href="http://www.jabber.org/jsf/">Jabber Software Foundation</a> (JSF) and is in full conformance with the JSF's Intellectual Property Rights Policy &lt;<a href="http://www.jabber.org/jsf/ipr-policy.shtml">http://www.jabber.org/jsf/ipr-policy.shtml</a>&gt;. This material may be distributed only subject to the terms and conditions set forth in the Creative Commons Attribution License (&lt;<a href="http://creativecommons.org/licenses/by/2.5/">http://creativecommons.org/licenses/by/2.5/</a>&gt;).</p>
<h2>Discussion Venue</h2>
<p class="indent">The preferred venue for discussion of this document is the Standards-JIG discussion list: &lt;<a href="http://mail.jabber.org/mailman/listinfo/standards-jig">http://mail.jabber.org/mailman/listinfo/standards-jig</a>&gt;.</p>
<p class="indent">Given that this JEP normatively references IETF technologies, discussion on the JSF-IETF list may also be appropriate (see &lt;<a href="http://mail.jabber.org/mailman/listinfo/jsf-ietf">http://mail.jabber.org/mailman/listinfo/jsf-ietf</a>&gt; for details).</p>
<h2>Relation to XMPP</h2>
<p class="indent">The Extensible Messaging and Presence Protocol (XMPP) is defined in the XMPP Core (RFC 3920) and XMPP IM (RFC 3921) specifications contributed by the Jabber Software Foundation to the Internet Standards Process, which is managed by the Internet Engineering Task Force in accordance with RFC 2026. Any protocol defined in this JEP has been developed outside the Internet Standards Process and is to be understood as an extension to XMPP rather than as an evolution, development, or modification of XMPP itself.</p>
<h2>Conformance Terms</h2>
<p class="indent">The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.</p>
<p><hr></p>
<h2>Table of Contents</h2>
<div class="indent"><dl>
<dt>1.  <a href="#intro">Introduction</a>
</dt>
<dt>2.  <a href="#background">Background</a>
</dt>
<dt>3.  <a href="#terms">Terminology</a>
</dt>
<dl><dt>3.1.  <a href="#terms-personae">Dramatis Personae</a>
</dt></dl>
<dt>4.  <a href="#reqs">Requirements</a>
</dt>
<dl>
<dt>4.1.  <a href="#reqs-sec">Security Requirements</a>
</dt>
<dl>
<dt>4.1.1.  <a href="#reqs-encrypt">Confidentiality</a>
</dt>
<dt>4.1.2.  <a href="#reqs-integrity">Integrity</a>
</dt>
<dt>4.1.3.  <a href="#reqs-replay">Replay Protection</a>
</dt>
<dt>4.1.4.  <a href="#reqs-forward">Perfect Forward Secrecy</a>
</dt>
<dt>4.1.5.  <a href="#reqs-auth">Authentication</a>
</dt>
<dt>4.1.6.  <a href="#reqs-id-protect">Identity Protection</a>
</dt>
<dt>4.1.7.  <a href="#reqs-repudiate">Repudiability</a>
</dt>
</dl>
<dt>4.2.  <a href="#reqs-xmpp">Application Requirements</a>
</dt>
<dl>
<dt>4.2.1.  <a href="#reqs-generality">Generality</a>
</dt>
<dt>4.2.2.  <a href="#reqs-implement">Implementability</a>
</dt>
<dt>4.2.3.  <a href="#reqs-usable">Usability</a>
</dt>
<dt>4.2.4.  <a href="#reqs-efficient">Efficiency</a>
</dt>
<dt>4.2.5.  <a href="#reqs-flexible">Flexibility</a>
</dt>
<dt>4.2.6.  <a href="#reqs-usable">Interoperability</a>
</dt>
<dt>4.2.7.  <a href="#reqs-offline">Offline Sessions</a>
</dt>
<dt>4.2.8.  <a href="#reqs-offline">Object Encryption</a>
</dt>
</dl>
</dl>
<dt>5.  <a href="#foundations">Cryptographic Origins - SIGMA</a>
</dt>
<dl>
<dt>5.1.  <a href="#foundations-parameters">SIGMA Parameter Descriptions</a>
</dt>
<dt>5.2.  <a href="#foundations-skeleton-i">SIGMA-I Overview</a>
</dt>
<dt>5.3.  <a href="#foundations-skeleton-r">SIGMA-R Overview</a>
</dt>
<dt>5.4.  <a href="#foundations-core-i">SIGMA-I Key Exchange</a>
</dt>
<dt>5.5.  <a href="#foundations-core-r">SIGMA-R Key Exchange</a>
</dt>
</dl>
<dt>6.  <a href="#design">Cryptographic Design</a>
</dt>
<dl>
<dt>6.1.  <a href="#design-parameters">ESession Parameter Descriptions</a>
</dt>
<dt>6.2.  <a href="#design-online-i">Online ESession-I Negotiation</a>
</dt>
<dt>6.3.  <a href="#design-online-r">Online ESession-R Negotiation</a>
</dt>
<dt>6.4.  <a href="#design-offline">Offline ESession Negotiation</a>
</dt>
</dl>
<dt>7.  <a href="#disco">Discovering Support</a>
</dt>
<dt>8.  <a href="#init">ESession Negotiation</a>
</dt>
<dl>
<dt>8.1.  <a href="#init-online">Online Diffie-Hellman Key Exchange</a>
</dt>
<dl>
<dt>8.1.1.  <a href="#init-online-request">ESession Request</a>
</dt>
<dt>8.1.2.  <a href="#init-online-bobprep">Diffie-Hellman Preparation (Bob)</a>
</dt>
<dt>8.1.3.  <a href="#init-keys">Generating Session Keys</a>
</dt>
<dt>8.1.4.  <a href="#init-hide">Hiding Identity</a>
</dt>
<dt>8.1.5.  <a href="#init-online-response">ESession Response</a>
</dt>
<dt>8.1.6.  <a href="#init-online-aliceprep">Diffie-Hellman Preparation (Alice)</a>
</dt>
<dt>8.1.7.  <a href="#init-online-bobid">Verifying Bob's Identity</a>
</dt>
<dt>8.1.8.  <a href="#init-online-complete">ESession Completion</a>
</dt>
</dl>
<dt>8.2.  <a href="#init-offline">Offline Diffie-Hellman Key Exchange</a>
</dt>
<dl>
<dt>8.2.1.  <a href="#init-offline-publish">Publishing ESession Options</a>
</dt>
<dt>8.2.2.  <a href="#init-offline-request">Requesting Offline ESession Options</a>
</dt>
<dt>8.2.3.  <a href="#init-offline-start">Starting an Offline ESession</a>
</dt>
<dt>8.2.4.  <a href="#init-offline-accept">Accepting Offline ESessions</a>
</dt>
</dl>
</dl>
<dt>9.  <a href="#exchange">Exchanging Stanzas</a>
</dt>
<dl>
<dt>9.1.  <a href="#exchange-separate">Encryptable Content</a>
</dt>
<dt>9.2.  <a href="#exchange-encrypt">Encryption</a>
</dt>
<dt>9.3.  <a href="#exchange-send">Sending an Encrypted Stanza</a>
</dt>
<dt>9.4.  <a href="#exchange-decrypt">Decryption</a>
</dt>
</dl>
<dt>10.  <a href="#rekey">Re-Key Exchange</a>
</dt>
<dl>
<dt>10.1.  <a href="#rekey-init">Re-Key Initiation</a>
</dt>
<dt>10.2.  <a href="#rekey-accept">Re-Key Acceptance</a>
</dt>
<dt>10.3.  <a href="#rekey-publish">Publishing Old MAC Values</a>
</dt>
</dl>
<dt>11.  <a href="#terminate">ESession Termination</a>
</dt>
<dt>12.  <a href="#sign">Signature Generation and Verification</a>
</dt>
<dl>
<dt>12.1.  <a href="#sign-normal">XML Normalization</a>
</dt>
<dt>12.2.  <a href="#sign-hash">Hash</a>
</dt>
<dt>12.3.  <a href="#sign-calc">Generation</a>
</dt>
<dl>
<dt>12.3.1.  <a href="#sign-rsa-gen">RSA</a>
</dt>
<dt>12.3.2.  <a href="#sign-dsa-gen">DSA</a>
</dt>
</dl>
<dt>12.4.  <a href="#sign-format">Signature Format</a>
</dt>
<dl>
<dt>12.4.1.  <a href="#sign-rsa-format">RSA</a>
</dt>
<dt>12.4.2.  <a href="#sign-dsa-format">DSA</a>
</dt>
</dl>
<dt>12.5.  <a href="#sign-calc">Verification</a>
</dt>
<dl>
<dt>12.5.1.  <a href="#sign-rsa-verify">RSA</a>
</dt>
<dt>12.5.2.  <a href="#sign-dsa-verify">DSA</a>
</dt>
</dl>
</dl>
<dt>13.  <a href="#sec">Security Considerations</a>
</dt>
<dl>
<dt>13.1.  <a href="#sec-prng">Random Numbers</a>
</dt>
<dt>13.2.  <a href="#sec-rekey">Re-Keying Limits</a>
</dt>
<dt>13.3.  <a href="#sec-keys">Verifying Keys</a>
</dt>
<dt>13.4.  <a href="#sec-replay">Replay Attacks</a>
</dt>
<dt>13.5.  <a href="#sec-offline">Offline ESessions</a>
</dt>
<dt>13.6.  <a href="#sec-unencrypted">Unencrypted ESessions</a>
</dt>
<dt>13.7.  <a href="#sec-storage">Storage</a>
</dt>
<dt>13.8.  <a href="#sec-general">Extra Responsabilities of Implementors</a>
</dt>
<dt>13.9.  <a href="#sec-mandatory">Mandatory to Implement Technologies</a>
</dt>
<dl>
<dt>13.9.1.  <a href="#sec-mandatory-encryption">Block Cipher Algorithms</a>
</dt>
<dt>13.9.2.  <a href="#sec-mandatory-sign">Key Signing Algorithms</a>
</dt>
<dt>13.9.3.  <a href="#sec-mandatory-public">Public Signature-Verification-Key Formats</a>
</dt>
<dt>13.9.4.  <a href="#sec-mandatory-hash">Hash Algorithms</a>
</dt>
<dt>13.9.5.  <a href="#sec-mandatory-compress">Compression Algorithms</a>
</dt>
</dl>
</dl>
<dt>14.  <a href="#iana">IANA Considerations</a>
</dt>
<dt>15.  <a href="#registrar">Jabber Registrar Considerations</a>
</dt>
<dl>
<dt>15.1.  <a href="#registrar-ns">Namespaces</a>
</dt>
<dt>15.2.  <a href="#registrar-formtype">Field Standardization</a>
</dt>
</dl>
<dt>16.  <a href="#schema">XML Schemas</a>
</dt>
<dt>17.  <a href="#acknowledgments">Acknowledgments</a>
</dt>
<dt>18.  <a href="#keys">Public Key Publication and Retrieval</a>
</dt>
<dt>19.  <a href="#open">Open Issues</a>
</dt>
<dl>
<dt>19.1.  <a href="#open-tothink">To Think About</a>
</dt>
<dt>19.2.  <a href="#open-todo">To Do</a>
</dt>
</dl>
<dt><a href="#notes">Notes</a></dt>
<dt><a href="#revs">Revision History</a></dt>
</dl></div>
<p><hr></p>
<h2>1.
       <a name="intro">Introduction</a>
</h2>
  <p class="" style="">End-to-end encryption is a desirable feature for any communication technology. Ideally, such a technology would design encryption in from the beginning and would forbid unencrypted communications. Realistically, most communication technologies have not been designed in that manner, and Jabber/XMPP technologies are no exception. In particular, the original Jabber technologies developed in 1999 did not include end-to-end encryption by default. PGP-based encryption of message bodies and signing of presence information was added as an extension to the core protocols in the year 2000; this extension is documented in <span class="ref" style="">Current Jabber OpenPGP Usage</span>  [<a href="#nt-id2250801">1</a>]. When the core protocols were formalized within the Internet Standards Process by the IETF's XMPP Working Group in 2003, a different extension was defined using S/MIME-based signing and encryption of CPIM-formatted messages (see <span class="ref" style="">RFC 3862</span>  [<a href="#nt-id2250832">2</a>]) and PIDF-formatted presence information (see <span class="ref" style="">RFC 3863</span>  [<a href="#nt-id2250855">3</a>]); this extension is specified in <span class="ref" style="">RFC 3923</span>  [<a href="#nt-id2250878">4</a>].</p>
  <p class="" style="">For reasons described more fully below, the foregoing proposals (and others not mentioned) have not been widely implemented and deployed. This is unfortunate, since an open communication protocol needs to enable end-to-end encryption in order to be seriously considered for deployment by a broad range of users.</p>
  <p class="" style="">This proposal describes a different approach to end-to-end encryption for use by entities that communicate using XMPP. The conceptual model for this encrypted sessions or "ESessions" approach was inspired by "off-the-record" (OTR) communication, as implemented in the Gaim encryption plugin and described in <span class="ref" style="">Off-the-Record Communication</span>  [<a href="#nt-id2250926">5</a>].</p>
<h2>2.
       <a name="background">Background</a>
</h2>
  <p class="" style="">As specified in <span class="ref" style="">RFC 3920</span>  [<a href="#nt-id2250961">6</a>], XMPP is an XML streaming protocol that enables the near-real-time exchange of XML fragments between any two (or more) network endpoints. To date, the main application built on top of the core XML streaming layer is instant messaging (IM) and presence, the base extensions for which are specified in <span class="ref" style="">RFC 3921</span>  [<a href="#nt-id2256505">7</a>]. There are three first-level elements of XML streams (&lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt;); each of these "XML stanza" types has different semantics, which can complicate the task of defining a generalized approach to end-to-end encryption for XMPP. In addition, XML stanzas can be extended (via properly-namespaced child elements) for a wide variety of functionality. The chosen approach should enable encryption of several complete XML elements rather than only parts thereof (e.g., only the XML character data of the message &lt;body/&gt; element as in <span style="font-weight: bold">JEP-0027</span>).</p>
  <p class="" style="">XMPP is a session-oriented communication technology: normally, a client authenticates with a server and maintains a long-lived connection that defines the client's XMPP session. Such stream-level sessions are secured via channel encryption using Transport Level Security (<span class="ref" style="">RFC 2246</span>  [<a href="#nt-id2256558">8</a>]), as specified in Section 5 of <span style="font-weight: bold">RFC 3920</span>. However, there is no guarantee that all hops will implement or enforce channel encryption (or that intermediate routers are trustworthy), which makes end-to-end encryption desirable.</p>
  <p class="" style="">The session metaphor also applies to communication between endpoints: for instance, in IM applications, most instant messaging exchanges occur in bursts within limited time periods (e.g., two people may send a fairly large number of messages during a five-minute chat and then not exchange messages again for hours or even days). The XML stanzas exchanged during such a session may not be limited to &lt;message/&gt; stanzas; for instance, the session may be triggered by a change in one of the parties' presence status (e.g., changing from away to available) and the session may involve the exchange of &lt;iq/&gt; stanzas (e.g., to transfer a file as specified in <span class="ref" style="">File Transfer</span>  [<a href="#nt-id2256605">9</a>]). Endpoints may want to encrypt the stanzas they send to each other in such a way that the stanzas cannot be understood by untrusted mediating entities (such as servers) except to the extent required to understand the necessary routing information. (One complicating factor is that routing information may include not only the stanza's 'to', 'from', 'type, and 'id' attributes, but also <span class="ref" style="">Advanced Message Processing</span>  [<a href="#nt-id2256626">10</a>] extensions.)</p>
  <p class="" style="">The foregoing XMPP communications exist in the context of a one-to-one communication session between two entities. However, several forms of XMPP communication exist outside the context of one-to-one communication sessions:</p>
  <ul>
    <li>Many-to-many sessions, such as a text conference in a chatroom as specified in <span class="ref" style="">Multi-User Chat</span>  [<a href="#nt-id2256662">11</a>].</li>
    <li>One-to-many "broadcast", such as undirected presence stanzas sent from one user to many contacts (see <span style="font-weight: bold">RFC 3921</span>) and data syndication implemented using <span class="ref" style="">Publish-Subscribe</span>  [<a href="#nt-id2256691">12</a>].</li>
    <li>One-to-one communications that are stored for later delivery rather than delivered immediately, such as so-called "offline messages".</li>
  </ul>
  <p class="" style="">Ideally, any technology for end-to-end encryption in XMPP could be extended to cover these scenarios as well as one-to-one communication sessions. However, both many-to-many sessions and one-to-many broadcast are deemed out of scope for this JEP. Offline communications are handled via a simple extension to the protocol for one-to-one sessions between two entities that are online simultaneously (see below).</p>
  <p class="" style="">Because XMPP is a session-oriented communication technology, encryption schemes that are appropriate for less dynamic technologies may not be appropriate for XMPP. XMPP, with its in-order delivery of XML stanzas, is able to take advantage of encryption approaches that are not feasible for less dynamic technologies. In particular, existing approaches to encryption of Internet communications have generally assumed that the "thing" to be encrypted has a stable identity or is best understood as a standalone object (e.g., a file or email message); the term "object encryption" well captures this assumption. Both <span style="font-weight: bold">JEP-0027</span> and <span style="font-weight: bold">RFC 3923</span> assume that XMPP communications are more like the exchange of email messages than they are like an interactive session -- while <span style="font-weight: bold">JEP-0027</span> uses "old-style" PGP object encryption and <span style="font-weight: bold">RFC 3923</span> uses "new-style" S/MIME object encryption, both specify the use of object encryption. </p>
  <p class="" style="">However, the session-oriented nature of XMPP may imply that the focus should be on "session encryption" rather than "object encryption". The paradigm for XMPP encryption may be something closer to the widely-deployed Secure Shell technology (see <span class="ref" style="">SSH Protocol Architecture</span>  [<a href="#nt-id2256793">13</a>] and <span class="ref" style="">SSH Transport Layer Protocol</span>  [<a href="#nt-id2256814">14</a>]) than to traditional encryption of files and standalone email messages.</p>
  <p class="" style="">Therefore, this JEP specifies a method for encrypted sessions ("ESessions") that takes advantage of the inherent possibilities and strengths of session encryption as opposed to object encryption. The basic concept is that of an encrypted session which acts as a secure tunnel between two endpoints. Once the tunnel is established, the content of all one-to-one XML stanzas exchanged between the endpoints will be encrypted and then transmitted within a "wrapper" protocol element.</p>
<h2>3.
       <a name="terms">Terminology</a>
</h2>
  <div class="indent">
<h3>3.1 <a name="terms-personae">Dramatis Personae</a>
</h3>
    <p class="" style="">This JEP introduces two characters to help the reader follow the necessary exchanges:</p>
    <ol start="1" type="">
      <li>"Alice" is the name of the initiator of the ESession. Within the scope of this JEP, we stipulate that her fully-qualified JID is: &lt;alice@example.org/pda&gt;.</li>
      <li>"Bob" is the name of the other participant in the ESession started by Alice. Within the scope of this JEP, his fully-qualified JID is: &lt;bob@example.com/laptop&gt;.</li>
    </ol>
    <p class="" style="">While Alice and Bob are introduced as "end users", they are simply meant to be examples of Jabber entities. Any directly addressable Jabber entity may participate in an ESession.</p>
  </div>
<h2>4.
       <a name="reqs">Requirements</a>
</h2>
  <div class="indent">
<h3>4.1 <a name="reqs-sec">Security Requirements</a>
</h3>
    <p class="" style="">This JEP stipulates the following security requirements for end-to-end encryption of XMPP communications:</p>
    <ul>
      <li>Confidentiality</li>
      <li>Integrity</li>
      <li>Replay protection</li>
      <li>Perfect forward secrecy</li>
      <li>Authentication</li>
      <li>Identity Protection</li>
      <li>Repudiability</li>
    </ul>
    <p class="" style="">Each of these requirements is explained in greater depth below.</p>
    <div class="indent">
<h3>4.1.1 <a name="reqs-encrypt">Confidentiality</a>
</h3>
      <p class="" style="">The one-to-one XML stanzas exchanged between two entities MUST NOT be understandable to any other entity that might intercept the communications.</p>
    </div>
    <div class="indent">
<h3>4.1.2 <a name="reqs-integrity">Integrity</a>
</h3>
      <p class="" style="">Alice and Bob MUST be sure that no other entity may change the content of the XML stanzas they exchange, or remove or insert stanzas into the ESession undetected.</p>
    </div>
    <div class="indent">
<h3>4.1.3 <a name="reqs-replay">Replay Protection</a>
</h3>
      <p class="" style="">Alice or Bob MUST be able to identify and reject any communications that are copies of their previous communications resent by another entity.</p>
    </div>
    <div class="indent">
<h3>4.1.4 <a name="reqs-forward">Perfect Forward Secrecy</a>
</h3>
      <p class="" style="">The encrypted communication MUST NOT be revealed even if long-lived keys are compromised in the future (e.g., Steve steals Bob's computer).</p>
    </div>
    <div class="indent">
<h3>4.1.5 <a name="reqs-auth">Authentication</a>
</h3>
      <p class="" style="">Each party to a conversation MUST know that the other party is who he says he is (Alice must be able to know that Bob really is Bob, and vice versa).  [<a href="#nt-id2257044">15</a>]</p>
    </div>
    <div class="indent">
<h3>4.1.6 <a name="reqs-id-protect">Identity Protection</a>
</h3>
      <p class="" style="">No other entity should be able to identify Alice or Bob. The JIDs they use to route their stanzas are unavoidably vulnerable to interception. However, the public keys they use SHOULD NOT be revealed to other entities using a passive attack. Bob SHOULD also be able to choose between protecting either his public key or Alice's public key from disclosure through active ("man-in-the-middle") attacks.</p>
    </div>
    <div class="indent">
<h3>4.1.7 <a name="reqs-repudiate">Repudiability</a>
</h3>
      <p class="" style="">Alice and Bob MUST be able to repudiate any stanza that occurs within an ESession. After an ESession has finished, it SHOULD NOT be possible to <span style="font-style: italic">prove cryptographically</span> that any transcript has not been modified by a third party.  [<a href="#nt-id2257094">16</a>]</p>
    </div>
  </div>
  <div class="indent">
<h3>4.2 <a name="reqs-xmpp">Application Requirements</a>
</h3>
    <p class="" style="">In addition to the foregoing security profile, this JEP also stipulates the following application-specific requirements for encrypted communication in the context of Jabber/XMPP technologies:</p>
    <ul>
      <li>Generality</li>
      <li>Implementability</li>
      <li>Usability</li>
      <li>Efficiency</li>
      <li>Flexibility</li>
      <li>Interoperability</li>
      <li>Offline "sessions"</li>
      <li>Object encryption</li>
    </ul>
    <p class="" style="">Each of these is explained in greater depth below.</p>
    <div class="indent">
<h3>4.2.1 <a name="reqs-generality">Generality</a>
</h3>
      <p class="" style="">The solution should be generally applicable to any XML stanza type (&lt;message/&gt;, &lt;presence/&gt;, &lt;iq/&gt;) sent between two entities. It is deemed acceptable for now if the solution does not apply to many-to-many stanzas (e.g., groupchat messages sent within the context of multi-user chat) or one-to-many stanzas (e.g., presence "broadcasts" and pubsub notifications); end-to-end encryption of such stanzas may require separate solutions or extensions to the one-to-one session solution.</p>
    </div>
    <div class="indent">
<h3>4.2.2 <a name="reqs-implement">Implementability</a>
</h3>
      <p class="" style="">The only good security technology is an implemented security technology. The solution should be one that typical client developers can implement in a relatively straightforward and interoperable fashion.</p>
    </div>
    <div class="indent">
<h3>4.2.3 <a name="reqs-usable">Usability</a>
</h3>
      <p class="" style="">The requirement of usability takes implementability one step further by stipulating that the solution must be one that organizations may deploy and humans may use with 100% transparency (with the ease-of-use of https:). Experience has shown that: solutions requiring a full public key infrastructure do not get widely deployed, and solutions requiring any user action are not widely used. We can do better.</p>
    </div>
    <div class="indent">
<h3>4.2.4 <a name="reqs-efficient">Efficiency</a>
</h3>
      <p class="" style="">Cryptographic operations are highly CPU intensive, particularly public key and Diffie-Hellman operations. Cryptographic data structures can be relatively large especially public keys and certificates. The solution should perform efficiently even when CPU and network bandwidth are constrained. The number of stanzas required for ESession negotiation should be minimized.</p>
    </div>
    <div class="indent">
<h3>4.2.5 <a name="reqs-flexible">Flexibility</a>
</h3>
      <p class="" style="">The solution should be compatible with existing (and future) cryptographic algorithms and identity certification schemes (including X.509 and PGP). The protocol should also be able to evolve to correct the weaknesses that are inevitably discovered once any cryptographic protocol is in widespread use.</p>
    </div>
    <div class="indent">
<h3>4.2.6 <a name="reqs-usable">Interoperability</a>
</h3>
      <p class="" style="">Ideally, it would be possible for an XMPP user to exchange encrypted messages (and, potentially, presence information) with users of non-XMPP messaging systems.</p>
    </div>
    <div class="indent">
<h3>4.2.7 <a name="reqs-offline">Offline Sessions</a>
</h3>
      <p class="" style="">Ideally, it should be possible to encrypt one-to-one communications that are stored for later delivery rather than delivered immediately, such as so-called "offline messages".</p>
    </div>
    <div class="indent">
<h3>4.2.8 <a name="reqs-offline">Object Encryption</a>
</h3>
      <p class="" style="">For cases where a session is not desired, it should be possible to encrypt, sign and send a single stanza in isolation, so-called "object encryption".</p>
    </div>
  </div>
<h2>5.
       <a name="foundations">Cryptographic Origins - SIGMA</a>
</h2>
  <p class="" style=""><span style="font-style: italic">Note: Implementors of ESessions may ignore this section since it is purely informative.</span></p>
  <p class="" style="">Authenticated key-exchange is the most challenging part of the design of any secure communication protocol. The ESessions key exchange essentially translates the <span class="ref" style="">SIGMA</span>  [<a href="#nt-id2250414">17</a>] [<a href="#nt-id2250401">18</a>] key-exchange protocol into the syntax of XMPP. This section provides an overview of SIGMA. The SIGMA approach underpins several standard key-exchange protocols including the Internet Key Exchange (IKE) protocol versions 1 and 2 (see <span class="ref" style="">RFC 2409</span>  [<a href="#nt-id2257553">19</a>] and <span class="ref" style="">IKEv2</span>  [<a href="#nt-id2257575">20</a>]).</p>
  <p class="" style="">The 3-message SIGMA-I-based key exchange protects the identity of the <span style="font-style: italic">initiator</span> against active attacks. The 4-message SIGMA-R-based key exchange defends the <span style="font-style: italic">responder's</span> identity against active attacks. The differences between the two versions of the SIGMA protocol are highlighted in the diagrams.</p>
  <div class="indent">
<h3>5.1 <a name="foundations-parameters">SIGMA Parameter Descriptions</a>
</h3>
    <p class="caption">Table 1: SIGMA Overview Parameters</p>
<table border="1" cellpadding="3" cellspacing="0">
      <tr class="body">
        <th colspan="" rowspan="">Parameter</th>
        <th colspan="" rowspan="">Description</th>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">g</td>
        <td align="" colspan="" rowspan="">Diffie-Hellman generator</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">x, y</td>
        <td align="" colspan="" rowspan="">Alice and Bob's private Diffie-Hellman keys</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">g<span class="super" style="">x</span>, g<span class="super" style="">y</span>
</td>
        <td align="" colspan="" rowspan="">Alice and Bob's public Diffie-Hellman keys</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">KS<span class="sub" style="">A</span>, KS<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The MAC keys that Alice and Bob use to calculate mac<span class="sub" style="">A</span> and mac<span class="sub" style="">B</span>
</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">pubKey<span class="sub" style="">A</span>, pubKey<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The public keys that represent the identity of Alice and Bob, and are used to verify their signatures</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">mac<span class="sub" style="">A</span>, mac<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The MAC values that associate the shared secret with the identity of Alice or Bob</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">signKey<span class="sub" style="">A</span>, signKey<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The private keys that Alice and Bob use to sign</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">sign<span class="sub" style="">A</span>, sign<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">Alice's and Bob's signatures of the shared secret</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">KC<span class="sub" style="">A</span>, KC<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The cipher keys that Alice and Bob use to encrypt</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">ID<span class="sub" style="">A</span>, ID<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The encrypted parameters that identify Alice and Bob to each other</td>
      </tr>
    </table>
    <p class="caption">Table 2: Key Exchange Parameters</p>
<table border="1" cellpadding="3" cellspacing="0">
      <tr class="body">
        <th colspan="" rowspan="">Parameter</th>
        <th colspan="" rowspan="">Description</th>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">p</td>
        <td align="" colspan="" rowspan="">Diffie-Hellman prime</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">e, d</td>
        <td align="" colspan="" rowspan="">Alice and Bob's public Diffie-Hellman keys (the same as g<span class="super" style="">x</span>, g<span class="super" style="">y</span>)</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">K</td>
        <td align="" colspan="" rowspan="">Shared secret</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">HASH</td>
        <td align="" colspan="" rowspan="">Selected hash algorithm</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">Alice and Bob's session freshness nonces (ESession IDs)</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">C<span class="sub" style="">A</span>, C<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">Block cipher initial counter value for blocks sent by Alice and Bob</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">n</td>
        <td align="" colspan="" rowspan="">Block size of selected cipher algorithm in bits</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">KM<span class="sub" style="">A</span>, KM<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The MAC keys that Alice and Bob use to protect the integrity of encrypted data</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">M<span class="sub" style="">A</span>, M<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The MAC values that Alice and Bob use to confirm the integrity of encrypted data</td>
      </tr>
    </table>
  </div>

  <div class="indent">
<h3>5.2 <a name="foundations-skeleton-i">SIGMA-I Overview</a>
</h3>
    <p class="" style="">The diagram below demonstrates the barest cryptographic skeleton of the SIGMA-I key exchange protocol. Here Bob allows Alice to protect her identity from active attacks, by allowing her to authenticate him before she communicates her identity. Note: The cipher keys (KC<span class="sub" style="">A</span> and KC<span class="sub" style="">B</span>) are different in each direction, making this exchange slightly more conservative than <span style="font-weight: bold">SIGMA</span>.</p>
    <pre>
<span style="font-weight: bold">ALICE</span>                                                <span style="font-weight: bold">BOB</span> 
                                            g<span class="super" style="">x</span>
                                      ------------&gt;

                                                     mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(KS<span class="sub" style="">B</span>, {g<span class="super" style="">x</span>, g<span class="super" style="">y</span>, pubKey<span class="sub" style="">B</span>})
                                                     sign<span class="sub" style="">B</span> = <span style="font-style: italic">sign</span>(signKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>)
                                                     ID<span class="sub" style="">B</span> = <span style="font-style: italic">cipher</span>(KC<span class="sub" style="">B</span>, {pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>})
                                         g<span class="super" style="">y</span>, ID<span class="sub" style="">B</span> 
                                      &lt;------------

<span style="font-style: italic">authenticate</span>(ID<span class="sub" style="">B</span>) 
mac<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(KS<span class="sub" style="">A</span>, {g<span class="super" style="">y</span>, g<span class="super" style="">x</span>, pubKey<span class="sub" style="">A</span>})
sign<span class="sub" style="">A</span> = <span style="font-style: italic">sign</span>(signKey<span class="sub" style="">A</span>, mac<span class="sub" style="">A</span>)
ID<span class="sub" style="">A</span> = <span style="font-style: italic">cipher</span>(KC<span class="sub" style="">A</span>, {pubKey<span class="sub" style="">A</span>, sign<span class="sub" style="">A</span>})
                                            ID<span class="sub" style="">A</span>
                                      ------------&gt;

                                                     <span style="font-style: italic">authenticate</span>(ID<span class="sub" style="">A</span>)
    </pre>
  </div>

  <div class="indent">
<h3>5.3 <a name="foundations-skeleton-r">SIGMA-R Overview</a>
</h3>
    <p class="" style="">The logic of the SIGMA-R protocol is similar to the SIGMA-I protocol. The diagram below demonstrates the skeleton of the key exchange. After receiving the first message from Alice, Bob chooses to protect his identity from active attacks by by delaying communicating his identity to Alice until he has authenticated her.</p>
    <pre>
<span style="font-weight: bold">ALICE</span>                                                <span style="font-weight: bold">BOB</span> 
                                            g<span class="super" style="">x</span>
                                      ------------&gt;

                                                     mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(KS<span class="sub" style="">B</span>, {g<span class="super" style="">x</span>, g<span class="super" style="">y</span>, pubKey<span class="sub" style="">B</span>})
                                                     sign<span class="sub" style="">B</span> = <span style="font-style: italic">sign</span>(signKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>)
                                                     ID<span class="sub" style="">B</span> = <span style="font-style: italic">cipher</span>(KC<span class="sub" style="">B</span>, {pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>})
                                            g<span class="super" style="">y</span>
                                      &lt;------------

mac<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(KS<span class="sub" style="">A</span>, {g<span class="super" style="">y</span>, g<span class="super" style="">x</span>, pubKey<span class="sub" style="">A</span>})
sign<span class="sub" style="">A</span> = <span style="font-style: italic">sign</span>(signKey<span class="sub" style="">A</span>, mac<span class="sub" style="">A</span>)
ID<span class="sub" style="">A</span> = <span style="font-style: italic">cipher</span>(KC<span class="sub" style="">A</span>, {pubKey<span class="sub" style="">A</span>, sign<span class="sub" style="">A</span>})
                                           ID<span class="sub" style="">A</span>
                                      ------------&gt;

                                                     <span style="font-style: italic">authenticate</span>(ID<span class="sub" style="">A</span>)
                                           ID<span class="sub" style="">B</span>
                                      &lt;------------

<span style="font-style: italic">authenticate</span>(ID<span class="sub" style="">B</span>)
    </pre>
    <p class="" style="">Note: In practice, Bob could delay calculating ID<span class="sub" style="">B</span> until after he has authenticated ID<span class="sub" style="">A</span>.</p>
  </div>

  <div class="indent">
<h3>5.4 <a name="foundations-core-i">SIGMA-I Key Exchange</a>
</h3>
    <p class="" style="">The diagram below describes exactly the same SIGMA-I key exchange protocol as the <a href="#foundations-skeleton-i">SIGMA-I skeleton</a> above. It provides much more detail, without specifying any ESession-specific details. Note: The block cipher function, <span style="font-style: italic">cipher</span>, uses CTR mode.</p>
    <pre>
<span style="font-weight: bold">ALICE</span>                                        <span style="font-weight: bold">BOB</span> 

x = <span style="font-style: italic">random</span>()
e = g<span class="super" style="">x</span> mod p
N<span class="sub" style="">A</span> = <span style="font-style: italic">random</span>()
                                 e, N<span class="sub" style="">A</span>
                             ------------&gt;
                                             C<span class="sub" style="">A</span> = <span style="font-style: italic">random</span>()
                                             y = <span style="font-style: italic">random</span>()
                                             d = g<span class="super" style="">y</span> mod p
                                             C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> 
                                             <span style="font-style: italic">assert</span> 1 &lt; e &lt; p-1
                                             K = HASH(e<span class="super" style="">y</span> mod p)
                                             KC<span class="sub" style="">A</span> = HASH(0, K)
                                             KC<span class="sub" style="">B</span> = HASH(1, K)
                                             KM<span class="sub" style="">A</span> = HASH(2, K)
                                             KM<span class="sub" style="">B</span> = HASH(3, K)
                                             KS<span class="sub" style="">A</span> = HASH(4, K)
                                             KS<span class="sub" style="">B</span> = HASH(5, K)
                                             N<span class="sub" style="">B</span> = <span style="font-style: italic">random</span>()
                                             mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">B</span>, {N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>, d, pubKey<span class="sub" style="">B</span>, C<span class="sub" style="">A</span>})
                                             sign<span class="sub" style="">B</span> = <span style="font-style: italic">sign</span>(signKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>)
                                             ID<span class="sub" style="">B</span> = <span style="font-style: italic">cipher</span>(KC<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, {pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>})
                                             M<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
                               d, C<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>
                             &lt;------------
                                ID<span class="sub" style="">B</span>, M<span class="sub" style="">B</span> 
C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> 
<span style="font-style: italic">assert</span> 1 &lt; d &lt; p-1
K = HASH(d<span class="super" style="">x</span> mod p)
KC<span class="sub" style="">A</span> = HASH(0, K)
KC<span class="sub" style="">B</span> = HASH(1, K)
KM<span class="sub" style="">A</span> = HASH(2, K)
KM<span class="sub" style="">B</span> = HASH(3, K)
KS<span class="sub" style="">A</span> = HASH(4, K)
KS<span class="sub" style="">B</span> = HASH(5, K)
<span style="font-style: italic">assert</span> M<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
{pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>} = <span style="font-style: italic">decipher</span>(KC<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">B</span>, {N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>, d, pubKey<span class="sub" style="">B</span>, C<span class="sub" style="">A</span>})
<span style="font-style: italic">verify</span>(sign<span class="sub" style="">B</span>, pubKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>) 
mac<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">A</span>, {N<span class="sub" style="">B</span>, N<span class="sub" style="">A</span>, e, pubKey<span class="sub" style="">A</span>})
sign<span class="sub" style="">A</span> = <span style="font-style: italic">sign</span>(signKey<span class="sub" style="">A</span>, mac<span class="sub" style="">A</span>)
ID<span class="sub" style="">A</span> = <span style="font-style: italic">cipher</span>(KC<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, {pubKey<span class="sub" style="">A</span>, sign<span class="sub" style="">A</span>})
M<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)
                                  ID<span class="sub" style="">A</span>
                             ------------&gt;
                                   M<span class="sub" style="">A</span> 
                                             <span style="font-style: italic">assert</span> M<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)
                                             {pubKey<span class="sub" style="">A</span>, sign<span class="sub" style="">A</span>} = <span style="font-style: italic">decipher</span>(KC<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)
                                             mac<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">A</span>, {N<span class="sub" style="">B</span>, N<span class="sub" style="">A</span>, e, pubKey<span class="sub" style="">A</span>})
                                             <span style="font-style: italic">verify</span>(sign<span class="sub" style="">A</span>, pubKey<span class="sub" style="">A</span>, mac<span class="sub" style="">A</span>)
    </pre>
  </div>

  <div class="indent">
<h3>5.5 <a name="foundations-core-r">SIGMA-R Key Exchange</a>
</h3>
    <p class="" style="">The diagram below describes exactly the same SIGMA-R key exchange protocol as the <a href="#foundations-skeleton-r">SIGMA-R skeleton</a> above. It provides much more detail, without specifying any ESession-specific details. Note: The block cipher function, <span style="font-style: italic">cipher</span>, uses CTR mode.</p>
    <pre>
<span style="font-weight: bold">ALICE</span>                                        <span style="font-weight: bold">BOB</span> 

x = <span style="font-style: italic">random</span>()
e = g<span class="super" style="">x</span> mod p
N<span class="sub" style="">A</span> = <span style="font-style: italic">random</span>()
                                 e, N<span class="sub" style="">A</span>
                             ------------&gt;
                                             C<span class="sub" style="">A</span> = <span style="font-style: italic">random</span>()
                                             y = <span style="font-style: italic">random</span>()
                                             d = g<span class="super" style="">y</span> mod p
                                             C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> 
                                             <span style="font-style: italic">assert</span> 1 &lt; e &lt; p-1
                                             K = HASH(e<span class="super" style="">y</span> mod p)
                                             KC<span class="sub" style="">A</span> = HASH(0, K)
                                             KC<span class="sub" style="">B</span> = HASH(1, K)
                                             KM<span class="sub" style="">A</span> = HASH(2, K)
                                             KM<span class="sub" style="">B</span> = HASH(3, K)
                                             KS<span class="sub" style="">A</span> = HASH(4, K)
                                             KS<span class="sub" style="">B</span> = HASH(5, K)
                                             N<span class="sub" style="">B</span> = <span style="font-style: italic">random</span>()
                                             mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">B</span>, {N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>, d, pubKey<span class="sub" style="">B</span>, C<span class="sub" style="">A</span>})
                                             sign<span class="sub" style="">B</span> = <span style="font-style: italic">sign</span>(signKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>)
                                             ID<span class="sub" style="">B</span> = <span style="font-style: italic">cipher</span>(KC<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, {pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>})
                                             M<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
                               d, C<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>
                             &lt;------------
C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> 
<span style="font-style: italic">assert</span> 1 &lt; d &lt; p-1
K = HASH(d<span class="super" style="">x</span> mod p)
KC<span class="sub" style="">A</span> = HASH(0, K)
KC<span class="sub" style="">B</span> = HASH(1, K)
KM<span class="sub" style="">A</span> = HASH(2, K)
KM<span class="sub" style="">B</span> = HASH(3, K)
KS<span class="sub" style="">A</span> = HASH(4, K)
KS<span class="sub" style="">B</span> = HASH(5, K)
mac<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">A</span>, {N<span class="sub" style="">B</span>, N<span class="sub" style="">A</span>, e, pubKey<span class="sub" style="">A</span>})
sign<span class="sub" style="">A</span> = <span style="font-style: italic">sign</span>(signKey<span class="sub" style="">A</span>, mac<span class="sub" style="">A</span>)
ID<span class="sub" style="">A</span> = <span style="font-style: italic">cipher</span>(KC<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, {pubKey<span class="sub" style="">A</span>, sign<span class="sub" style="">A</span>})
M<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)
                                  ID<span class="sub" style="">A</span>
                             ------------&gt;
                                   M<span class="sub" style="">A</span> 
                                             <span style="font-style: italic">assert</span> M<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)
                                             {pubKey<span class="sub" style="">A</span>, sign<span class="sub" style="">A</span>} = <span style="font-style: italic">decipher</span>(KC<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)
                                             mac<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">A</span>, {N<span class="sub" style="">B</span>, N<span class="sub" style="">A</span>, e, pubKey<span class="sub" style="">A</span>})
                                             <span style="font-style: italic">verify</span>(sign<span class="sub" style="">A</span>, pubKey<span class="sub" style="">A</span>, mac<span class="sub" style="">A</span>)
                                  ID<span class="sub" style="">B</span>
                             &lt;------------
                                   M<span class="sub" style="">B</span> 

<span style="font-style: italic">assert</span> M<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
{pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>} = <span style="font-style: italic">decipher</span>(KC<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">B</span>, {N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>, d, pubKey<span class="sub" style="">B</span>, C<span class="sub" style="">A</span>})
<span style="font-style: italic">verify</span>(sign<span class="sub" style="">B</span>, pubKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>)
    </pre>
  </div>
<h2>6.
       <a name="design">Cryptographic Design</a>
</h2>
  <p class="" style=""><span style="font-style: italic">Note: Implementors of ESessions may ignore this section since it is purely informative.</span></p>
  <p class="" style="">This section provides an overview of the full ESession key-exchange protocol from a cryptographic point of view. This protocol is based on the <span style="font-style: italic">full fledge</span> protocol, as described in Appendix B of the <span style="font-weight: bold">SIGMA</span> paper. It also uses <span style="font-style: italic">variant (ii)</span>, as described in Secion 5.4 of the same paper.</p>
  <div class="indent">
<h3>6.1 <a name="design-parameters">ESession Parameter Descriptions</a>
</h3>
    <p class="" style="">The table below describes the parameters that are not found in the <a href="#foundations-parameters">Parameter Descriptions</a> tables at the start of the previous section.</p>
    <p class="caption">Table 3: ESession Negotiation Parameters</p>
<table border="1" cellpadding="3" cellspacing="0">
      <tr class="body">
        <th colspan="" rowspan="">Parameter</th>
        <th colspan="" rowspan="">Description</th>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">options</td>
        <td align="" colspan="" rowspan="">Includes a set of possible values for each ESession parameter (see <a href="#init-online-request">ESession Request</a>)</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">chosen</td>
        <td align="" colspan="" rowspan="">Includes a chosen value for each ESession parameter</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">CIPHER</td>
        <td align="" colspan="" rowspan="">Selected CTR-mode block cipher algorithm</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">DECIPHER</td>
        <td align="" colspan="" rowspan="">Selected CTR-mode block decipher algorithm (corresponds to CIPHER)</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">SIGN</td>
        <td align="" colspan="" rowspan="">Selected signature algorithm</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">VERIFY</td>
        <td align="" colspan="" rowspan="">The selected signature verification algorithm (corresponds to SIGN)</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">x<span class="sub" style="">1</span>...x<span class="sub" style="">Z</span>
</td>
        <td align="" colspan="" rowspan="">Alice's private Diffie-Hellman keys - each value corresponds to one of Z different DH groups</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">e<span class="sub" style="">1</span>...e<span class="sub" style="">Z</span>
</td>
        <td align="" colspan="" rowspan="">The choice of public Diffie-Hellman keys that Alice offers Bob - each value corresponds to one of Z different DH groups (and a different value of x)</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">*signKeys<span class="sub" style="">A</span>
</td>
        <td align="" colspan="" rowspan="">All the private keys that Alice is able to use to create signatures</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">*signs<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The set of signatures of form<span class="sub" style="">B</span> (one for each of Bob's private keys)</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">*pubKeys<span class="sub" style="">A</span>
</td>
        <td align="" colspan="" rowspan="">The IDs of all the public keys that Alice can sign for</td>
      </tr>
    </table>
    <p class="" style="">* Offline negotiation only</p>
  </div>
  <div class="indent">
<h3>6.2 <a name="design-online-i">Online ESession-I Negotiation</a>
</h3>
    <p class="" style="">Alice uses this protocol when Bob is Online. In addition to the key exchange described in the <a href="#foundations-core-i">SIGMA-I Key Exchange</a> protocol above, she offers Bob a choice of Diffie-Hellman groups with her corresponding values of e, various algorithms and other parameters.</p>
    
    <pre>
<span style="font-weight: bold">ALICE</span>                                    <span style="font-weight: bold">BOB</span> 

<span style="font-style: italic">for</span> g,p ∈ options
    x = <span style="font-style: italic">random</span>()
    e = g<span class="super" style="">x</span> mod p
N<span class="sub" style="">A</span> = <span style="font-style: italic">random</span>()
form<span class="sub" style="">A</span> = {e<span class="sub" style="">1</span>...e<span class="sub" style="">Z</span>, options, N<span class="sub" style="">A</span>}
                                form<span class="sub" style="">A</span>
                             ---------&gt;

                                         chosen = {p,g,HASH,CIPHER,SIGN...} = <span style="font-style: italic">choose</span>(options)
                                         e = <span style="font-style: italic">choose</span>(e<span class="sub" style="">1</span>...e<span class="sub" style="">Z</span>, p)
                                         C<span class="sub" style="">A</span> = <span style="font-style: italic">random</span>()
                                         y = <span style="font-style: italic">random</span>()
                                         d = g<span class="super" style="">y</span> mod p
                                         C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> 
                                         <span style="font-style: italic">assert</span> 1 &lt; e &lt; p-1
                                         K = HASH(e<span class="super" style="">y</span> mod p)
                                         KC<span class="sub" style="">A</span> = HASH(0, K)
                                         KC<span class="sub" style="">B</span> = HASH(1, K)
                                         KM<span class="sub" style="">A</span> = HASH(2, K)
                                         KM<span class="sub" style="">B</span> = HASH(3, K)
                                         KS<span class="sub" style="">A</span> = HASH(4, K)
                                         KS<span class="sub" style="">B</span> = HASH(5, K)
                                         N<span class="sub" style="">B</span> = <span style="font-style: italic">random</span>()
                                         form<span class="sub" style="">B</span> = {C<span class="sub" style="">A</span>, chosen, d, N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>}
                                         mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">B</span>, {N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>, d, pubKey<span class="sub" style="">B</span>, form<span class="sub" style="">B</span>})
                                         sign<span class="sub" style="">B</span> = SIGN(signKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>)
                                         ID<span class="sub" style="">B</span> = CIPHER(KC<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, {pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>})
                                         M<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
                                form<span class="sub" style="">B</span>
                             &lt;---------
                               ID<span class="sub" style="">B</span>, M<span class="sub" style="">B</span> 
<span style="font-style: italic">assert</span> chosen ∈ options
x = <span style="font-style: italic">choose</span>(x<span class="sub" style="">1</span>...x<span class="sub" style="">Z</span>, p)
e = g<span class="super" style="">x</span> mod p
C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> 
<span style="font-style: italic">assert</span> 1 &lt; d &lt; p-1
K = HASH(d<span class="super" style="">x</span> mod p)
KC<span class="sub" style="">A</span> = HASH(0, K)
KC<span class="sub" style="">B</span> = HASH(1, K)
KM<span class="sub" style="">A</span> = HASH(2, K)
KM<span class="sub" style="">B</span> = HASH(3, K)
KS<span class="sub" style="">A</span> = HASH(4, K)
KS<span class="sub" style="">B</span> = HASH(5, K)
<span style="font-style: italic">assert</span> M<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
{pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>} = DECIPHER(KC<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">B</span>, {N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>, d, pubKey<span class="sub" style="">B</span>, form<span class="sub" style="">B</span>})
VERIFY(sign<span class="sub" style="">B</span>, pubKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>) 
mac<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">A</span>, {N<span class="sub" style="">B</span>, N<span class="sub" style="">A</span>, e, pubKey<span class="sub" style="">A</span>, form<span class="sub" style="">A</span>})
sign<span class="sub" style="">A</span> = SIGN(signKey<span class="sub" style="">A</span>, mac<span class="sub" style="">A</span>)
ID<span class="sub" style="">A</span> = CIPHER(KC<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, {pubKey<span class="sub" style="">A</span>, sign<span class="sub" style="">A</span>})
M<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)
                                 ID<span class="sub" style="">A</span>
                             ---------&gt;
                               N<span class="sub" style="">B</span>, M<span class="sub" style="">A</span> 
                                         <span style="font-style: italic">assert</span> M<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)
                                         {pubKey<span class="sub" style="">A</span>, sign<span class="sub" style="">A</span>} = DECIPHER(KC<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)
                                         mac<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">A</span>, {N<span class="sub" style="">B</span>, N<span class="sub" style="">A</span>, e, pubKey<span class="sub" style="">A</span>, form<span class="sub" style="">A</span>})
                                         VERIFY(sign<span class="sub" style="">A</span>, pubKey<span class="sub" style="">A</span>, mac<span class="sub" style="">A</span>)
    </pre>
  </div>

  <div class="indent">
<h3>6.3 <a name="design-online-r">Online ESession-R Negotiation</a>
</h3>
    <p class="" style="">This protocol is similar to the <a href="#design-online-i">Online ESession-I Negotiation</a> above, except that after receiving the first message from Alice, Bob chooses to protect his identity from active attacks (by by delaying communicating his identity to Alice until he has authenticated her).</p>
    <pre>
<span style="font-weight: bold">ALICE</span>                                    <span style="font-weight: bold">BOB</span> 

<span style="font-style: italic">for</span> g,p ∈ options
    x = <span style="font-style: italic">random</span>()
    e = g<span class="super" style="">x</span> mod p
N<span class="sub" style="">A</span> = <span style="font-style: italic">random</span>()
form<span class="sub" style="">A</span> = {e<span class="sub" style="">1</span>...e<span class="sub" style="">Z</span>, options, N<span class="sub" style="">A</span>}
                                form<span class="sub" style="">A</span>
                             ---------&gt;

                                         chosen = {p,g,HASH,CIPHER,SIGN...} = <span style="font-style: italic">choose</span>(options)
                                         e = <span style="font-style: italic">choose</span>(e<span class="sub" style="">1</span>...e<span class="sub" style="">Z</span>, p)
                                         C<span class="sub" style="">A</span> = <span style="font-style: italic">random</span>()
                                         y = <span style="font-style: italic">random</span>()
                                         d = g<span class="super" style="">y</span> mod p
                                         C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> 
                                         <span style="font-style: italic">assert</span> 1 &lt; e &lt; p-1
                                         K = HASH(e<span class="super" style="">y</span> mod p)
                                         KC<span class="sub" style="">A</span> = HASH(0, K)
                                         KC<span class="sub" style="">B</span> = HASH(1, K)
                                         KM<span class="sub" style="">A</span> = HASH(2, K)
                                         KM<span class="sub" style="">B</span> = HASH(3, K)
                                         KS<span class="sub" style="">A</span> = HASH(4, K)
                                         KS<span class="sub" style="">B</span> = HASH(5, K)
                                         N<span class="sub" style="">B</span> = <span style="font-style: italic">random</span>()
                                         form<span class="sub" style="">B</span> = {C<span class="sub" style="">A</span>, chosen, d, N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>}
                                         mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">B</span>, {N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>, d, pubKey<span class="sub" style="">B</span>, form<span class="sub" style="">B</span>})
                                         sign<span class="sub" style="">B</span> = SIGN(signKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>)
                                         ID<span class="sub" style="">B</span> = CIPHER(KC<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, {pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>})
                                         M<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)

                                form<span class="sub" style="">B</span>
                             &lt;---------
<span style="font-style: italic">assert</span> chosen ∈ options
x = <span style="font-style: italic">choose</span>(x<span class="sub" style="">1</span>...x<span class="sub" style="">Z</span>, p)
e = g<span class="super" style="">x</span> mod p
C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> 
<span style="font-style: italic">assert</span> 1 &lt; d &lt; p-1
K = HASH(d<span class="super" style="">x</span> mod p)
KC<span class="sub" style="">A</span> = HASH(0, K)
KC<span class="sub" style="">B</span> = HASH(1, K)
KM<span class="sub" style="">A</span> = HASH(2, K)
KM<span class="sub" style="">B</span> = HASH(3, K)
KS<span class="sub" style="">A</span> = HASH(4, K)
KS<span class="sub" style="">B</span> = HASH(5, K)
mac<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">A</span>, {N<span class="sub" style="">B</span>, N<span class="sub" style="">A</span>, e, pubKey<span class="sub" style="">A</span>, form<span class="sub" style="">A</span>})
sign<span class="sub" style="">A</span> = SIGN(signKey<span class="sub" style="">A</span>, mac<span class="sub" style="">A</span>)
ID<span class="sub" style="">A</span> = CIPHER(KC<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, {pubKey<span class="sub" style="">A</span>, sign<span class="sub" style="">A</span>})
M<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)
                                 ID<span class="sub" style="">A</span>
                             ---------&gt;
                               N<span class="sub" style="">B</span>, M<span class="sub" style="">A</span> 
                                        <span style="font-style: italic">assert</span> M<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)
                                        {pubKey<span class="sub" style="">A</span>, sign<span class="sub" style="">A</span>} = DECIPHER(KC<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)
                                        mac<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">A</span>, {N<span class="sub" style="">B</span>, N<span class="sub" style="">A</span>, e, pubKey<span class="sub" style="">A</span>, form<span class="sub" style="">A</span>})
                                        VERIFY(sign<span class="sub" style="">A</span>, pubKey<span class="sub" style="">A</span>, mac<span class="sub" style="">A</span>)
                                 ID<span class="sub" style="">B</span>
                             &lt;---------
                               N<span class="sub" style="">A</span>, M<span class="sub" style="">B</span> 

<span style="font-style: italic">assert</span> M<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
{pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>} = DECIPHER(KC<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">B</span>, {N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>, d, pubKey<span class="sub" style="">B</span>, form<span class="sub" style="">B</span>})
VERIFY(sign<span class="sub" style="">B</span>, pubKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>)
    </pre>
  </div>

  <div class="indent">
<h3>6.4 <a name="design-offline">Offline ESession Negotiation</a>
</h3>
    <p class="" style="">Bob uses this protocol to send stanzas to Alice when she is Offline. Note: Since the full <span style="font-weight: bold">SIGMA</span> protocol cannot be used if Alice is offline, her identity is not protected.</p>
    <p class="" style="">The diagram is split into three phases. First Alice publishes her ESession options before going offline. Later Bob completes the key exchange (and sends her encrypted stanzas that are not shown below) these are all stored by Alice's server. Finally when Alice comes online again she verifies and calculates the decryption key.</p>
    <p class="" style="">The differences between this offline protocol and the <a href="#design-online-i">Online ESession-I Negotiation</a> protocol above are highlighted in the diagram below.</p>
    <pre>
<span style="font-weight: bold">ALICE</span>                    <span style="font-weight: bold">ALICE'S SERVER</span>              <span style="font-weight: bold">BOB</span> 

<span style="font-style: italic">for</span> g,p ∈ options
    x = <span style="font-style: italic">random</span>()
    e = g<span class="super" style="">x</span> mod p
N<span class="sub" style="">A</span> = <span style="font-style: italic">random</span>()
form<span class="sub" style="">A</span> = {e<span class="sub" style="">1</span>...e<span class="sub" style="">Z</span>, options, N<span class="sub" style="">A</span>, pubKeys<span class="sub" style="">A</span>}
signs<span class="sub" style="">A</span> = <span style="font-style: italic">multi_sign</span>(signKeys<span class="sub" style="">A</span>, form<span class="sub" style="">A</span>)
<span style="font-style: italic">store</span>(N<span class="sub" style="">A</span>, x<span class="sub" style="">1</span>...x<span class="sub" style="">Z</span>)
                   form<span class="sub" style="">A</span>
                 --------&gt;
                   signs<span class="sub" style="">A</span> 

                         <span style="font-style: italic">store</span>(form<span class="sub" style="">A</span>, signs<span class="sub" style="">A</span>)
---------------------------------------------------------------------------------------------------------
                         <span style="font-style: italic">retrieve</span>(form<span class="sub" style="">A</span>, signs<span class="sub" style="">A</span>)

                                             form<span class="sub" style="">A</span>
                                           --------&gt;
                                             signs<span class="sub" style="">A</span> 

                                                     <span style="font-style: italic">verify_one</span>(signs<span class="sub" style="">A</span>, pubKeys<span class="sub" style="">A</span>, form<span class="sub" style="">A</span>)
                                                     chosen = {p,g,HASH,CIPHER,SIGN...} = <span style="font-style: italic">choose</span>(options)
                                                     e = <span style="font-style: italic">choose</span>(e<span class="sub" style="">1</span>...e<span class="sub" style="">Z</span>, p)
                                                     C<span class="sub" style="">A</span> = <span style="font-style: italic">random</span>()
                                                     y = <span style="font-style: italic">random</span>()
                                                     d = g<span class="super" style="">y</span> mod p
                                                     C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> 
                                                     <span style="font-style: italic">assert</span> 1 &lt; e &lt; p-1
                                                     K = HASH(e<span class="super" style="">y</span> mod p)
                                                     KC<span class="sub" style="">A</span> = HASH(0, K)
                                                     KC<span class="sub" style="">B</span> = HASH(1, K)
                                                     KM<span class="sub" style="">A</span> = HASH(2, K)
                                                     KM<span class="sub" style="">B</span> = HASH(3, K)
                                                     KS<span class="sub" style="">A</span> = HASH(4, K)
                                                     KS<span class="sub" style="">B</span> = HASH(5, K)
                                                     N<span class="sub" style="">B</span> = <span style="font-style: italic">random</span>()
                                                     form<span class="sub" style="">B</span> = {C<span class="sub" style="">A</span>, chosen, d, N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>}
                                                     mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">B</span>, {N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>, d, pubKey<span class="sub" style="">B</span>, form<span class="sub" style="">B</span>})
                                                     sign<span class="sub" style="">B</span> = SIGN(signKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>)
                                                     ID<span class="sub" style="">B</span> = CIPHER(KC<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, {pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>})
                                                     M<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)

                                             form<span class="sub" style="">B</span>
                                           &lt;--------
                                            ID<span class="sub" style="">B</span>, M<span class="sub" style="">B</span> 

                         <span style="font-style: italic">store</span>(form<span class="sub" style="">B</span>,ID<span class="sub" style="">B</span>,M<span class="sub" style="">B</span>)
---------------------------------------------------------------------------------------------------------
                         <span style="font-style: italic">retrieve</span>(form<span class="sub" style="">B</span>,ID<span class="sub" style="">B</span>,M<span class="sub" style="">B</span>) 
                   form<span class="sub" style="">B</span>
                 &lt;--------
                  ID<span class="sub" style="">B</span>, M<span class="sub" style="">B</span> 

<span style="font-style: italic">retrieve</span>(N<span class="sub" style="">A</span>, x<span class="sub" style="">1</span>...x<span class="sub" style="">Z</span>) 
<span style="font-style: italic">assert</span> chosen ∈ options
x = <span style="font-style: italic">choose</span>(x<span class="sub" style="">1</span>...x<span class="sub" style="">Z</span>, p)
e = g<span class="super" style="">x</span> mod p
C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> 
<span style="font-style: italic">assert</span> 1 &lt; d &lt; p-1
K = HASH(d<span class="super" style="">x</span> mod p)
KC<span class="sub" style="">A</span> = HASH(0, K)
KC<span class="sub" style="">B</span> = HASH(1, K)
KM<span class="sub" style="">A</span> = HASH(2, K)
KM<span class="sub" style="">B</span> = HASH(3, K)
KS<span class="sub" style="">A</span> = HASH(4, K)
KS<span class="sub" style="">B</span> = HASH(5, K)
<span style="font-style: italic">assert</span> M<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
{pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>} = DECIPHER(KC<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)
mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">B</span>, {N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>, d, pubKey<span class="sub" style="">B</span>, form<span class="sub" style="">B</span>})
VERIFY(sign<span class="sub" style="">B</span>, pubKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>)
    </pre>
    <p class="" style="">Note: KM<span class="sub" style="">B</span> is necessary only to allow Bob to terminate the ESession if he comes online before Alice terminates it. The calculation of KC<span class="sub" style="">B</span> and KS<span class="sub" style="">B</span> is not strictly necessary.</p>
  </div>
<h2>7.
       <a name="disco">Discovering Support</a>
</h2>
  <p class="" style="">Before attempting to engage in an ESession with Bob, Alice SHOULD discover whether he supports this protocol, using either <span class="ref" style="">Service Discovery</span>  [<a href="#nt-id2265567">21</a>] or the presence-based profile of <span style="font-weight: bold">JEP-0030</span> specified in <span class="ref" style="">Entity Capabilities</span>  [<a href="#nt-id2265594">22</a>].</p>
  <p class="" style="">The normal course of events is for Alice to authenticate with her server, retrieve her roster (see <span style="font-weight: bold">RFC 3921</span>), send initial presence to her server, and then receive presence information from all the contacts in her roster. If the presence information she receives from some contacts does not include capabilities data (per <span style="font-weight: bold">JEP-0115</span>), Alice SHOULD then send a service discovery information ("disco#info") request to each of those contacts (in accordance with <span style="font-weight: bold">JEP-0030</span>). Such initial service discovery stanzas MUST NOT be considered part of encrypted communication sessions for the purposes of this JEP, since they perform a "bootstrapping" function that is a prerequisite to encrypted communications. The disco#info request sent from Alice to Bob might look as follows:</p>
  <p class="caption">Example 1. Alice Queries Bob for ESession Support via Disco</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='alice@example.org/pda'
    to='bob@example.com/laptop'
    id='disco1'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'/&gt;
&lt;/iq&gt;
  </pre></div>
  <p class="" style="">If Bob sends a disco#info reply and he supports the protocol defined herein, then he MUST include a service discovery feature variable of "http://jabber.org/protocol/esession".</p>
  <p class="caption">Example 2. Bob Returns disco#info Data</p>
<div class="indent"><pre>
&lt;iq type='result'
    from='bob@example.com/laptop'
    to='alice@example.org/pda'
    id='disco1'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'&gt;
    &lt;identity category='client' type='pc'/&gt;
    ...
    &lt;feature var='http://jabber.org/protocol/esession'/&gt;
    ...
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
<h2>8.
       <a name="init">ESession Negotiation</a>
</h2>
  <p class="" style="">The process for establishing a secure session over an insecure transport is essentially a negotiation of various ESession algorithms and other parameters, combined with a translation into XMPP syntax of the <span style="font-weight: bold">SIGMA</span> approach to Diffie-Hellman (see <span class="ref" style="">RFC 2631</span>  [<a href="#nt-id2265686">23</a>]) key agreement.</p>
  <p class="" style="">When Alice wishes to establish an ESession with Bob, Alice may choose between two different methods of performing the initial Diffie-Hellman key exchange, depending on whether Bob is online or not. Note: Alice MUST NOT initiate a new ESession with Bob if she already has one established with him.</p>

  <div class="indent">
<h3>8.1 <a name="init-online">Online Diffie-Hellman Key Exchange</a>
</h3>
    <p class="" style="">If Alice believes Bob may be online then she SHOULD use the protocol specified in <span class="ref" style="">Chat Session Negotiation</span>  [<a href="#nt-id2265747">24</a>] to negotiate the ESession options and the keys.</p>
    <div class="indent">
<h3>8.1.1 <a name="init-online-request">ESession Request</a>
</h3>
      <p class="" style="">In addition to the "accept" and "logging" fields specified in <span style="font-weight: bold">Chat Session Negotiation</span>, Alice MUST specify each of the ESession options (see list below) that she is willing to use, in her order of preference (see <a href="#sec-mandatory">Mandatory to Implement Technologies</a>). Note: Alice SHOULD NOT include a "reason" field since Aunt Tillie may not be aware the ESession request is <span style="font-style: italic">not</span> encrypted.</p>
      <ol start="" type="">
        <li><p class="" style="">Whether or not both entities MUST be connected securely to their servers (see Section 5 of <span style="font-weight: bold">RFC 3920</span>)</p></li>
        <li><p class="" style="">The list of Modular Exponential (MODP) group numbers (as specified in <span style="font-weight: bold">RFC 2409</span> or <span class="ref" style="">RFC 3526</span>  [<a href="#nt-id2265833">25</a>]) that MAY be used for Diffie-Hellman key exchange (valid group numbers include 1,2,3,4,5,14,15,16,17 and 18)</p></li>
        <li><p class="" style="">Symmetric block cipher algorithm names</p></li>
        <li><p class="" style="">Hash algorithm names</p></li>
        <li><p class="" style="">Signature algorithm names</p></li>
        <li><p class="" style="">Compression algorithm names</p></li>
        <li><p class="" style="">The list of stanza types that MAY be encrypted and decrypted</p></li>
        <li><p class="" style="">Whether or not the other entity MUST send the fingerprint (PKID) of its public signature-verification key instead of the full key</p></li>
        <li><p class="" style="">The minimum and maximum versions of this document that are supported</p></li>
        <li><p class="" style="">The minimum number of stanzas that MUST be exchanged before an entity MAY initiate a key re-exchange (1 - every stanza, 100 - every hundred stanzas). Note: This value MUST be less than 2<span class="super" style="">32</span> (see <a href="#sec-rekey">Re-Keying Limits</a>)</p></li>
      </ol>
      <p class="" style="">Each MODP group has at least two well known constants: a large prime number p, and a generator g for a subgroup of GF(p). For each MODP group that Alice specifies she MUST perform the following computations to calculate her Diffie-Hellman keys (where n is the number of bits per cipher block for the block cipher algorithm with the largest block size out of those she specified):</p>
      <ol start="" type="">
        <li><p class="" style="">Generate a secret random number x (where 2<span class="super" style="">2n-1</span> &lt; x &lt; p - 1)</p></li>
        <li><p class="" style="">Calculate e = g<span class="super" style="">x</span> mod p</p></li>
      </ol>
      <p class="" style="">Alice MUST send all her calculated values of e to Bob. She MUST also specify randomly generated Base64 encoded (in accordance with Section 3 of <span class="ref" style="">RFC 3548</span>  [<a href="#nt-id2266024">26</a>]) value of N<span class="sub" style="">A</span> (her ESession ID).</p>
      <p class="caption">Example 3. Alice Requests an ESession</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x type='form' xmlns='jabber:x:data'&gt;
      &lt;field type="hidden" var="FORM_TYPE"&gt;
        &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
      &lt;/field&gt;
      &lt;field type="boolean" var="accept"&gt;
        &lt;value&gt;1&lt;/value&gt;
      &lt;/field&gt;
      &lt;field type="boolean" var="logging"&gt;
        &lt;value&gt;1&lt;/value&gt;
      &lt;/field&gt;
      &lt;field type="boolean" var="secure"&gt;
        &lt;value&gt;0&lt;/value&gt;
      &lt;/field&gt;
      &lt;field type="list-single" var="modp"&gt;
        &lt;option&gt;&lt;value&gt;5&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;14&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;2&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type="list-single" var="crypt_algs"&gt;
        &lt;option&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;twofish256-ctr&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;aes128-ctr&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type="list-single" var="hash_algs"&gt;
        &lt;option&gt;&lt;value&gt;whirlpool&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type="list-single" var="sign_algs"&gt;
        &lt;option&gt;&lt;value&gt;rsa&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;dsa&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type="list-single" var="compress"&gt;
        &lt;option&gt;&lt;value&gt;none&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type="list-multi" var="stanzas"&gt;
        &lt;option&gt;&lt;value&gt;message&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;iq&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;presence&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type="boolean" var="pk_hash"&gt;
        &lt;value&gt;0&lt;/value&gt;
      &lt;/field&gt;
      &lt;field type="list-single" var="ver"&gt;
        &lt;option&gt;&lt;value&gt;1.0&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;1.3&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type="text-single" var="rekey_freq"&gt;
        &lt;value&gt;1&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="my_nonce"&gt;
        &lt;value&gt; ** Base64 encoded ESession ID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="keys"&gt;
        &lt;value&gt; ** Base64 encoded value of e5 ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded value of e14 ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded value of e2 ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/feature&gt;
  &lt;amp xmlns='http://jabber.org/protocol/amp' per-hop='true'&gt;
    &lt;rule action='drop' condition='deliver' value='stored'/&gt;
  &lt;/amp&gt;
&lt;/message&gt;
      </pre></div>
      <p class="" style="">If Bob does not support one or more of the options in each ESession field, then he SHOULD return a &lt;feature-not-implemented/&gt; error (but he MAY return no error if, for example, he does not want to reveal his presence to Alice for whatever reason):</p>
      <p class="caption">Example 4. Bob Informs Alice that Her Options Are Not Supported</p>
<div class="indent"><pre>
&lt;message type='error'
         from='bob@example.com/laptop'
         to='alice@example.org/pda'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    ...
  &lt;/feature&gt;
  &lt;error type='cancel'&gt;
    &lt;feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
    &lt;unsupported-options xmlns='http://jabber.org/protocol/esession#error'/&gt;
  &lt;/error&gt;
&lt;/message&gt;
      </pre></div>
      <p class="" style="">Either Bob or Alice MAY attempt to initiate a new ESession after any error during the negotiation process. However, both MUST consider the previous negotiation to have failed and MUST discard any information learned through the previous negotiation.</p>
      <p class="" style="">If Bob is unwilling to start an ESession, but he <span style="font-style: italic">is</span> ready to initiate a one-to-one chat session with Alice (see <span style="font-weight: bold">Chat Session Negotiation</span>), then he SHOULD accept the Chat Session and terminate the ESession negotiation by <span style="font-style: italic">not</span> including a 'nonce' field in his response.</p>
      <p class="caption">Example 5. Bob Accepts Chat Session</p>
<div class="indent"><pre>
&lt;message from='bob@example.com/laptop' to='alice@example.org/pda'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      &lt;field var="FORM_TYPE"&gt;
        &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="accept"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/field&gt;
      &lt;field var="logging"&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var="secure"&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
    &lt;/x&gt;
  &lt;/feature&gt;
&lt;/message&gt;
      </pre></div>
    </div>
    <div class="indent">
<h3>8.1.2 <a name="init-online-bobprep">Diffie-Hellman Preparation (Bob)</a>
</h3>
      <p class="" style="">If Bob supports one or more of each of Alice's ESession options and is willing to start an ESession with Alice, then he MUST select one of the options from each of the ESession fields he received from Alice including one hash algorithm ("HASH"), and one of the MODP groups and Alice's corresponding value of e (see <span class="ref" style="">RFC 3766</span>  [<a href="#nt-id2266192">27</a>] or <span style="font-weight: bold">RFC 3526</span> for recommendations regarding balancing the sizes of symmetric cipher blocks and Diffie-Hellman moduli).</p>
      <p class="" style="">Each MODP group has at least two well known constants: a large prime number p, and a generator g for a subgroup of GF(p). Bob SHOULD return a &lt;feature-not-implemented/&gt; error unless: 1 &lt; e &lt; p - 1</p>
      <p class="" style="">Bob MUST then perform the following computations (where n is the number of bits per cipher block for the selected block cipher algorithm):</p>
      <ol start="1" type="">
        <li><p class="" style="">Generate a random number N<span class="sub" style="">B</span> (his ESession ID)</p></li>
        <li><p class="" style="">Generate an n-bit random number C<span class="sub" style="">A</span> (the block cipher counter for stanzas sent from Alice to Bob)</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> (where C<span class="sub" style="">B</span> is the block counter for stanzas sent from Bob to Alice)</p></li>
        <li><p class="" style="">Generate a secret random number y (where 2<span class="super" style="">2n-1</span> &lt; y &lt; p - 1)</p></li>
        <li><p class="" style="">Calculate d = g<span class="super" style="">y</span> mod p</p></li>
        <li><p class="" style="">Calculate K = HASH(e<span class="super" style="">y</span> mod p) (the shared secret)</p></li>
      </ol>
    </div>

    <div class="indent">
<h3>8.1.3 <a name="init-keys">Generating Session Keys</a>
</h3>
      <p class="" style="">Bob MUST use the shared secret ("K") and the selected hash algorithm ("HASH") to generate two sets of three keys, one set for each direction of the ESession.</p>
      <p class="" style="">For stanzas that Alice will send to Bob, the keys are calculated as:</p>
      <ol start="" type="">
        <li><p class="" style="">Encryption key KC<span class="sub" style="">A</span> = HASH(K, 0)</p></li>
        <li><p class="" style="">Integrity key KM<span class="sub" style="">A</span> = HASH(K, 2)</p></li>
        
        <li><p class="" style="">SIGMA key KS<span class="sub" style="">A</span> = HASH(K, 4)</p></li>
      </ol>
      <p class="" style="">For stanzas that Bob will send to Alice the keys are calculated as:</p>
      <ol start="4" type="">
        <li><p class="" style="">Encryption key KC<span class="sub" style="">B</span> = HASH(K, 1)</p></li>
        <li><p class="" style="">Integrity key KM<span class="sub" style="">B</span> = HASH(K, 3)</p></li>
        <li><p class="" style="">SIGMA key KS<span class="sub" style="">B</span> = HASH(K, 5)</p></li>
      </ol>
      <p class="" style="">Once the sets of keys have been calculated the value of K MUST be securely destroyed.</p>
      <p class="" style="">Note: As many bits of key data as are needed for each key MUST be taken from the least significant bits of the hash output. When negotiating a hash, entities MUST ensure that the hash output is no shorter than the required key data. For algorithms with variable-length keys the maximum length (up to the hash output length) SHOULD be used.</p>
    </div>

    <div class="indent">
<h3>8.1.4 <a name="init-hide">Hiding Identity</a>
</h3>
      <p class="" style="">Bob MUST perform the following steps before he can prove his identity to Alice while protecting it from third parties.</p>
      <ol start="" type="">
        <li><p class="" style="">Select pubKey<span class="sub" style="">B</span>, the public key Alice should use to authenticate his signature with the signature algorithm he selected ("SIGN"). Note: If the value of the 'pk_hash' field that Alice sent Bob was true then Bob SHOULD set pubKey<span class="sub" style="">B</span> to HASH(pubKey<span class="sub" style="">B</span>).</p></li>
        <li>
<p class="" style="">Set form<span class="sub" style="">B</span> to the <a href="#sign-normal">Normalized</a> <span style="font-style: italic">content</span> of the reponse data form he will send back to Alice (including his responses for all the fields he received from Alice).</p>
            <p class="" style="">Bob MUST encapsulate the Base64 encoded values of C<span class="sub" style="">A</span> and Alice's N<span class="sub" style="">A</span> in two new 'counter' and 'nonce' fields and add them to form<span class="sub" style="">B</span>. Note: The 'pk_hash' field specifies whether or not Alice MUST send the fingerprint (PKID) of her public signature-verification key instead of her full key. Note: The value of the 'rekey_freq' field MUST be less than 2<span class="super" style="">32</span> and greater than or equal to the value specified by Alice. Note: Bob MUST place his Base64 encoded values of N<span class="sub" style="">B</span> and d in the 'my_nonce' and 'keys' fields. Bob MUST NOT return Alice's values of e.</p>
</li>
        <li>
<p class="" style="">Concatenate Alice's ESession ID, Bob's ESession ID, d, pubKey<span class="sub" style="">B</span> and form<span class="sub" style="">B</span>, and calculate the HMAC (as defined in Section 2 of <span class="ref" style="">RFC 2104</span>  [<a href="#nt-id2266777">28</a>]) of the resulting byte string using the selected hash algorithm ("HASH") and the key KS<span class="sub" style="">B</span>.</p>
            <p class="caption"></p>
<div class="indent"><pre>mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">B</span>, {N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>, d, pubKey<span class="sub" style="">B</span>, form<span class="sub" style="">B</span>})</pre></div>
</li>
        <li>
<p class="" style="">Calculate sign<span class="sub" style="">B</span>, the signature of the HMAC result using his private signature key that corresponds to pubKey<span class="sub" style="">B</span></p>
            <p class="caption"></p>
<div class="indent"><pre>sign<span class="sub" style="">B</span> = SIGN(signKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>)</pre></div>
</li>
        <li>
<p class="" style="">Concatenate pubKey<span class="sub" style="">B</span> and sign<span class="sub" style="">B</span> and encrypt the resulting byte string with the agreed algorithm ("CIPHER") in counter mode (see <span class="ref" style=""> Recommendation for Block Cipher Modes of Operation</span>  [<a href="#nt-id2266963">29</a>]), using the encryption key KC<span class="sub" style="">B</span> and block counter C<span class="sub" style="">B</span>. Note: C<span class="sub" style="">B</span> MUST be incremented by 1 for each encrypted block or partial block (i.e. C<span class="sub" style="">B</span> = (C<span class="sub" style="">B</span> + 1) mod 2<span class="super" style="">n</span>, where n is the number of bits per cipher block for the agreed block cipher algorithm).</p>
            <p class="caption"></p>
<div class="indent"><pre>ID<span class="sub" style="">B</span> = CIPHER(KC<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, {pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>})</pre></div>
</li>
        <li>
<p class="" style="">Calculate the HMAC of the encrypted identity (ID<span class="sub" style="">B</span>) and the value of Bob's block cipher counter C<span class="sub" style="">B</span> <span style="font-style: italic">before</span> the encryption using the selected hash algorithm ("HASH") and the integrity key KM<span class="sub" style="">B</span>.</p>
            <p class="caption"></p>
<div class="indent"><pre>M<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)</pre></div>
</li>
      </ol>
    </div>

    <div class="indent">
<h3>8.1.5 <a name="init-online-response">ESession Response</a>
</h3>
    <p class="" style="">If Bob prefers the 3-message ESession negotiation, where Alice's identity is protected from active attacks instead of his own, then he should encapsulate the Base64 encoded values of ID<span class="sub" style="">B</span> and M<span class="sub" style="">B</span> in data form fields ('identity' and 'mac'), and append the new fields to form<span class="sub" style="">B</span>.</p>
    <p class="" style="">Bob responds to Alice by sending her form<span class="sub" style="">B</span>.</p>

    <p class="caption">Example 6. Bob Responds to Alice (3-Message Negotiation)</p>
<div class="indent"><pre>
&lt;message from='bob@example.com/laptop' to='alice@example.org/pda'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      &lt;field var="FORM_TYPE"&gt;
        &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="accept"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/field&gt;
      &lt;field var="logging"&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var="secure"&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var="modp"&gt;&lt;value&gt;5&lt;/value&gt;&lt;/field&gt;
      &lt;field var="crypt_algs"&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/field&gt;
      &lt;field var="hash_algs"&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/field&gt;
      &lt;field var="sign_algs"&gt;&lt;value&gt;rsa&lt;/value&gt;&lt;/field&gt;
      &lt;field var="compress"&gt;&lt;value&gt;none&lt;/value&gt;&lt;/field&gt;
      &lt;field var="stanzas"&gt;&lt;value&gt;message&lt;/value&gt;&lt;/field&gt;
      &lt;field var="pk_hash"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/field&gt;
      &lt;field var="ver"&gt;&lt;value&gt;1.3&lt;/value&gt;&lt;/field&gt;
      &lt;field var="rekey_freq"&gt;&lt;value&gt;50&lt;/value&gt;&lt;/field&gt;
      &lt;field var="my_nonce"&gt;
        &lt;value&gt; ** Base64 encoded ESession ID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="keys"&gt;
        &lt;value&gt; ** Base64 encoded value of d ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="nonce"&gt;
        &lt;value&gt; ** Base64 encoded ESession ID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="counter"&gt;
        &lt;value&gt; ** Base64 encoded block counter ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="identity"&gt;
        &lt;value&gt; ** Encrypted identity ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="mac"&gt;
        &lt;value&gt; ** Integrity of identity ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/feature&gt;
&lt;/message&gt;
    </pre></div>
    <p class="caption">Example 7. Bob Responds to Alice (4-Message Negotiation)</p>
<div class="indent"><pre>
&lt;message from='bob@example.com/laptop' to='alice@example.org/pda'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      &lt;field var="FORM_TYPE"&gt;
        &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="accept"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/field&gt;
      &lt;field var="logging"&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var="secure"&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var="modp"&gt;&lt;value&gt;5&lt;/value&gt;&lt;/field&gt;
      &lt;field var="crypt_algs"&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/field&gt;
      &lt;field var="hash_algs"&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/field&gt;
      &lt;field var="sign_algs"&gt;&lt;value&gt;rsa&lt;/value&gt;&lt;/field&gt;
      &lt;field var="compress"&gt;&lt;value&gt;none&lt;/value&gt;&lt;/field&gt;
      &lt;field var="stanzas"&gt;&lt;value&gt;message&lt;/value&gt;&lt;/field&gt;
      &lt;field var="pk_hash"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/field&gt;
      &lt;field var="ver"&gt;&lt;value&gt;1.3&lt;/value&gt;&lt;/field&gt;
      &lt;field var="rekey_freq"&gt;&lt;value&gt;50&lt;/value&gt;&lt;/field&gt;
      &lt;field var="my_nonce"&gt;
        &lt;value&gt; ** Base64 encoded ESession ID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="keys"&gt;
        &lt;value&gt; ** Base64 encoded value of d ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="nonce"&gt;
        &lt;value&gt; ** Base64 encoded ESession ID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="counter"&gt;
        &lt;value&gt; ** Base64 encoded block counter ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/feature&gt;
&lt;/message&gt;
    </pre></div>
    </div>

    <div class="indent">
<h3>8.1.6 <a name="init-online-aliceprep">Diffie-Hellman Preparation (Alice)</a>
</h3>
      <p class="" style="">After Alice receives Bob's response, she MUST use the value of d and the ESession options specified in Bob's response to perform the following steps (where p and g are the constants associated with the selected MODP group, HASH is the selected hash algorithm, and n is the number of bits per cipher block for the agreed block cipher algorithm):</p>
      <ol start="1" type="">
        <li><p class="" style="">Return a &lt;feature-not-implemented/&gt; error to Bob if she is not prepared to support any of the ESession options specified by Bob (if any of the options were not included in her initial ESession request)</p></li>
        <li><p class="" style="">Return a &lt;feature-not-implemented/&gt; error to Bob unless: 1 &lt; d &lt; p - 1</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> (where C<span class="sub" style="">B</span> is the block counter for stanzas sent from Bob to Alice)</p></li>
        <li><p class="" style="">Select her values of x and e that correspond to the selected MODP group (from all the values of x and e she calculated previously)</p></li>
        <li><p class="" style="">Calculate K = HASH(d<span class="super" style="">x</span> mod p) (the shared secret)</p></li>
        <li><p class="" style="">Generate the session keys (KC<span class="sub" style="">A</span>, KM<span class="sub" style="">A</span>, KS<span class="sub" style="">A</span>, KC<span class="sub" style="">B</span>, KM<span class="sub" style="">B</span> and KS<span class="sub" style="">B</span>) in the same way as Bob did (see <a href="#init-keys">Generating Session Keys</a>)</p></li>
      </ol>
    </div>
    <div class="indent">
<h3>8.1.7 <a name="init-online-bobid">Verifying Bob's Identity</a>
</h3>
      <p class="" style="">If Bob included 'identity' and 'mac' fields in his response then Alice MUST also perform the following steps:</p>
      <ol start="1" type="">
        <li>
<p class="" style="">Calculate the HMAC of the encrypted identity (ID<span class="sub" style="">B</span>) and the value of Bob's block cipher counter using HASH and the integrity key KM<span class="sub" style="">B</span>.</p>
            <p class="caption"></p>
<div class="indent"><pre>M<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)</pre></div>
</li>
        <li><p class="" style="">Return a &lt;feature-not-implemented/&gt; error to Bob unless the value of M<span class="sub" style="">B</span> she calculated matches the one she received in the 'mac' field</p></li>
        <li>
<p class="" style="">Obtain pubKey<span class="sub" style="">B</span> and sign<span class="sub" style="">B</span> by decrypting ID<span class="sub" style="">B</span> with the agreed symmetric block cipher algorithm ("DECIPHER") in counter mode, using the encryption key KC<span class="sub" style="">B</span> and block counter C<span class="sub" style="">B</span>. Note: C<span class="sub" style="">B</span> MUST be incremented by 1 for each encrypted block or partial block (i.e. C<span class="sub" style="">B</span> = (C<span class="sub" style="">B</span> + 1) mod 2<span class="super" style="">n</span>, where n is the number of bits per cipher block for the agreed block cipher algorithm).</p>
            <p class="caption"></p>
<div class="indent"><pre>{pubKey<span class="sub" style="">B</span>, sign<span class="sub" style="">B</span>} = DECIPHER(KC<span class="sub" style="">B</span>, C<span class="sub" style="">B</span>, ID<span class="sub" style="">B</span>)</pre></div>
</li>
        <li><p class="" style="">If the value of the 'pk_hash' field she sent to Bob in her <a href="#init-online-request">ESession Request</a> was true, then Alice SHOULD change the value of pubKey<span class="sub" style="">B</span> to be her copy of the public key whose HASH matches the value of pubKey<span class="sub" style="">B</span> that she received from Bob. Note: If she cannot find a copy of the public key then Alice MUST terminate the ESession. She MAY then request a new ESession with the 'pk_hash' field set to false.</p></li>
        <li><p class="" style="">Return a &lt;feature-not-implemented/&gt; error to Bob unless she can confirm (or has previously confirmed) that pubKey<span class="sub" style="">B</span> really is Bob's public key, for examples, via secure out-of-band communication, or through a third-party authority (see <a href="#sec-keys">Verifying Keys</a>).</p></li>
        <li><p class="" style="">Set the value of form<span class="sub" style="">B</span> to be the <a href="#sign-normal">Normalized</a> <span style="font-style: italic">content</span> of the form she received from Bob without the 'identity' and 'mac' fields.</p></li>
        <li>
<p class="" style="">Concatenate Alice's ESession ID, Bob's ESession ID, d, pubKey<span class="sub" style="">B</span> and form<span class="sub" style="">B</span>, and calculate the HMAC of the resulting byte string using HASH and the key KS<span class="sub" style="">B</span>.</p>
            <p class="caption"></p>
<div class="indent"><pre>mac<span class="sub" style="">B</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">B</span>, {N<span class="sub" style="">A</span>, N<span class="sub" style="">B</span>, d, pubKey<span class="sub" style="">B</span>, form<span class="sub" style="">B</span>})</pre></div>
</li>
        <li>
<p class="" style="">Return a &lt;feature-not-implemented/&gt; error to Bob unless she can use pubKey<span class="sub" style="">B</span> with the selected signature verification algorithm ("VERIFY") to confirm that sign<span class="sub" style="">B</span> is the signature of the HMAC result (see <a href="#sign">Signature Verification</a>).</p>
            <p class="caption"></p>
<div class="indent"><pre>VERIFY(sign<span class="sub" style="">B</span>, pubKey<span class="sub" style="">B</span>, mac<span class="sub" style="">B</span>)</pre></div>
</li>
      </ol>
    </div>

    <div class="indent">
<h3>8.1.8 <a name="init-online-complete">ESession Completion</a>
</h3>
      <p class="" style="">Alice MUST then prove her identity to Bob while protecting it from third parties. She MUST perform the steps equivalent to those Bob performed above (see <a href="#init-hide">Hiding Identity</a> for a more detailed description). Alice's calculations are summarised below (pay attention to the order of N<span class="sub" style="">B</span> and N<span class="sub" style="">A</span> when calculating mac<span class="sub" style="">A</span>). Note: form<span class="sub" style="">A</span> is the <a href="#sign-normal">Normalized</a> <span style="font-style: italic">content</span> of the <a href="#init-online-request">ESession Request</a> data form that she sent to Bob previously.</p>
      <p class="caption"></p>
<div class="indent"><pre>mac<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">A</span>, {N<span class="sub" style="">B</span>, N<span class="sub" style="">A</span>, e, pubKey<span class="sub" style="">A</span>, form<span class="sub" style="">A</span>})</pre></div>
      <p class="caption"></p>
<div class="indent"><pre>sign<span class="sub" style="">A</span> = SIGN(signKey<span class="sub" style="">A</span>, mac<span class="sub" style="">A</span>)</pre></div>
      <p class="caption"></p>
<div class="indent"><pre>ID<span class="sub" style="">A</span> = CIPHER(KC<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, {pubKey<span class="sub" style="">A</span>, sign<span class="sub" style="">A</span>})</pre></div>
      <p class="caption"></p>
<div class="indent"><pre>M<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)</pre></div>

      <p class="" style="">Alice MUST send the Base64 encoded values of N<span class="sub" style="">B</span>, ID<span class="sub" style="">A</span> and M<span class="sub" style="">A</span> to Bob. If Alice has already confirmed Bob's identity (i.e. if Bob included 'identity' and 'mac' fields in his response), then she MAY also send encrypted content (see <a href="#exchange">Exchanging Stanzas</a>) in the same stanza as the proof of her identity.</p>
      <p class="caption">Example 8. Alice Sends Bob Her Identity</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x type='result' xmlns='jabber:x:data'&gt;
      &lt;field var="FORM_TYPE"&gt;&lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;&lt;/field&gt;
      &lt;field var="nonce"&gt;&lt;value&gt; ** Base64 encoded ESession ID ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var="identity"&gt;&lt;value&gt; ** Encrypted identity ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var="mac"&gt;&lt;value&gt; ** Integrity of identity ** &lt;/value&gt;&lt;/field&gt;
    &lt;/x&gt;
  &lt;/feature&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
      </pre></div>
      <p class="" style="">If Alice also includes a &lt;terminate/&gt; element (see <a href="#terminate">ESession Termination</a>) within the &lt;encrypted/&gt; element then the ESession is terminated immediately. Note: This special case, where a single stanza is encrypted and sent in isolation, is equivalent to object encryption (or object signing if no encryption is specified).</p>
      <p class="" style="">After receiving Alice's identity Bob MUST verify it by performing steps equivalent to those described in the section <a href="#init-online-bobid">Verifying Bob's Identity</a> above. Bob's calculations are summarised below (pay attention to the order of N<span class="sub" style="">B</span> and N<span class="sub" style="">A</span> when calculating mac<span class="sub" style="">A</span>). Note: form<span class="sub" style="">A</span> is the <a href="#sign-normal">Normalized</a> <span style="font-style: italic">content</span> of the <a href="#init-online-request">ESession Request</a> data form (the <span style="font-style: italic">first</span> form) that Alice sent him. Note: If Bob sends an error to Alice then he SHOULD ignore any encrypted content he received in the stanza.</p>
      <p class="caption"></p>
<div class="indent"><pre>M<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)</pre></div>
      <p class="caption"></p>
<div class="indent"><pre>{pubKey<span class="sub" style="">A</span>, sign<span class="sub" style="">A</span>} = DECIPHER(KC<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, ID<span class="sub" style="">A</span>)</pre></div>
      <p class="caption"></p>
<div class="indent"><pre>mac<span class="sub" style="">A</span> = <span style="font-style: italic">HMAC</span>(HASH, KS<span class="sub" style="">A</span>, {N<span class="sub" style="">B</span>, N<span class="sub" style="">A</span>, e, pubKey<span class="sub" style="">A</span>, form<span class="sub" style="">A</span>})</pre></div>
      <p class="caption"></p>
<div class="indent"><pre>VERIFY(sign<span class="sub" style="">A</span>, pubKey<span class="sub" style="">A</span>, mac<span class="sub" style="">A</span>)</pre></div>
      <p class="" style="">If Alice has already confirmed Bob's identity (i.e. if Bob included 'identity' and 'mac' fields in his response above), then the ESession negotiation is complete.</p>
      <p class="" style="">Otherwise, one more step is necessary. Bob MUST send Alice the Base64 encoded values of N<span class="sub" style="">A</span>, ID<span class="sub" style="">B</span> and M<span class="sub" style="">B</span> that he calculated previously (see <a href="#init-hide">Hiding Identity</a>). Note: He MAY also send encrypted content (see <a href="#exchange">Exchanging Stanzas</a>) in the same stanza.</p>
      <p class="caption">Example 9. Bob Sends Alice His Identity</p>
<div class="indent"><pre>
&lt;message from='bob@example.com/laptop' to='alice@example.org/pda'&gt;
  &lt;init xmlns='http://jabber.org/protocol/esession#init'&gt;
    &lt;x type='result' xmlns='jabber:x:data'&gt;
      &lt;field var="FORM_TYPE"&gt;&lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;&lt;/field&gt;
      &lt;field var="nonce"&gt;&lt;value&gt; ** Base64 encoded ESession ID ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var="identity"&gt;&lt;value&gt; ** Encrypted identity ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var="mac"&gt;&lt;value&gt; ** Integrity of identity ** &lt;/value&gt;&lt;/field&gt;
    &lt;/x&gt;
  &lt;/init&gt;
&lt;/message&gt;
      </pre></div>
      <p class="" style="">After receiving Bob's identity Alice MUST verify it by performing steps described in the section <a href="#init-online-bobid">Verifying Bob's Identity</a> above. Note: If Alice sends an error to Bob then she SHOULD ignore any encrypted content she received in the stanza.</p>
    </div>
  </div>

<div class="indent">
<h3>8.2 <a name="init-offline">Offline Diffie-Hellman Key Exchange</a>
</h3>
  <p class="" style="">As described below, offline negotiation of an ESession is in essence a special case of 3-message online ESession negotiation. Alice MAY publish a set of ESession options just before she goes offline (see <a href="#sec-offline">Offline ESessions</a> Security Considerations) to allow entities that subscribe to her presence to initiate ESessions and send encrypted stanzas to her while she is offline. She MAY also publish <span style="font-style: italic">another</span> similar set of relatively long-lived  [<a href="#nt-id2268780">30</a>] ESession options that any entity MAY use for the same purpose.</p>
    <div class="indent">
<h3>8.2.1 <a name="init-offline-publish">Publishing ESession Options</a>
</h3>
      <p class="" style="">In order to publish either set of her offline ESession options Alice MUST create an options data form in exactly the same way as she would create an <a href="#init-online-request">ESession Request</a> data form except she MUST omit The 'accept' and 'pk_hash' fields. Note: The list of stanza types she is willing to decrypt MUST NOT include the value 'iq'.</p>
      <p class="" style="">Alice MUST store her value of N<span class="sub" style="">A</span> (her ESession ID) and all her values of x (one for each MODP group) in a secure way, so that she can retrieve them when she comes back online (idealy even if that is using a different client and/or a different machine)</p>
      <p class="" style="">If Alice would not be able to decrypt stanzas if she came back online using a different client and/or a different machine then she SHOULD also encapsulate the resource of her client in a 'match_resource' field and append it to her options data form. In this case, the list of stanza types she is willing to decrypt MUST include only 'message'.</p>
      <p class="" style="">Alice MUST also append to the content of the form the list of the fingerprints (PKIDs) of all her public signature-verification keys that she can sign for in a 'pkids' field, and the corresponding list of signatures (see <a href="#sign">Signature Generation</a>) of the <span style="font-style: italic">content</span> of the data form (excluding the 'signs' field).</p>
      <p class="" style="">Alice MUST publish the ESession options data form through her own server using <span class="ref" style="">Simplified Personal Publish-Subscribe</span>  [<a href="#nt-id2268910">31</a>].</p>
      <p class="" style=""><span style="font-style: italic">Note: Version 0.1 of the SPPS protocol is Experimental, planned modifications will allow access to be limited to subscribers.</span></p>
      <p class="caption">Example 10. Alice Publishes Her ESession Options for Her Subscribers</p>
<div class="indent"><pre>
&lt;iq type='set' from='alice@example.org/pda' id='es2'&gt;
  &lt;pubsub xmlns='http://jabber.org/protocol/pubsub'&gt;
    &lt;publish node='http://jabber.org/protocol/esession#subscription'&gt;
      &lt;item&gt;
        &lt;x type='form' xmlns='jabber:x:data'&gt;
          &lt;field type="hidden" var="FORM_TYPE"&gt;
            &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
          &lt;/field&gt;
          &lt;field type="boolean" var="logging"&gt;
            &lt;value&gt;1&lt;/value&gt;
          &lt;/field&gt;
          &lt;field type="boolean" var="secure"&gt;
            &lt;value&gt;0&lt;/value&gt;
          &lt;/field&gt;
          &lt;field type="list-single" var="modp"&gt;
            &lt;option&gt;&lt;value&gt;5&lt;/value&gt;&lt;/option&gt;
            &lt;option&gt;&lt;value&gt;14&lt;/value&gt;&lt;/option&gt;
            &lt;option&gt;&lt;value&gt;2&lt;/value&gt;&lt;/option&gt;
          &lt;/field&gt;
          &lt;field type="list-single" var="crypt_algs"&gt;
            &lt;option&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/option&gt;
            &lt;option&gt;&lt;value&gt;twofish256-ctr&lt;/value&gt;&lt;/option&gt;
            &lt;option&gt;&lt;value&gt;aes128-ctr&lt;/value&gt;&lt;/option&gt;
          &lt;/field&gt;
          &lt;field type="list-single" var="hash_algs"&gt;
            &lt;option&gt;&lt;value&gt;whirlpool&lt;/value&gt;&lt;/option&gt;
            &lt;option&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/option&gt;
          &lt;/field&gt;
          &lt;field type="list-single" var="sign_algs"&gt;
            &lt;option&gt;&lt;value&gt;rsa&lt;/value&gt;&lt;/option&gt;
            &lt;option&gt;&lt;value&gt;dsa&lt;/value&gt;&lt;/option&gt;
          &lt;/field&gt;
          &lt;field type="list-single" var="compress"&gt;
            &lt;option&gt;&lt;value&gt;none&lt;/value&gt;&lt;/option&gt;
          &lt;/field&gt;
          &lt;field type="list-multi" var="stanzas"&gt;
            &lt;option&gt;&lt;value&gt;message&lt;/value&gt;&lt;/option&gt;
          &lt;/field&gt;
          &lt;field type="list-single" var="ver"&gt;
            &lt;option&gt;&lt;value&gt;1.0&lt;/value&gt;&lt;/option&gt;
            &lt;option&gt;&lt;value&gt;1.3&lt;/value&gt;&lt;/option&gt;
          &lt;/field&gt;
          &lt;field type="text-single" var="rekey_freq"&gt;
            &lt;value&gt;1&lt;/value&gt;
          &lt;/field&gt;
          &lt;field var="my_nonce"&gt;
            &lt;value&gt; ** Base64 encoded ESession ID ** &lt;/value&gt;
          &lt;/field&gt;
          &lt;field var="keys"&gt;
            &lt;value&gt; ** Base64 encoded value of e5 ** &lt;/value&gt;
            &lt;value&gt; ** Base64 encoded value of e14 ** &lt;/value&gt;
            &lt;value&gt; ** Base64 encoded value of e2 ** &lt;/value&gt;
          &lt;/field&gt;
          &lt;field var="match_resource"&gt;
            &lt;value&gt;pda&lt;/value&gt;
          &lt;/field&gt;
          &lt;field var="pkids"&gt;
            &lt;value&gt; ** PKID ** &lt;/value&gt;
            &lt;value&gt; ** PKID ** &lt;/value&gt;
          &lt;/field&gt;
          &lt;field var="signs"&gt;
            &lt;value&gt; ** signature of form ** &lt;/value&gt;
            &lt;value&gt; ** signature of form ** &lt;/value&gt;
          &lt;/field&gt;
        &lt;/x&gt;
      &lt;/item&gt;
    &lt;/publish&gt;
  &lt;/pubsub&gt;
&lt;/iq&gt;
  </pre></div>
      <p class="" style="">Alice MAY publish her ESession options for all entities using the same protocol except for the 'node' attribute of the &lt;publish/&gt; element:</p>
      <p class="caption">Example 11. Alice Publishes Her ESession Options for All Entities</p>
<div class="indent"><pre>
&lt;iq type='set' from='alice@example.org/pda' id='es3'&gt;
  &lt;pubsub xmlns='http://jabber.org/protocol/pubsub'&gt;
    &lt;publish node='http://jabber.org/protocol/esession'&gt;
      ...
    &lt;/publish&gt;
  &lt;/pubsub&gt;
&lt;/iq&gt;
  </pre></div>
    </div>
    <div class="indent">
<h3>8.2.2 <a name="init-offline-request">Requesting Offline ESession Options</a>
</h3>
      <p class="" style="">If Bob believes Alice is offline he SHOULD request her ESession options and her long-term public signature-verification keys (see <a href="#keys">Public Key Publication and Retrieval</a>) from her server using <span style="font-weight: bold">Simplified Personal Publish-Subscribe</span>.</p>
      <p class="" style=""><span style="font-style: italic">Note: Version 0.1 of the SPPS protocol is Experimental, planned modifications will allow the persistence and retrieval of the last published item.</span></p>
      <p class="" style="">If Bob is subscribing to Alice's presence he MUST request her ESession Options exclusively for subscribers.</p>
      <p class="caption">Example 12. Bob asks Alice's Server for her ESession Options (Subscribers)</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='bob@example.com/laptop'
    to='alice@example.org'
    id='es4'&gt;
  &lt;pubsub xmlns='http://jabber.org/protocol/pubsub'&gt;
    &lt;get node='http://jabber.org/protocol/esession#subscription'/&gt;
  &lt;/pubsub&gt;
&lt;/iq&gt;
  </pre></div>
      <p class="" style="">If Bob is not subscribing to Alice's presence (or if Alice has no ESession options exclusively for subscribers) he MUST use the following request instead.</p>
      <p class="caption">Example 13. Bob asks Alice's Server for her ESession Options (All Entities)</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='bob@example.com/laptop'
    to='alice@example.org'
    id='es4'&gt;
  &lt;pubsub xmlns='http://jabber.org/protocol/pubsub'&gt;
    &lt;get node='http://jabber.org/protocol/esession'/&gt;
  &lt;/pubsub&gt;
&lt;/iq&gt;
  </pre></div>
      <p class="" style="">If, after receiving Alice's public keys and ESession options, Bob is unable to verify any of Alice's signatures of her offline options data form (see <a href="#sign">Signature Verification</a>) then he MAY decide to proceed no further, since he cannot be sure who will be able to decrypt his stanzas.</p>
      <p class="" style="">If Bob does not support one or more of the options in each Alice's ESession fields, then he MUST NOT send encrypted stanzas to her while she is offline.</p>
    </div>

    <div class="indent">
<h3>8.2.3 <a name="init-offline-start">Starting an Offline ESession</a>
</h3>
      <p class="" style="">Bob MUST now continue as if Alice had requested an online ESession, performing the steps described in three of the online negotiation sections:</p>
      <ol start="1" type="">
        <li><p class="" style=""><a href="#init-online-bobprep">Diffie-Hellman Preparation (Bob)</a> Note: If the value of e he selected is not valid, Bob SHOULD terminate the ESession <span style="font-style: italic">without</span> sending an error.</p></li>
        <li><p class="" style=""><a href="#init-keys">Generating Session Keys</a></p></li>
        <li><p class="" style=""><a href="#init-hide">Hiding Identity</a> Note: Since Bob did not receive a 'pk_hash' field, he MUST assume its value is false. Bob SHOULD NOT include a 'pk_hash' field in form<span class="sub" style="">B</span> since Alice has already proved her identity.</p></li>
      </ol>
      <p class="" style="">As with 3-message ESession negotiation, Bob should encapsulate the Base64 encoded values of ID<span class="sub" style="">B</span> and M<span class="sub" style="">B</span> in data form fields ('identity' and 'mac'), and append the new fields to form<span class="sub" style="">B</span>.</p>
      <p class="" style="">Bob MAY also send encrypted content (see the <a href="#exchange">Exchanging Stanzas</a> section of this document) in the same stanza. Note: If he also includes a &lt;terminate/&gt; element (see <a href="#terminate">ESession Termination</a>) within the &lt;encrypted/&gt; element then the ESession is terminated immediately. This special case, where a single stanza is encrypted and sent in isolation, is equivalent to object encryption (or object signing if no encryption is specified).</p>
      <p class="" style="">If Alice included a 'match_resource' field in her ESession options, then Bob MUST address all the stanzas he sends within the offline ESession to the specified resource and use the <span style="font-weight: bold">Advanced Message Processing</span> protocol to ensure that they are not delivered to any other resource.</p>
      <p class="" style="">After sending form<span class="sub" style="">B</span> to Alice, Bob can assume that the ESession negotiation is complete.</p>
      <p class="caption">Example 14. Bob Establishes an ESession Without Negotiation</p>
<div class="indent"><pre>
&lt;message from='bob@example.com/laptop' to='alice@example.org/pda' type='chat'&gt;
  &lt;init xmlns='http://jabber.org/protocol/esession#init'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      &lt;field var="FORM_TYPE"&gt;
        &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="logging"&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var="secure"&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var="modp"&gt;&lt;value&gt;5&lt;/value&gt;&lt;/field&gt;
      &lt;field var="crypt_algs"&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/field&gt;
      &lt;field var="hash_algs"&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/field&gt;
      &lt;field var="sign_algs"&gt;&lt;value&gt;rsa&lt;/value&gt;&lt;/field&gt;
      &lt;field var="compress"&gt;&lt;value&gt;none&lt;/value&gt;&lt;/field&gt;
      &lt;field var="stanzas"&gt;&lt;value&gt;message&lt;/value&gt;&lt;/field&gt;
      &lt;field var="ver"&gt;&lt;value&gt;1.3&lt;/value&gt;&lt;/field&gt;
      &lt;field var="rekey_freq"&gt;&lt;value&gt;50&lt;/value&gt;&lt;/field&gt;
      &lt;field var="my_nonce"&gt;
        &lt;value&gt; ** Base64 encoded ESession ID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="keys"&gt;
        &lt;value&gt; ** Base64 encoded value of d ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="nonce"&gt;
        &lt;value&gt; ** Base64 encoded ESession ID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="counter"&gt;
        &lt;value&gt; ** Base64 encoded block counter ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="identity"&gt;
        &lt;value&gt; ** Encrypted identity ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="mac"&gt;
        &lt;value&gt; ** Integrity of identity ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/init&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
  &lt;amp xmlns='http://jabber.org/protocol/amp'&gt;
    &lt;rule action='??????' condition='match-resource' value='exact'/&gt;
  &lt;/amp&gt;
&lt;/message&gt;
    </pre></div>
    </div>
    <div class="indent">
<h3>8.2.4 <a name="init-offline-accept">Accepting Offline ESessions</a>
</h3>
      <p class="" style="">When Alice comes online she MUST perform the following steps:</p>
      <ol start="" type="">
        <li>
<p class="" style="">Ensure she is no longer publishing offline ESession options exclusively for entities that are subscribing to her presence.</p>
            <p class="caption">Example 15. Alice Stops Publishing Her ESession Options</p>
<div class="indent"><pre>
&lt;iq type='set' from='alice@example.org/pda' id='es5'&gt;
  &lt;pubsub xmlns='http://jabber.org/protocol/pubsub'&gt;
    &lt;publish node='http://jabber.org/protocol/esession#subscription'&gt;
      &lt;item/&gt;
    &lt;/publish&gt;
  &lt;/pubsub&gt;
&lt;/iq&gt;
  </pre></div>
        </li>
        <li><p class="" style="">Retrieve any values of N<span class="sub" style="">A</span> and x (one for each MODP group for each N<span class="sub" style="">A</span>) that she stored before going offline, and destroy in a secure way any persistently stored copies that correspond to ESession options exclusively for subscribers.</p></li>
      </ol>
      <p class="" style="">When Alice receives an offline ESession request stanza from Bob then she MUST perform the following steps:</p>
      <ol start="" type="">
        <li><p class="" style="">Select her value of x that corresponds to the 'nonce' and 'modp' fields she received from Bob.  [<a href="#nt-id2269432">32</a>]</p></li>
        <li><p class="" style="">Confirm that she has not already received a key exchange stanza from Bob with the same value of d or N<span class="sub" style="">B</span> ('my_nonce' field) since she published her ESession options (see <a href="#sec-replay">Replay Attacks</a>). If the options were for subscribers, that means since she came online.</p></li>
        <li>
<p class="" style="">Alice MUST now continue as if Bob had responded to her online ESession request, performing the steps described in two of the online negotiation sections:</p>
        <ul>
          <li><p class="" style=""><a href="#init-online-aliceprep">Diffie-Hellman Preparation (Alice)</a> Note: If she is not prepared to support any of the ESession options specified by Bob, or if the value of d she selected is not valid, then Alice SHOULD terminate the ESession <span style="font-style: italic">without</span> sending an error.</p></li>
          <li><p class="" style=""><a href="#init-online-bobid">Verifying Bob's Identity</a> Note: Since Alice did not send a 'pk_hash' field to Bob, she MUST assume its value is false. If the value of M<span class="sub" style="">B</span> she calculated does not match the one she received, or if she cannot confirm that pubKey<span class="sub" style="">B</span> really is Bob's public key, or if she cannot confirm that sign<span class="sub" style="">B</span> is the signature of the HMAC result, then Alice SHOULD terminate the ESession <span style="font-style: italic">without</span> sending an error.</p></li>
        </ul>
</li>
      </ol>
    </div>
  </div>
<h2>9.
       <a name="exchange">Exchanging Stanzas</a>
</h2>
  <div class="indent">
<h3>9.1 <a name="exchange-separate">Encryptable Content</a>
</h3>
    <p class="" style="">Once ESession negotiation is complete, Alice and Bob MUST exchange only encrypted forms of the one-to-one stanza types they agreed upon (e.g., &lt;message/&gt; and &lt;iq/&gt; stanzas).</p>
    <p class="" style="">Whenever Alice wants to send Bob an encrypted stanza she MUST only encrypt the XML content that would normally be ignored by the intermediate servers. She MUST NOT encrypt stanza wrapper elements or <span style="font-weight: bold">Advanced Message Processing</span> elements.</p>
    <p class="" style="">If this is an offline ESession then Alice SHOULD include a 'Created' SHIM header in the encrypted content. Bob SHOULD trust this header and ignore the unencrypted <span class="ref" style="">Delayed Delivery</span>  [<a href="#nt-id2269632">33</a>] element inserted by his server.</p>

  <p class="caption">Example 16. Unencrypted Stanza</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda'
         to='bob@example.com/laptop'
         type='chat'&gt;
  &lt;body&gt;Hello, Bob!&lt;/body&gt;
  &lt;amp xmlns='http://jabber.org/protocol/amp'&gt;
    &lt;rule action='error' condition='match-resource' value='exact'/&gt;
  &lt;/amp&gt;
  &lt;headers xmlns='http://jabber.org/protocol/shim'&gt;
    &lt;header name='Created'&gt;2005-02-10T03:01:52Z&lt;/header&gt;
  &lt;/headers&gt;
  &lt;active xmlns='http://jabber.org/protocol/chatstates'/&gt;
&lt;/message&gt;
</pre></div>

  <p class="caption">Example 17. XML Content to be Encrypted</p>
<div class="indent"><pre>
&lt;body&gt;Hello, Bob!&lt;/body&gt;
&lt;headers xmlns='http://jabber.org/protocol/shim'&gt;
  &lt;header name='Created'&gt;2005-02-10T03:01:52Z&lt;/header&gt;
&lt;/headers&gt;
&lt;active xmlns='http://jabber.org/protocol/chatstates'/&gt;
</pre></div>
  </div>
  <div class="indent">
<h3>9.2 <a name="exchange-encrypt">Encryption</a>
</h3>

    <p class="" style="">Alice MUST perform the following steps to encrypt the XML content. Note: if there is no XML content to be encrypted (e.g. if this is an empty <a href="#rekey">Re-Keying</a> or <a href="#terminate">Termination</a> stanza), then C<span class="sub" style="">A</span> MUST be incremented by 1 (see below), and only the last two steps (normalization and MAC calculation) should be performed.</p>
    <ol start="1" type="">
      <li><p class="" style="">Serialize the XML content she wishes to send into an array of UTF-8 bytes, m.  [<a href="#nt-id2269709">34</a>]</p></li>
      <li>
        <p class="" style="">Compress m using the negotiated algorithm. If a compression algorithm other than 'none' was agreed, the compression context is typically initialized after key exchange and passed from one stanza to the next, with only a partial flush at the end of each stanza.  [<a href="#nt-id2269729">35</a>]</p>
        <p class="caption"></p>
<div class="indent"><pre>m_compressed = compress(m)</pre></div>
      </li>
      <li>
        <p class="" style="">Encrypt the data with the agreed algorithm in counter mode, using the encryption key KC<span class="sub" style="">A</span>. Note: C<span class="sub" style="">A</span> MUST be incremented by 1 for each encrypted block or partial block (i.e. C<span class="sub" style="">A</span> = (C<span class="sub" style="">A</span> + 1) mod 2<span class="super" style="">n</span>, where n is the number of bits per cipher block for the agreed block cipher algorithm). Note: if the block cipher algorithm 'none' was agreed (see <a href="#sec-unencrypted">Unencrypted ESessions</a>) then encryption MUST NOT be performed and C<span class="sub" style="">A</span> MUST be incremented by 1 (for replay protection).</p>
        <p class="caption"></p>
<div class="indent"><pre>m_final = encrypt(KC<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, m_compressed)</pre></div>
      </li>
      <li>
        <p class="" style="">Alice MUST now create the <a href="#sign-normal">Normalized</a> XML <span style="font-style: italic">content</span> of the &lt;encrypted/&gt; XML element. If there is encrypted XML content, the XML MUST include the Base64 encoded value of m_final wrapped in a &lt;data/&gt; element. Note: the &lt;encrypted/&gt; element MAY also contain one &lt;terminate/&gt; element (see <a href="#terminate">Termination</a>), one &lt;key/&gt; element and one or more &lt;old/&gt; elements (see <a href="#rekey">Re-Keying</a>).</p>
        <p class="caption"></p>
<div class="indent"><pre>m_content = '&lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;'</pre></div>
      </li>
      <li>
        <p class="" style="">The XML content and the value of Alice's block cipher counter C<span class="sub" style="">A</span> <span style="font-style: italic">before</span> the data was encrypted, are now processed through the HMAC algorithm, along with the agreed hash algorithm ("HASH") and the integrity key KM<span class="sub" style="">A</span>.</p>
        <p class="caption"></p>
<div class="indent"><pre>a_mac = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">A</span>, m_content, C<span class="sub" style="">A</span>)</pre></div>
      </li>
    </ol>

  </div>
  <div class="indent">
<h3>9.3 <a name="exchange-send">Sending an Encrypted Stanza</a>
</h3>
    <p class="" style="">Before sending the stanza to Bob, Alice MUST wrap m_content and the Base64 encoded value of a_mac (wrapped in a &lt;mac/&gt; element) inside an &lt;encrypted/&gt; element and insert it into the stanza in place of the original content. There MUST NOT be more than one &lt;encrypted/&gt; element per stanza.</p>
    <p class="caption">Example 18. Message Stanza with Encrypted Content</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda'
         to='bob@example.com/laptop'
         type='chat'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
  &lt;amp xmlns='http://jabber.org/protocol/amp' per-hop='true'&gt;
    &lt;rule action='error' condition='match-resource' value='exact'/&gt;
  &lt;/amp&gt;
&lt;/message&gt;
    </pre></div>
  </div>
  <div class="indent">
<h3>9.4 <a name="exchange-decrypt">Decryption</a>
</h3>

    <p class="" style="">When Bob receives the stanza from Alice, he extracts and Base64 decodes the values of m_final and a_mac from the content and performs the following steps.</p>
    <ol start="1" type="">
      <li>
        <p class="" style="">Remove the &lt;mac/&gt; element from the &lt;encrypted/&gt; element and <a href="#sign-normal">Normalize</a> the remaining XML <span style="font-style: italic">content</span>. Calculate the Message Authentication Code (MAC) for the content.</p>
        <p class="caption"></p>
<div class="indent"><pre>b_mac = <span style="font-style: italic">HMAC</span>(HASH, KM<span class="sub" style="">A</span>, m_content, C<span class="sub" style="">A</span>)</pre></div>
      </li>
      <li>
        <p class="" style="">Verify that b_mac and a_mac match. If they are not identical, the content has been tampered with and Bob MUST terminate the ESession, he MAY send a &lt;not-acceptable/&gt; error to Alice.  [<a href="#nt-id2270086">36</a>]</p>
      </li>
      <li>
        <p class="" style="">Decrypt m_final using the agreed algorithm, KC<span class="sub" style="">A</span> and C<span class="sub" style="">A</span>. Note: C<span class="sub" style="">A</span> MUST be incremented by 1 for each decrypted block (see <a href="#exchange-encrypt">Encryption</a>). Note: if the block cipher algorithm 'none' was agreed decryption MUST NOT be performed and C<span class="sub" style="">A</span> MUST be incremented by 1.</p>
        <p class="caption"></p>
<div class="indent"><pre>m_compressed = decrypt(KC<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, m_final)</pre></div>
      </li>
      <li>
        <p class="" style="">Decompress m_compressed using the negotiated algorithm (usually 'none').</p>
        <p class="caption"></p>
<div class="indent"><pre>m = decompress(m_compressed)</pre></div>
      </li>
      <li>
        <p class="" style="">Replace the &lt;encrypted/&gt; element in the serialized XML stanza with m and feed the stanza into an XML parser. If the parser returns an XML format error then Bob MUST terminate the ESession, he MAY send a &lt;not-acceptable/&gt; error to Alice.  [<a href="#nt-id2270262">37</a>]</p>
      </li>
    </ol>
  </div>
  <h2>10.
       <a name="rekey">Re-Key Exchange</a>
</h2>
<p class="" style="">Once an attacker has discovered an encryption key it could be used to decrypt all stanzas within a session, including stanzas that were intercepted <span style="font-style: italic">before</span> the key was discovered. To reduce the window of vulnerability, both Alice and Bob SHOULD change their values of x and y and re-exchange the encryption key as regularly as possible. They MUST also destroy all copies of keys as soon as they are no longer needed.</p>
<p class="" style="">Note: Although most entities are capable of re-keying after each stanza, clients running in constrained runtime environments may require a few seconds to re-key. During ESession negotiation these clients MAY negotiate the minimum number of stanzas to be exchanged between re-keys at the cost of a larger window of vulnerability. Entities MUST NOT initiate key re-exchanges more frequently than the agreed limit.</p>

  <div class="indent">
<h3>10.1 <a name="rekey-init">Re-Key Initiation</a>
</h3>
    <p class="" style="">Either Alice or Bob MAY initiate a key re-exchange. Here we describe the process initiated by Alice. First she MUST calculate new values for the encryption parameters:</p>
    <ol start="1" type="">
      <li><p class="" style="">Generate a secret random number x (where 2<span class="super" style="">2n-1</span> &lt; x &lt; p - 1, where n is the number of bits per cipher block for the agreed block cipher algorithm)</p></li>
      <li><p class="" style="">Calculate e = g<span class="super" style="">x</span> mod p</p></li>
      <li><p class="" style="">Calculate K = d<span class="super" style="">x</span> mod p (the new shared secret)</p></li>
      <li><p class="" style="">Calculate KC<span class="sub" style="">A</span>, KM<span class="sub" style="">A</span>, KC<span class="sub" style="">B</span>, KM<span class="sub" style="">B</span> from K (see <a href="#init-keys">Generating Session Keys</a>)</p></li>
    </ol>
    <p class="" style="">To avoid extra stanzas, the new value of e SHOULD be sent to Bob along with an encrypted stanza. Note: Alice MUST NOT use the new KC<span class="sub" style="">A</span> and KM<span class="sub" style="">A</span> to encrypt this stanza or to calculate the MAC. However, she MUST use them when sending subsequent stanzas.</p>
    <p class="" style="">Note: There is no need for Alice to provide a signature because the calculation of the MAC includes the new value of e, see <a href="#exchange">Exchanging Stanzas</a>).</p>
    <p class="caption">Example 19. Alice Sends Re-Key Stanza</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;key&gt; ** Base64 encoded value of new e ** &lt;/key&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">Note: Bob may not receive the new key before he sends his next stanzas (they may cross in transit). So, before destroying her old values of KC<span class="sub" style="">B</span> and KM<span class="sub" style="">B</span>, Alice MUST wait until either she receives a stanza encrypted with the new key, or a reasonable time has passed (60 seconds should cover a network round-trip and calculations by a constrained client). Similarly she MUST wait before destroying her old value of x, in case Bob sends two stanzas before receiving Alice's new key (the first stanza might include a re-key).</p>
  </div>
  <div class="indent">
<h3>10.2 <a name="rekey-accept">Re-Key Acceptance</a>
</h3>
    <p class="" style="">After Bob receives a stanza with a new value of e and confirmed it is greater than one, and he has decrypted the stanza with the old value of KC<span class="sub" style="">A</span>, he MUST securely destroy all copies of KC<span class="sub" style="">A</span> and KC<span class="sub" style="">B</span> and perform the following calculations with the new value of e:</p>
    <ol start="1" type="">
      <li><p class="" style="">Calculate K = e<span class="super" style="">y</span> mod p</p></li>
      <li><p class="" style="">Calculate KC<span class="sub" style="">A</span>, KM<span class="sub" style="">A</span>, KC<span class="sub" style="">B</span>, KM<span class="sub" style="">B</span> from K (see <a href="#init-keys">Generating Session Keys</a>)</p></li>
    </ol>
    <p class="" style="">He MUST use these new values to encrypt and decrypt all subsequent stanzas.  [<a href="#nt-id2270626">38</a>]</p>
    <p class="" style="">The next time Bob sends Alice a stanza he MUST specify the number of rekeys he has received from her since he sent her his last stanza. He does that by setting the 'rekeys' attribute of the &lt;data/&gt; element. Note: The default value of the 'rekeys' attribute is zero.</p>
    <p class="caption">Example 20. Bob's First Stanza After Receiving a Re-Key</p>
<div class="indent"><pre>
&lt;message from='bob@example.com/laptop' to='alice@example.org/pda'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data rekeys='1'&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** Base64 encoded b_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">When Alice receives the stanza from Bob she MUST use the 'rekeys' attribute to decide which of her values of KC<span class="sub" style="">B</span> and KM<span class="sub" style="">B</span> (or x) she should use to decrypt the stanza - otherwise she would not know if Bob received her rekey(s) before he sent the stanza. Once she is sure Bob has received her rekey(s) she MUST discard all her older values of KC<span class="sub" style="">B</span>, KM<span class="sub" style="">B</span> and x.</p>
  </div>
  <div class="indent">
<h3>10.3 <a name="rekey-publish">Publishing Old MAC Values</a>
</h3>
    <p class="" style="">Once the expired MAC keys have been published, anyone could create valid arbitrary stanzas with them. This prevents anyone being able to prove the authenticity of a transcript of the ESession in the future.</p>
    <p class="" style="">Either entity MAY publish old values of KM<span class="sub" style="">A</span> and/or KM<span class="sub" style="">B</span> within any encrypted stanza as long as it knows that all the stanzas that MAY use the old values have been received and validated. Note: A 'man-in-the-middle' could delay the delivery of stanzas indefinitely. So, before Alice publishes KM<span class="sub" style="">A</span> (and KM<span class="sub" style="">B</span>), she MUST wait until she has both sent a re-key to Bob and received a stanza from Bob encrypted with her new key. (She MAY also publish KM<span class="sub" style="">B</span> after she has received a re-key from Bob.)</p>
    <p class="caption">Example 21. Publishing Expired MAC Keys</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;old&gt; ** Base64 encoded old MAC key ** &lt;/old&gt;
    &lt;old&gt; ** Base64 encoded old MAC key ** &lt;/old&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">Entities SHOULD ignore any &lt;old/&gt; elements they receive.</p>
  </div>
  <h2>11.
       <a name="terminate">ESession Termination</a>
</h2>
    <p class="" style="">Either entity MAY terminate an ESession at any time. Entities MUST terminate all open ESessions before they go offline. To terminate an ESession Alice MUST send a stanza to Bob including a &lt;terminate/&gt; element with content "1"  [<a href="#nt-id2270833">39</a>]. Note: She MAY publish old values of KM<span class="sub" style="">A</span> and/or KM<span class="sub" style="">B</span> within her termination stanza as long as she is sure all the stanzas that MAY use the old values have been received and validated (see <a href="#rekey-publish">Publishing Old MAC Values</a>). She MUST then securely destroy all keys associated with the ESession.</p>
    <p class="caption">Example 22. Alice Terminates an ESession</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;terminate&gt;1&lt;/terminate&gt;
    &lt;old&gt; ** Base64 encoded old MAC key ** &lt;/old&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">When Bob receives a termination stanza he MUST verify the MAC (to be sure he received all the stanzas Alice sent him during the ESession) and, if the stanza was sent to him while he was online, immediately send a termination stanza back to Alice. Note: He MAY publish <span style="font-style: italic">any</span> old values of KM<span class="sub" style="">A</span> or KM<span class="sub" style="">B</span> within the termination stanza. He MUST then securely destroy all keys associated with the ESession.</p>
    <p class="caption">Example 23. Bob Confirms ESession Termination</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;terminate&gt;1&lt;/terminate&gt;
    &lt;old&gt; ** Base64 encoded old MAC key ** &lt;/old&gt;
    &lt;mac&gt; ** Base64 encoded b_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">When Alice receives the stanza she MUST verify the MAC to be sure she received all the stanzas Bob sent her during the ESession. Once an entity has sent a termination stanza it MUST NOT send another stanza within the ESession.</p>
    <p class="" style="">Note: If Alice notices that Bob comes online during her offline ESession with him then she MUST terminate the ESession immediately. If required she may then negotiate a new (more secure) online ESession.</p>
    <p class="" style="">Note: Bob MUST NOT send encrypted content within an ESession started by Alice. If Alice is conducting an offline ESession with Bob when he is online (e.g., if she is not subscribing to his presence), then if Bob wants to send a stanza to Alice, he MUST terminate the offline ESession and start a new online ESession first.</p>
  <h2>12.
       <a name="sign">Signature Generation and Verification</a>
</h2>
  <div class="indent">
<h3>12.1 <a name="sign-normal">XML Normalization</a>
</h3>
    <p class="" style="">Before the signature or MAC of a block of XML is generated or verified, all character data <span style="font-style: italic">between</span> all elements MUST be removed and the XML MUST be converted to canonical form (see <span class="ref" style="">Canonical XML</span>  [<a href="#nt-id2271020">40</a>]).</p>
    <p class="" style="">All the XML this protocol requires to be signed or MACed is very simple, so in this case, canonicalization SHOULD only require the following changes:</p>
    <ul>
      <li>Set attribute value delimiters to quotation marks (i.e. simply replace all single quotes in the serialized XML with double quotes)</li>
      <li>Impose lexicographic order on the attributes of "field" elements (i.e. ensure "type" is before "var")</li>
    </ul>
    <p class="" style="">Implementations MAY conceivably also need to make the following changes. Note: Empty elements and special characters SHOULD NOT appear in the signed or MACed XML specified in this protocol.</p>
    <ul>
      <li>Ensure there are no character references</li>
      <li>Convert empty elements to start-end tag pairs</li>
      <li>Ensure there is no whitespace except for single spaces before attributes</li>
    </ul>
  </div>
  <div class="indent">
<h3>12.2 <a name="sign-hash">Hash</a>
</h3>
    <p class="" style="">Before the signature or MAC of a block of XML is generated or verified, the agreed hash algorithm MUST be used to generate the hash of the normalized XML.</p>
    <p class="caption"></p>
<div class="indent"><pre>m_hash = HASH(m_content)</pre></div>
  </div>
  <div class="indent">
<h3>12.3 <a name="sign-calc">Generation</a>
</h3>
    <p class="" style="">The signature generation depends on the type of private key being used.</p>
    <div class="indent">
<h3>12.3.1 <a name="sign-rsa-gen">RSA</a>
</h3>
      <p class="caption"></p>
<div class="indent"><pre>signature_rsa = rsa_sign(rsa_private_key, m_hash, hashOID)</pre></div>
      <p class="" style="">The multiprecision integer signature_rsa is the signature (see <span class="ref" style="">RFC 3447</span>  [<a href="#nt-id2271144">41</a>]).</p>
    </div>
    <div class="indent">
<h3>12.3.2 <a name="sign-dsa-gen">DSA</a>
</h3>
      <p class="caption"></p>
<div class="indent"><pre>sig_dsa_r, sig_dsa_s = dsa_sign(dsa_private_key, m_hash)</pre></div>
      <p class="" style="">The multiprecision integers sig_dsa_r and sig_dsa_s are the signature (see <span class="ref" style="">Digital Signature Standard</span>  [<a href="#nt-id2271198">42</a>]).</p>
    </div>
  </div>
  <div class="indent">
<h3>12.4 <a name="sign-format">Signature Format</a>
</h3>
    <p class="" style="">The signature formats are the same for all public key formats. All integers are stored in big-endian byte order.</p>
    <div class="indent">
<h3>12.4.1 <a name="sign-rsa-format">RSA</a>
</h3>
      <p class="" style="">Base64 encoding of the signature_rsa multiprecision integer (without any header or length prefix).</p>
    </div>
    <div class="indent">
<h3>12.4.2 <a name="sign-dsa-format">DSA</a>
</h3>
      <p class="" style="">Base64 encoding of the following structure:</p>
      <ul>
        <li>number of bytes in sig_dsa_r (2-byte integer)</li>
        <li>sig_dsa_r</li>
        <li>number of bytes in sig_dsa_s (2-byte integer)</li>
        <li>sig_dsa_s</li>
      </ul>
    </div>
  </div>
  <div class="indent">
<h3>12.5 <a name="sign-calc">Verification</a>
</h3>
    <p class="" style="">The signature verification depends on the type of public key being used.</p>
    <div class="indent">
<h3>12.5.1 <a name="sign-rsa-verify">RSA</a>
</h3>
      <p class="" style="">The rsa_modulus and rsa_public_exponent multiprecision integers are extracted from the other entity's authenticated public key. The signature_rsa multiprecision integer is the signature received from the other entity.</p>
      <p class="caption"></p>
<div class="indent"><pre>boolean = rsa_verify(signature_rsa, m_hash, hashOID, rsa_modulus, rsa_public_exponent)</pre></div>
    </div>
    <div class="indent">
<h3>12.5.2 <a name="sign-dsa-verify">DSA</a>
</h3>
      <p class="" style="">The dsa_p, dsa_q, dsa_g and dsa_y multiprecision integers are extracted from the other entity's authenticated public key. The sig_dsa_r and sig_dsa_s multiprecision integers are the signature received from the other entity.</p>
      <p class="caption"></p>
<div class="indent"><pre>boolean = dsa_verify(sig_dsa_r, sig_dsa_s, m_hash, dsa_p, dsa_q, dsa_g, dsa_y)</pre></div>
    </div>
  </div>
  <h2>13.
       <a name="sec">Security Considerations</a>
</h2>
  <div class="indent">
<h3>13.1 <a name="sec-prng">Random Numbers</a>
</h3>
    <p class="" style="">Weak pseudo-random number generators (PRNG) enable successful attacks. Implementors MUST use a cryptographically strong PRNG to generate all random numbers (see <span class="ref" style="">RFC 1750</span>  [<a href="#nt-id2271377">43</a>]).</p>
  </div>
  <div class="indent">
<h3>13.2 <a name="sec-rekey">Re-Keying Limits</a>
</h3>
    <p class="" style="">After a key exchange an entity MUST NOT exchange a total of 2<span class="super" style="">32</span> encrypted blocks before it initiates a key re-exchange (see <span class="ref" style="">SSH Transport Layer Encryption Modes</span>  [<a href="#nt-id2271425">44</a>]). Note: This limitation also ensures the same key and counter values are never used to encrypt two different blocks using counter mode (thus preventing simple attacks).</p>
    <p class="" style="">In order to reduce the Perfect Forward Secrecy window of vulnerability, after an extended period of activity, entities SHOULD either re-key or terminate the ESession.</p>
  </div>
  <div class="indent">
<h3>13.3 <a name="sec-keys">Verifying Keys</a>
</h3>
    <p class="" style="">The trust system outlined in this document is based on Alice trusting that the public key presented by Bob is <span style="font-style: italic">actually</span> Bob's key (and vice versa). Determining this trust may be done in a variety of ways depending on the entities' support for different public key (certificate) formats, signing algorithms and signing authorities. For instance, if Bob publishes a PGP/GPG public key, Alice MAY verify that his key is signed by another key that she knows to be good. Or, if Bob provides an X.509 certificate, she MAY check that his key has been signed by a Certificate Authority that she trusts.</p>
    <p class="" style="">When trust cannot be achieved automatically, methods that are not transparent to the users may be employed. For example, Bob could communicate the SHA-256 fingerprint of his public key to Alice via secure out-of-band communication (e.g. face-to-face). This would enable Alice to confirm that the public key she receives in-band is valid. Note however that very few people bother to verify fingerprints in this way. So this method is exceptionally vulnerable to 'man-in-the-middle' attacks. In order to reduce the window of vulnerability, an entity SHOULD remember the fingerprints of all user-validated public keys and alert the user in the future if ever the fingerprint(s) it stored for an entity do not match any of the received public keys.</p>
    <p class="" style="">Alternatively Alice and Bob could agree a shared secret via secure out-of-band communication, Bob could then use it to create an HMAC of his public key that only Alice could verify.</p>
    <p class="" style="">Note: If no keys are acceptable to Alice (because Alice has never verified any of the keys, and because either the keys are not signed, or Alice does not support the signature algorithms of the keys, or she cannot parse the certificate formats, or she does not recognise the authorities that signed the keys) then, although the ESession can still be encrypted, she cannot be sure she is communicating with Bob.</p>
  </div>
  <div class="indent">
<h3>13.4 <a name="sec-replay">Replay Attacks</a>
</h3>
    <p class="" style="">The block cipher counters maintained implicitly by Alice and Bob (C<span class="sub" style="">A</span> and C<span class="sub" style="">B</span>) prevent stanzas being replayed within any ESession. They ensure that the MAC will be different for all stanzas, even if the HMAC key and the content of the stanza are identical.</p>
    <p class="" style="">Alice and Bob MUST ensure that the value of e or d they provide when negotiating each online ESession is unique. This prevents complete online ESessions being replayed.</p>
    <p class="" style="">Since Alice supplies the same set of values of e for all offline ESessions, to prevent complete offline ESessions being replayed to her, she MUST take care to securely store <span style="font-style: italic">new</span> values (or destroy existing values) of N<span class="sub" style="">A</span> and x for subscribers whenever she goes offline (see <a href="#init-publish">Publishing ESession Options</a>). Also, when Alice comes online again, she MUST remember all the values of d he receives in offline ESession negotiation stanzas, and reject any offline ESessions that specify a value of d she has already received (see <a href="#init-accept">Accepting an Offline ESession</a>).</p>
    <p class="" style="">Note: If Alice publishes ESession options for non-subscribers, and if she does not update them whenever she comes online then, until she updates the options, she MUST save all the values of d she receives to secure persistent storage (along with the values of N<span class="sub" style="">A</span> and x).</p>
  </div>
  <div class="indent">
<h3>13.5 <a name="sec-offline">Offline ESessions</a>
</h3>
    <p class="" style="">Alice MAY decide not to support Offline ESessions since they are significantly less secure than online ESessions. The Perfect Forward Secrecy window of vulnerability is much longer. More seriously, Alice MUST store her private Diffie-Hellman keys, x<span class="sub" style="">1</span>...x<span class="sub" style="">Z</span>, to local disk or to a server (perhaps symmetrically encrypted with a password). It is <span style="font-style: italic">really</span> hard to securely erase something from a disk.</p>
    <p class="" style="">Note: If Alice does not support Offline ESessions then, while she is offline, Bob, or Aunt Tillie, will probably send her completely unprotected messages!</p>
  </div>
  <div class="indent">
<h3>13.6 <a name="sec-unencrypted">Unencrypted ESessions</a>
</h3>
    <p class="" style="">Organisations with full disclosure policies may require entities to disable encryption to enable the logging of all messages on their server. Unencrypted ESessions meet all the <a href="#reqs-sec">Security Requirements</a> except for Confidentiality. This enables Alice to use the 'secure' ESession option to confirm securely with Bob that both client-server connections are secure.</p>
  </div>
  <div class="indent">
<h3>13.7 <a name="sec-storage">Storage</a>
</h3>
    <p class="" style="">If either entity stores a (re-encrypted) transcript of an ESession for future consultation then the Perfect Forward Secrecy offered by this protocol is lost. If the negotiated value of the 'logging' <span style="font-weight: bold">Chat Session Negotiation</span> field is false the entities SHOULD NOT store any part of the ESession content (not even in encrypted form).</p>
  </div>
  <div class="indent">
<h3>13.8 <a name="sec-general">Extra Responsabilities of Implementors</a>
</h3>
    <p class="" style="">Cryptography plays only a small part in an entity's security. Even if it implements this protocol perfectly it may still be vulnerable to other attacks. For examples, an implementation might store ESession keys on swap space or save private keys to a file in cleartext! Implementors MUST take very great care when developing applications with secure technologies.</p>
  </div>
  <div class="indent">
<h3>13.9 <a name="sec-mandatory">Mandatory to Implement Technologies</a>
</h3>
    <p class="" style="">An implementation of ESession MUST support the Diffie-Hellman Key Agreement and HMAC algorithms. Note: The parameter names mentioned below are related to secure shell; see <span style="font-weight: bold">SSH Transport Layer Encryption Modes</span> for block cipher algorithm details; see the <span class="ref" style="">IANA Secure Shell Protocol Parameters Registry</span>  [<a href="#nt-id2271798">45</a>] for other names.</p>
    <div class="indent">
<h3>13.9.1 <a name="sec-mandatory-encryption">Block Cipher Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support at least the following block cipher algorithm:</p>
      <ul>
        <li>aes128-ctr (see <span class="ref" style="">Advanced Encryption Standard</span>  [<a href="#nt-id2271845">46</a>])</li>
      </ul>
      <p class="" style="">The block length of an block cipher algorithm's cipher SHOULD be at least 128 bits. An implementation of ESession MAY also support the following block cipher algorithms:</p>
      <ul>
        <li>aes256-ctr</li>
        <li>aes192-ctr</li>
        <li>twofish256-ctr (see <span class="ref" style="">Twofish</span>  [<a href="#nt-id2271890">47</a>])</li>
        <li>twofish192-ctr</li>
        <li>twofish128-ctr</li>
        <li>serpent256-ctr (see <span class="ref" style="">Serpent</span>  [<a href="#nt-id2271924">48</a>])</li>
        <li>serpent192-ctr</li>
        <li>serpent128-ctr</li>
        <li>none (no encryption, only signing)</li>
      </ul>
    </div>
    <div class="indent">
<h3>13.9.2 <a name="sec-mandatory-sign">Key Signing Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support at least the following signing algorithm:</p>
      <ul>
        <li>rsa (see <span style="font-weight: bold">RFC 3447</span>)</li>
      </ul>
      <p class="" style="">An implementation of ESession SHOULD also support at least the following signing algorithm:</p>
      <ul>
        <li>dsa (see <span style="font-weight: bold">Digital Signature Standard</span>)</li>
      </ul>
    </div>
    <div class="indent">
<h3>13.9.3 <a name="sec-mandatory-public">Public Signature-Verification-Key Formats</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support the following public key formats:</p>
      <ul>
        <li>ssh-rsa</li>
      </ul>
      <p class="" style="">An implementation of ESession SHOULD also support at least the following public key formats:</p>
      <ul>
        <li>ssh-dss</li>
        <li>x509v3-sign-rsa (see <span class="ref" style="">X.509 Authentication in SSH2</span>  [<a href="#nt-id2272042">49</a>])</li>
        <li>x509v3-sign-dss</li>
        <li>pgp-sign-rsa</li>
        <li>pgp-sign-dss</li>
      </ul>
      <p class="" style="">An implementation of ESession MAY also support the following public key formats:</p>
      <ul>
        <li>spki-sign-rsa</li>
        <li>spki-sign-dss</li>
      </ul>
    </div>
    <div class="indent">
<h3>13.9.4 <a name="sec-mandatory-hash">Hash Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support the following hash algorithm:</p>
      <ul>
        <li>sha256 (see <span class="ref" style="">Secure Hash Standard</span>  [<a href="#nt-id2272119">50</a>])</li>
      </ul>
      <p class="" style="">An implementation of ESession SHOULD also support at least the following hash algorithm (sha1 and md5 are NOT RECOMMENDED):</p>
      <ul>
        <li>whirlpool (see <span class="ref" style="">Whirlpool</span>  [<a href="#nt-id2272162">51</a>])</li>
      </ul>
    </div>
    <div class="indent">
<h3>13.9.5 <a name="sec-mandatory-compress">Compression Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support the following compression algorithm:</p>
      <ul>
        <li>none (no compression, the output MUST be the same as the input)</li>
      </ul>
      <p class="" style="">Support for other algorithms is NOT RECOMMENDED since compression partially defeats the <a href="#reqs-repudiate">Repudiability</a> requirement of this JEP by making it more difficult for a third party (with some knowledge of the plaintext) to modify a transcript of an encrypted session in a meaningful way. However, encrypted content is pseudo-random and cannot be compressed, so, in those cases where bandwidth is severely constrained, an implementation of ESession MAY support the following algorithms to compress content before it is encrypted:</p>
      <ul>
        <li>lzw (see <span class="ref" style="">Standard ECMA-151</span>  [<a href="#nt-id2272232">52</a>])</li>
        <li>zlib (see <span class="ref" style="">RFC 1950</span>  [<a href="#nt-id2272258">53</a>])</li>
      </ul>
    </div>
  </div>
<h2>14.
       <a name="iana">IANA Considerations</a>
</h2>
  <p class="" style="">This JEP requires no interaction with the <span class="ref" style="">Internet Assigned Numbers Authority (IANA)</span>  [<a href="#nt-id2272299">54</a>]. </p>
<h2>15.
       <a name="registrar">Jabber Registrar Considerations</a>
</h2>
  <div class="indent">
<h3>15.1 <a name="registrar-ns">Namespaces</a>
</h3>
    <p class="" style="">Upon approval of this JEP, the <span class="ref" style="">Jabber Registrar</span>  [<a href="#nt-id2272385">55</a>] shall register the following namespaces:</p>
    <ul>
      <li>http://jabber.org/protocol/esession</li>
      <li>http://jabber.org/protocol/esession#init</li>
      <li>http://jabber.org/protocol/esession#error</li>
    </ul>
  </div>
  <div class="indent">
<h3>15.2 <a name="registrar-formtype">Field Standardization</a>
</h3>
    <p class="" style=""><span class="ref" style="">Field Standardization for Data Forms</span>  [<a href="#nt-id2272407">56</a>] defines a process for standardizing the fields used within Data Forms qualified by a particular namespace. The following fields shall be registered for use in <span style="font-style: italic">both</span> Encrypted Sessions and Chat Session Negotiation:</p>
    <p class="caption">Registry Submission</p>
<div class="indent"><pre>
&lt;form_type&gt;
  &lt;name&gt;http://jabber.org/protocol/esession&lt;/name&gt;
  &lt;jep&gt;JEP-0116&lt;/jep&gt;
  &lt;desc&gt;ESession negotiation forms&lt;/desc&gt;
  &lt;field
      var='match_resource'
      type='text-single'
      label='Target resource for offline ESessions'/&gt;
  &lt;field
      var='secure'
      type='boolean'
      label='Require encrypted client-server streams'/&gt;
  &lt;field
      var='modp'
      type='list-single'
      label='MODP group number'/&gt;
  &lt;field
      var='crypt_algs'
      type='list-single'
      label='Symmetric block cipher options'/&gt;
  &lt;field
      var='hash_algs'
      type='list-single'
      label='Hash algorithm options'/&gt;
  &lt;field
      var='sign_algs'
      type='list-single'
      label='Signature algorithm options'/&gt;
  &lt;field
      var='compress'
      type='list-single'
      label='Compression algorithm options'/&gt;
  &lt;field
      var='stanzas'
      type='list-multi'
      label='Stanzas types to encrypt'/&gt;
  &lt;field
      var='pk_hash'
      type='boolean'
      label='Respond with public key fingerprint'/&gt;
  &lt;field
      var='ver'
      type='list-single'
      label='Supported versions of JEP-0116'/&gt;
  &lt;field
      var='rekey_freq'
      type='text-single'
      label='Minimum number of stanzas between key exchanges'/&gt;
  &lt;field
      var='keys'
      type='hidden'
      label='Diffie-Hellman keys'/&gt;
  &lt;field
      var='my_nonce'
      type='hidden'
      label='ESession ID of Sender'/&gt;
  &lt;field
      var='nonce'
      type='hidden'
      label='ESession ID of Receiver'/&gt;
  &lt;field
      var='counter'
      type='hidden'
      label='Initial block counter'/&gt;
  &lt;field
      var='pkids'
      type='list-single'
      label='Public key IDs'/&gt;
  &lt;field
      var='signs'
      type='list-single'
      label='Data form signatures'/&gt;
&lt;/form_type&gt;

&lt;form_type&gt;
  &lt;name&gt;http://jabber.org/protocol/chatneg&lt;/name&gt;
  &lt;jep&gt;JEP-0155&lt;/jep&gt;
  ...
&lt;/form_type&gt;
    </pre></div>
  </div>
<h2>16.
       <a name="schema">XML Schemas</a>
</h2>
  <p class="" style="">To follow.</p>
<h2>17.
       <a name="acknowledgments">Acknowledgments</a>
</h2>
  <p class="" style="">The authors would like to thank Ian Goldberg for the time he spent reviewing this protocol and for his invaluable suggestions and comments.</p>
<h2>18.
       <a name="keys">Public Key Publication and Retrieval</a>
</h2>
  <p class="" style=""><span style="font-style: italic">Note: This section is depricated and will be specified in a separate proposal before this document reaches draft status.</span></p>
  <p class="" style="">Entities SHOULD publish their long-term public signature-verification keys to all entities through their own server using SPPS.</p>
  <p class="caption">Example 24. Entity Publishes Public Keys to Server</p>
<div class="indent"><pre>
&lt;iq type='set' from='alice@example.org/pda' id='dp1'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/publickeys'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      &lt;field var='FORM_TYPE'&gt;
        &lt;value&gt;http://jabber.org/protocol/publickeys&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='types'&gt;
        &lt;value&gt;x509v3-sign-rsa&lt;/value&gt;
        &lt;value&gt;pgp-sign-dss&lt;/value&gt;
        &lt;value&gt;ssh-rsa&lt;/value&gt;
        &lt;value&gt;ssh-dss&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='keys'&gt;
        &lt;value&gt; ** Base64 encoded x509 certificate containing RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded OpenPGP certificate containing DSS public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded unsigned RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded unsigned DSS public key ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>

  <p class="" style="">Before initiating an ESession, if Bob does not already possess one of Alice's signature-verification keys, he SHOULD retrieve them from Alice's server.</p>
  <p class="caption">Example 25. Bob Requests Public Keys from Alice's Server</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='bob@example.com/laptop'
    to='alice@example.org'
    id='dp2'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/publickeys'/&gt;
&lt;/iq&gt;
  </pre></div>

  <p class="caption">Example 26. Server Returns Public Keys</p>
<div class="indent"><pre>
&lt;iq type='result'
    from='alice@example.org'
    to='bob@example.com/laptop'
    id='dp2'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/publickeys'&gt;
    &lt;x type='result' xmlns='jabber:x:data'&gt;
      &lt;field var='FORM_TYPE'&gt;
        &lt;value&gt;http://jabber.org/protocol/publickeys&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='types'&gt;
        &lt;value&gt;x509v3-sign-rsa&lt;/value&gt;
        &lt;value&gt;pgp-sign-dss&lt;/value&gt;
        &lt;value&gt;ssh-rsa&lt;/value&gt;
        &lt;value&gt;ssh-dss&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='keys'&gt;
        &lt;value&gt; ** Base64 encoded x509 certificate containing RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded OpenPGP certificate containing DSS public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded unsigned RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded unsigned DSS public key ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
  <p class="" style="">Bob should examine all the public keys and identify which ones are acceptable (see <a href="#sec-keys">Verifying Keys</a>).</p>
<h2>19.
       <a name="open">Open Issues</a>
</h2>
  <div class="indent">
<h3>19.1 <a name="open-tothink">To Think About</a>
</h3>
    <ol start="" type="">
      <li>Split Offline ESessions into another JEP?</li>
      <li>Standardise on the X.509 public key and signature formats?</li>
      <li>What challenges exist to make the OTR Gaim Plugin use this protocol natively when talking to Jabber entities? Can these be mitigated by 'non-critical' protocol changes?</li>
      <li>Would anything in this protocol (e.g., its dependency on in-order stanza delivery) prevent an XMPP entity using it to exchange encrypted messages and presence with a user of a non-XMPP messaging system, assuming that the gateway both supports this protocol and is compatible with a purpose-built security plugin on the other user's client (e.g. a Gaim plugin connects to the gateway via a non-XMPP network)?</li>
      <li>Could use <span class="ref" style="">Flexible Offline Message Retrieval</span>  [<a href="#nt-id2272656">57</a>] (FOMR) instead of AMP to prevent any offline ESessions Bob can't decrypt being delivered to him. (Each &lt;item/&gt; that corresponds to an ESession message would have to contain a &lt;ESessionID/&gt; child, to allow Bob to discover which of his stored values of y was used to encrypt the message.)</li>
    </ol>
  </div>
  <div class="indent">
<h3>19.2 <a name="open-todo">To Do</a>
</h3>
    <ol start="" type="">
      <li>Ask the authors of AMP to explain how to achieve the match_resource functionality to be specified here.</li>
      <li>Separate public key publishing into another JEP. Should there be a separate SPPS node for each key?</li>
      <li>Define names for X.509 SubjectPublicKeyInfo public key formats (different to X.509 certificates). This format must be used when keys are distributed within session negotiation.</li>
      <li>Add non-repudiable signing option</li>
      <li>Move "secure" field to JEP-0155</li>
      <li>Perhaps the JEP needs to specify more carefully how block counters are handled between messages, especially in the event of partial blocks?</li>
      <li>Give examples of specific errors and discuss error scenarios throughout document (e.g., what should Bob do if he is not offline and he receives an offline key exchange stanza?).</li>
      <li>Update Dependencies list</li>
      <li>Define an <span style="font-style: italic">optional</span> protocol that would allow Alice to store values of N<span class="sub" style="">A</span> and x (and the PKIDs she trusts) 'securely' on her own server (before she goes offline).</li>
    </ol>
  </div>
<p><hr></p>
<a name="notes"></a><h2>Notes</h2>
<div class="indent">
<p><a name="nt-id2250801">1</a>. JEP-0027: Current Jabber OpenPGP Usage &lt;<a href="http://www.jabber.org/jeps/jep-0027.html">http://www.jabber.org/jeps/jep-0027.html</a>&gt;.</p>
<p><a name="nt-id2250832">2</a>. RFC 3862: Common Presence and Instant Messaging (CPIM): Message Format &lt;<a href="http://www.ietf.org/rfc/rfc3862.txt">http://www.ietf.org/rfc/rfc3862.txt</a>&gt;.</p>
<p><a name="nt-id2250855">3</a>. RFC 3863: Presence Information Data Format (PIDF) &lt;<a href="http://www.ietf.org/rfc/rfc3863.txt">http://www.ietf.org/rfc/rfc3863.txt</a>&gt;.</p>
<p><a name="nt-id2250878">4</a>. RFC 3923: End-to-End Signing and Object Encryption for the Extensible Messaging and Presence Protocol (XMPP) &lt;<a href="http://www.ietf.org/rfc/rfc3923.txt">http://www.ietf.org/rfc/rfc3923.txt</a>&gt;.</p>
<p><a name="nt-id2250926">5</a>. Off-the-Record Communication, or, Why Not to Use PGP &lt;<a href="http://www.isaac.cs.berkeley.edu/~iang/pubs/otr-wpes.pdf">http://www.isaac.cs.berkeley.edu/~iang/pubs/otr-wpes.pdf</a>&gt;.</p>
<p><a name="nt-id2250961">6</a>. RFC 3920: Extensible Messaging and Presence Protocol (XMPP): Core &lt;<a href="http://www.ietf.org/rfc/rfc3920.txt">http://www.ietf.org/rfc/rfc3920.txt</a>&gt;.</p>
<p><a name="nt-id2256505">7</a>. RFC 3921: Extensible Messaging and Presence Protocol (XMPP): Instant Messaging and Presence &lt;<a href="http://www.ietf.org/rfc/rfc3921.txt">http://www.ietf.org/rfc/rfc3921.txt</a>&gt;.</p>
<p><a name="nt-id2256558">8</a>. RFC 2246: The TLS Protocol Version 1.0 &lt;<a href="http://www.ietf.org/rfc/rfc2246.txt">http://www.ietf.org/rfc/rfc2246.txt</a>&gt;.</p>
<p><a name="nt-id2256605">9</a>. JEP-0096: File Transfer &lt;<a href="http://www.jabber.org/jeps/jep-0096.html">http://www.jabber.org/jeps/jep-0096.html</a>&gt;.</p>
<p><a name="nt-id2256626">10</a>. JEP-0079: Advanced Message Processing &lt;<a href="http://www.jabber.org/jeps/jep-0079.html">http://www.jabber.org/jeps/jep-0079.html</a>&gt;.</p>
<p><a name="nt-id2256662">11</a>. JEP-0045: Multi-User Chat &lt;<a href="http://www.jabber.org/jeps/jep-0045.html">http://www.jabber.org/jeps/jep-0045.html</a>&gt;.</p>
<p><a name="nt-id2256691">12</a>. JEP-0060: Publish-Subscribe &lt;<a href="http://www.jabber.org/jeps/jep-0060.html">http://www.jabber.org/jeps/jep-0060.html</a>&gt;.</p>
<p><a name="nt-id2256793">13</a>. SSH Protocol Architecture &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-architecture-22.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-architecture-22.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2256814">14</a>. SSH Transport Layer Protocol &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-transport-24.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-transport-24.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2257044">15</a>. The reliable association between an entity and its public keys is beyond the scope of this JEP.</p>
<p><a name="nt-id2257094">16</a>. Naturally, it is possible that Alice or Bob may retain cleartext versions of the exchanged communications; however, that threat is out of scope for this JEP.</p>
<p><a name="nt-id2250414">17</a>. SIGMA: the 'SIGn-and-MAc' Approach to Authenticated Diffie-Hellman and its Use in the IKE Protocols (Hugo Krawczyk, June 12 2003) &lt;<a href="http://web.archive.org/web/20040409013835/http://www.ee.technion.ac.il/~hugo/sigma.ps">http://www.ee.technion.ac.il/~hugo/sigma.ps</a>&gt;.</p>
<p><a name="nt-id2250401">18</a>. Like <span style="font-weight: bold">RFC 2409</span>, this protocol uses <span style="font-style: italic">variant (ii)</span>, as described in Secion 5.4 of the <span style="font-weight: bold">SIGMA</span> paper.</p>
<p><a name="nt-id2257553">19</a>. RFC 2409: The Internet Key Exchange (IKE) &lt;<a href="http://www.ietf.org/rfc/rfc2409.txt">http://www.ietf.org/rfc/rfc2409.txt</a>&gt;.</p>
<p><a name="nt-id2257575">20</a>. Internet Key Exchange (IKEv2) Protocol &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-ipsec-ikev2-17.txt">http://www.ietf.org/internet-drafts/draft-ietf-ipsec-ikev2-17.txt</a>&gt;.</p>
<p><a name="nt-id2265567">21</a>. JEP-0030: Service Discovery &lt;<a href="http://www.jabber.org/jeps/jep-0030.html">http://www.jabber.org/jeps/jep-0030.html</a>&gt;.</p>
<p><a name="nt-id2265594">22</a>. JEP-0115: Entity Capabilities &lt;<a href="http://www.jabber.org/jeps/jep-0115.html">http://www.jabber.org/jeps/jep-0115.html</a>&gt;.</p>
<p><a name="nt-id2265686">23</a>. RFC 2631: Diffie-Hellman Key Agreement Method &lt;<a href="http://www.ietf.org/rfc/rfc2631.txt">http://www.ietf.org/rfc/rfc2631.txt</a>&gt;.</p>
<p><a name="nt-id2265747">24</a>. JEP-0155: Chat Session Negotiation &lt;<a href="http://www.jabber.org/jeps/jep-0155.html">http://www.jabber.org/jeps/jep-0155.html</a>&gt;.</p>
<p><a name="nt-id2265833">25</a>. RFC 3526: More Modular Exponential (MODP) Diffie-Hellman Groups &lt;<a href="http://www.ietf.org/rfc/rfc3526.txt">http://www.ietf.org/rfc/rfc3526.txt</a>&gt;.</p>
<p><a name="nt-id2266024">26</a>. RFC 3548: The Base16, Base32, and Base64 Data Encodings &lt;<a href="http://www.ietf.org/rfc/rfc3548.txt">http://www.ietf.org/rfc/rfc3548.txt</a>&gt;.</p>
<p><a name="nt-id2266192">27</a>. RFC 3766: Determining Strengths For Public Keys Used For Exchanging Symmetric Keys &lt;<a href="http://www.ietf.org/rfc/rfc3766.txt">http://www.ietf.org/rfc/rfc3766.txt</a>&gt;.</p>
<p><a name="nt-id2266777">28</a>. RFC 2104: HMAC: Keyed-Hashing for Message Authentication &lt;<a href="http://www.ietf.org/rfc/rfc2104.txt">http://www.ietf.org/rfc/rfc2104.txt</a>&gt;.</p>
<p><a name="nt-id2266963">29</a>. Recommendation for Block Cipher Modes of Operation: Federal Information Processing Standards Publication 800-38a &lt;<a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">http://csrc.nist.gov/publications/ nistpubs/800-38a/sp800-38a.pdf</a>&gt;.</p>
<p><a name="nt-id2268780">30</a>. The more often Alice changes her published ESession options, the shorter the Perfect Forward Secrecy window of vulnerability. However, whenever she changes them she divulges her presence to all the entities that are monitoring them.</p>
<p><a name="nt-id2268910">31</a>. JEP-0163: Simplified Personal Publish-Subscribe &lt;<a href="http://www.jabber.org/jeps/jep-0163.html">http://www.jabber.org/jeps/jep-0163.html</a>&gt;.</p>
<p><a name="nt-id2269432">32</a>. Alice may not be able to find the specified value of x if, for example, she went offline using a different client and/or a different machine without publishing a 'match_resource' field. In this case Alice cannot decrypt the offline ESession!</p>
<p><a name="nt-id2269632">33</a>. JEP-0091: Delayed Delivery &lt;<a href="http://www.jabber.org/jeps/jep-0091.html">http://www.jabber.org/jeps/jep-0091.html</a>&gt;.</p>
<p><a name="nt-id2269709">34</a>. Although counter mode encryption requires no padding, implementations MAY still disguise the length of m by appending a random number of white-space characters.</p>
<p><a name="nt-id2269729">35</a>. If Bob were to receive a stanza out-of-order, then he would fail to decrypt the stanza and be forced to terminate the ESession.</p>
<p><a name="nt-id2270086">36</a>. If Bob were to receive a stanza out-of-order, then the MACs would not match because the values of C<span class="sub" style="">A</span> would not be synchronized.</p>
<p><a name="nt-id2270262">37</a>. Bob MUST NOT send a stream error to his server since intermediate entities are not responsible for encoded content.</p>
<p><a name="nt-id2270626">38</a>. If an entity fails to receive any stanza that includes a new key in the correct order, then it will fail to decrypt the next stanza it receives and be forced to terminate the ESession.</p>
<p><a name="nt-id2270833">39</a>. Content is specified for the &lt;terminate/&gt; element to facilitate <a href="#sign-normal">XML Normalization</a>.</p>
<p><a name="nt-id2271020">40</a>. Canonical XML 1.0 &lt;<a href="http://www.w3.org/TR/xml-c14n">http://www.w3.org/TR/xml-c14n</a>&gt;.</p>
<p><a name="nt-id2271144">41</a>. RFC 3447: Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1 &lt;<a href="http://www.ietf.org/rfc/rfc3447.txt">http://www.ietf.org/rfc/rfc3447.txt</a>&gt;.</p>
<p><a name="nt-id2271198">42</a>. Digital Signature Standard: Federal Information Processing Standards Publication 186  &lt;<a href="http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf">http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf</a>&gt;.</p>
<p><a name="nt-id2271377">43</a>. RFC 1750: Randomness Recommendations for Security &lt;<a href="http://www.ietf.org/rfc/rfc1750.txt">http://www.ietf.org/rfc/rfc1750.txt</a>&gt;.</p>
<p><a name="nt-id2271425">44</a>. SSH Transport Layer Encryption Modes &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-05.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-05.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2271798">45</a>. IANA registry of parameters related to secure shell &lt;<a href="http://www.iana.org/assignments/ssh-parameters">http://www.iana.org/assignments/ssh-parameters</a>&gt;.</p>
<p><a name="nt-id2271845">46</a>. Advanced Encryption Standard: Federal Information Processing Standards Publication 197 &lt;<a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf</a>&gt;.</p>
<p><a name="nt-id2271890">47</a>. The Twofish Block Cipher &lt;<a href="http://www.schneier.com/twofish.html">http://www.schneier.com/twofish.html</a>&gt;.</p>
<p><a name="nt-id2271924">48</a>. The Serpent Block Cipher &lt;<a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">http://www.cl.cam.ac.uk/~rja14/serpent.html</a>&gt;.</p>
<p><a name="nt-id2272042">49</a>. X.509 Authentication in SSH2 &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-x509-02.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-x509-02.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2272119">50</a>. Secure Hash Standard: Federal Information Processing Standards Publication 180-2  &lt;<a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">http://csrc.nist.gov/publications/fips/fips180-2/fips186-2withchangenotice.pdf</a>&gt;.</p>
<p><a name="nt-id2272162">51</a>. The Whirlpool Hash Function &lt;<a href="http://paginas.terra.com.br/informatica/paulobarreto/WhirlpoolPage.html">http://paginas.terra.com.br/informatica/paulobarreto/WhirlpoolPage.html</a>&gt;.</p>
<p><a name="nt-id2272232">52</a>. Standard ECMA-151: Data Compression for Information Interchange - Adaptive Coding with Embedded Dictionary - DLCZ Algorithm &lt;<a href="http://www.ecma-international.org/publications/standards/Ecma-151.htm">http://www.ecma-international.org/publications/standards/Ecma-151.htm</a>&gt;.</p>
<p><a name="nt-id2272258">53</a>. RFC 1950: ZLIB Compressed Data Format Specification version 3.3 &lt;<a href="http://www.ietf.org/rfc/rfc1950.txt">http://www.ietf.org/rfc/rfc1950.txt</a>&gt;.</p>
<p><a name="nt-id2272299">54</a>. The Internet Assigned Numbers Authority (IANA) is the central coordinator for the assignment of unique parameter values for Internet protocols, such as port numbers and URI schemes. For further information, see &lt;<a href="http://www.iana.org/">http://www.iana.org/</a>&gt;.</p>
<p><a name="nt-id2272385">55</a>. The Jabber Registrar maintains a list of reserved Jabber protocol namespaces as well as registries of parameters used in the context of protocols approved by the Jabber Software Foundation. For further information, see &lt;<a href="http://www.jabber.org/registrar/">http://www.jabber.org/registrar/</a>&gt;.</p>
<p><a name="nt-id2272407">56</a>. JEP-0068: Field Data Standardization for Data Forms &lt;<a href="http://www.jabber.org/jeps/jep-0068.html">http://www.jabber.org/jeps/jep-0068.html</a>&gt;.</p>
<p><a name="nt-id2272656">57</a>. JEP-0013: Flexible Offline Message Retrieval &lt;<a href="http://www.jabber.org/jeps/jep-0013.html">http://www.jabber.org/jeps/jep-0013.html</a>&gt;.</p>
</div>
<p><hr></p>
<a name="revs"></a><h2>Revision History</h2>
<div class="indent">
<h4>Version 0.9 (2005-11-29)</h4>
<div class="indent">Modified protocol in line with SIGMA: added Identity Protection requirement, no pre-indication of acceptable keys, send multiple values of e with ESession request, offline options published via SPPS, added LZW compression (ip)
    </div>
<h4>Version 0.8 (2005-09-27)</h4>
<div class="indent">Added diagramatic synopses; Added match_resource field; replaced req_mac and kid fields with prev_hash; Alice specifies initial counter (doubles as nonce); many other improvements (ip)
    </div>
<h4>Version 0.7 (2005-08-26)</h4>
<div class="indent">Simplified XML normalization; added Synopsis and Efficiency requirement; defined signature formats (ip)
    </div>
<h4>Version 0.6 (2005-08-12)</h4>
<div class="indent">Extended termination procedure; added object encryption/signing requirement and special case; clarified expired MAC publishing; added Flexible Offline Message Retrieval to Open Issues. (ip)
    </div>
<h4>Version 0.5 (2005-08-10)</h4>
<div class="indent">Added flexibility requirement; added late signature of initial request; added termination MAC. (ip)
    </div>
<h4>Version 0.4 (2005-08-09)</h4>
<div class="indent">Added (offline) replay protection; required offline Created header; compression is NOT RECOMMENDED; added second set of offline options for subscribers; added JIDs to session key generation; unencrypted sessions; added secure option; sign whole data form; HMAC whole &lt;encrypted/&gt; element; added ESession termination; option to distribute public keys within session negotiation; added Integrity requirement; several clarifications (ip)
    </div>
<h4>Version 0.3 (2005-08-02)</h4>
<div class="indent">Restored status to Experimental; complete rewrite; new Introduction, Background, Requirements and Security Considerations; new OTR-inspired protocol; JEP-0155-based negotiation; counter mode encryption; more secure hashes; offline sessions; re-keying; mac publishing; preliminary key and options publishing protocol. (ip/psa)
    </div>
<h4>Version 0.2 (2004-07-26)</h4>
<div class="indent">At the request of the JEP author, changed status to Retracted. (psa)
    </div>
<h4>Version 0.1 (2003-09-09)</h4>
<div class="indent">Initial version. (dss/psa)
    </div>
</div>
<p><hr></p>
<p>END</p>
</body>
</html>
