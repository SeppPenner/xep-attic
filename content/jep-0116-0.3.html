<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JEP-0116: Encrypted Sessions</title>
<link rel="stylesheet" type="text/css" href="jep.css">
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
<meta name="DC.Title" content="Encrypted Sessions">
<meta name="DC.Creator" content="Ian Paterson">
<meta name="DC.Creator" content="Peter Saint-Andre">
<meta name="DC.Creator" content="Dave Smith">
<meta name="DC.Description" content="This JEP specifies a protocol for session-based, end-to-end encryption of XMPP communications.">
<meta name="DC.Publisher" content="Jabber Software Foundation">
<meta name="DC.Contributor" content="JEP Editor">
<meta name="DC.Date" content="2005-08-02">
<meta name="DC.Type" content="Jabber Enhancement Proposal">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="JEP-0116">
<meta name="DC.Language" content="en">
<meta name="DC.Rights" content="This Jabber Enhancement Proposal is copyright 1999 - 2005 by the Jabber Software Foundation (JSF) and is in full conformance with the JSF's Intellectual Property Rights Policy &lt;http://www.jabber.org/jsf/ipr-policy.shtml&gt;. This material may be distributed only subject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latest version is presently available at &lt;http://www.opencontent.org/openpub/&gt;).">
</head>
<body>
<h1>JEP-0116: Encrypted Sessions</h1>
<p>This JEP specifies a protocol for session-based, end-to-end encryption of XMPP communications.</p>
<p><hr></p>
<p style="color:red">WARNING: This Standards-Track JEP is Experimental. Publication as a Jabber Enhancement Proposal does not imply approval of this proposal by the Jabber Software Foundation. Implementation of the protocol described herein is encouraged in exploratory implementations, but production systems should not deploy implementations of this protocol until it advances to a status of Draft.</p>
<p><hr></p>
<h2>JEP Information</h2>
<p class="indent">
            Status: Experimental<br>
            Type: Standards Track<br>
            Number: 0116<br>
            Version: 0.3<br>
            Last Updated: 2005-08-02<br>
            JIG: Standards JIG<br>
                Approving Body: Jabber Council<br>Dependencies: XMPP Core, RFC 2409, RFC 2631, RFC 3526, JEP-0004, JEP-0020, JEP-0030, JEP-0068, JEP-0155<br>
                Supersedes: None<br>
                Superseded By: None<br>
            Short Name: esession<br></p>
<h2>Author Information</h2>
<div class="indent">
<h3>Ian Paterson</h3>
<p class="indent">
        Email: ian.paterson@clientside.co.uk<br>
        JID: ian@zoofy.com</p>
<h3>Peter Saint-Andre</h3>
<p class="indent">
        Email: stpeter@jabber.org<br>
        JID: stpeter@jabber.org</p>
<h3>Dave Smith</h3>
<p class="indent">
        Email: dizzyd@jabber.org<br>
        JID: dizzyd@jabber.org</p>
</div>
<h2>Legal Notice</h2>
<p class="indent">This Jabber Enhancement Proposal is copyright 1999 - 2005 by the <a href="http://www.jabber.org/jsf/">Jabber Software Foundation</a> (JSF) and is in full conformance with the JSF's Intellectual Property Rights Policy &lt;<a href="http://www.jabber.org/jsf/ipr-policy.shtml">http://www.jabber.org/jsf/ipr-policy.shtml</a>&gt;. This material may be distributed only subject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latest version is presently available at &lt;<a href="http://www.opencontent.org/openpub/">http://www.opencontent.org/openpub/</a>&gt;).</p>
<h2>Discussion Venue</h2>
<p class="indent">The preferred venue for discussion of this document is the Standards-JIG discussion list: &lt;<a href="http://mail.jabber.org/mailman/listinfo/standards-jig">http://mail.jabber.org/mailman/listinfo/standards-jig</a>&gt;.</p>
<p class="indent">Given that this JEP normatively references IETF technologies, discussion on the JSF-IETF list may also be appropriate (see &lt;<a href="http://mail.jabber.org/mailman/listinfo/jsf-ietf">http://mail.jabber.org/mailman/listinfo/jsf-ietf</a>&gt; for details).</p>
<h2>Relation to XMPP</h2>
<p class="indent">The Extensible Messaging and Presence Protocol (XMPP) is defined in the XMPP Core (RFC 3920) and XMPP IM (RFC 3921) specifications contributed by the Jabber Software Foundation to the Internet Standards Process, which is managed by the Internet Engineering Task Force in accordance with RFC 2026. Any protocol defined in this JEP has been developed outside the Internet Standards Process and is to be understood as an extension to XMPP rather than as an evolution, development, or modification of XMPP itself.</p>
<h2>Conformance Terms</h2>
<p class="indent">The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.</p>
<p><hr></p>
<h2>Table of Contents</h2>
<div class="indent"><dl>
<dt>1.  <a href="#intro">Introduction</a>
</dt>
<dt>2.  <a href="#background">Background</a>
</dt>
<dt>3.  <a href="#terms">Terminology</a>
</dt>
<dl><dt>3.1.  <a href="#terms-personae">Dramatis Personae</a>
</dt></dl>
<dt>4.  <a href="#reqs">Requirements</a>
</dt>
<dl>
<dt>4.1.  <a href="#reqs-sec">Security Requirements</a>
</dt>
<dl>
<dt>4.1.1.  <a href="#reqs-encrypt">Encryption</a>
</dt>
<dt>4.1.2.  <a href="#reqs-forward">Perfect Forward Security</a>
</dt>
<dt>4.1.3.  <a href="#reqs-auth">Authentication</a>
</dt>
<dt>4.1.4.  <a href="#reqs-repudiate">Repudiability</a>
</dt>
</dl>
<dt>4.2.  <a href="#reqs-xmpp">Application Requirements</a>
</dt>
<dl>
<dt>4.2.1.  <a href="#reqs-generality">Generality</a>
</dt>
<dt>4.2.2.  <a href="#reqs-implement">Implementability</a>
</dt>
<dt>4.2.3.  <a href="#reqs-usable">Usability</a>
</dt>
<dt>4.2.4.  <a href="#reqs-usable">Interoperability</a>
</dt>
<dt>4.2.5.  <a href="#reqs-offline">Offline sessions</a>
</dt>
</dl>
</dl>
<dt>5.  <a href="#disco">Discovering Support</a>
</dt>
<dt>6.  <a href="#init">ESession Initiation</a>
</dt>
<dl>
<dt>6.1.  <a href="#init-online">Online Diffie-Hellman Key Exchange</a>
</dt>
<dl>
<dt>6.1.1.  <a href="#init-request">Esession Request</a>
</dt>
<dt>6.1.2.  <a href="#init-prep">Diffie-Hellman Preparation (Bob)</a>
</dt>
<dt>6.1.3.  <a href="#init-response">Esession Response</a>
</dt>
<dt>6.1.4.  <a href="#init-prep2">Diffie-Hellman Preparation (Alice)</a>
</dt>
<dt>6.1.5.  <a href="#init-complete">Diffie-Hellman Completion</a>
</dt>
</dl>
<dt>6.2.  <a href="#init-offline">Offline Diffie-Hellman Key Exchange</a>
</dt>
<dl>
<dt>6.2.1.  <a href="#init-publish">Publishing Esession Options</a>
</dt>
<dt>6.2.2.  <a href="#init-start">Requesting Offline Esession Options</a>
</dt>
<dt>6.2.3.  <a href="#init-prep3">Diffie-Hellman Preparation (Offline)</a>
</dt>
<dt>6.2.4.  <a href="#init-start">Starting an Offline Esession</a>
</dt>
<dt>6.2.5.  <a href="#init-start">Accepting an Offline Esession</a>
</dt>
</dl>
<dt>6.3.  <a href="#init-keys">Generating Initial Session Keys</a>
</dt>
</dl>
<dt>7.  <a href="#exchange">Exchanging Stanzas</a>
</dt>
<dt>8.  <a href="#rekey">Re-Key Exchange</a>
</dt>
<dl>
<dt>8.1.  <a href="#rekey-init">Re-Key Initiation</a>
</dt>
<dt>8.2.  <a href="#rekey-accept">Re-Key Acceptance</a>
</dt>
<dt>8.3.  <a href="#rekey-publish">Publishing Old Values of K-M</a>
</dt>
</dl>
<dt>9.  <a href="#sec">Security Considerations</a>
</dt>
<dl>
<dt>9.1.  <a href="#sec-prng">Verifying Keys</a>
</dt>
<dt>9.2.  <a href="#sec-rekey">Re-Keying Limits</a>
</dt>
<dt>9.3.  <a href="#sec-keys">Verifying Keys</a>
</dt>
<dt>9.4.  <a href="#sec-general">Extra Responsabilities of Implementors</a>
</dt>
<dt>9.5.  <a href="#sec-mandatory">Mandatory to Implement Technologies</a>
</dt>
<dl>
<dt>9.5.1.  <a href="#sec-mandatory-encryption">Encryption Algorithms</a>
</dt>
<dt>9.5.2.  <a href="#sec-mandatory-sign">Key Signing Algorithms</a>
</dt>
<dt>9.5.3.  <a href="#sec-mandatory-public">Public Signature-Verification-Key Formats</a>
</dt>
<dt>9.5.4.  <a href="#sec-mandatory-hash">Hash Algorithms</a>
</dt>
<dt>9.5.5.  <a href="#sec-mandatory-compress">Compression Algorithms</a>
</dt>
</dl>
</dl>
<dt>10.  <a href="#iana">IANA Considerations</a>
</dt>
<dt>11.  <a href="#registrar">Jabber Registrar Considerations</a>
</dt>
<dl>
<dt>11.1.  <a href="#registrar-ns">Namespaces</a>
</dt>
<dt>11.2.  <a href="#registrar-formtype">Field Standardization</a>
</dt>
</dl>
<dt>12.  <a href="#schema">XML Schemas</a>
</dt>
<dt>13.  <a href="#keys">Public Key Publication and Retrieval</a>
</dt>
<dt>14.  <a href="#open">Open Issues</a>
</dt>
<dt><a href="#notes">Notes</a></dt>
<dt><a href="#revs">Revision History</a></dt>
</dl></div>
<p><hr></p>
<h2>1.
       <a name="intro">Introduction</a>
</h2>
  <p class="" style="">End-to-end encryption is a desirable feature for any communication technology. Ideally, such a technology would design encryption in from the beginning and would forbid unencrypted communications. Realistically, most communication technologies have not been designed in that manner, and Jabber/XMPP technologies are no exception. In particular, the original Jabber technologies developed in 1999 did not include end-to-end encryption by default. PGP-based encryption of message bodies and signing of presence information was added as an extension to the core protocols in the year 2000; this extension is documented in <span class="ref" style="">Current Jabber OpenPGP Usage</span>  [<a href="#nt-id2250515">1</a>]. When the core protocols were formalized within the Internet Standards Process by the IETF's XMPP Working Group in 2003, a different extension was defined using S/MIME-based signing and encryption of CPIM-formatted messages (see <span class="ref" style="">RFC 3862</span>  [<a href="#nt-id2250681">2</a>]) and PIDF-formatted presence information (see <span class="ref" style="">RFC 3863</span>  [<a href="#nt-id2250702">3</a>]); this extension is specified in <span class="ref" style="">RFC 3923</span>  [<a href="#nt-id2250725">4</a>].</p>
  <p class="" style="">For reasons described more fully below, the foregoing proposals (and others not mentioned) have not been widely implemented and deployed. This is unfortunate, since an open communication protocol needs to enable end-to-end encryption in order to be seriously considered for deployment by a broad range of users. This proposal describes a different approach to end-to-end encryption for use by entities that communicate using XMPP. The approach taken herein essentially translates the semantics of the secure shell protocol (SSH) into the syntax of XMPP, with some adjustments that reflect reports of security issues with SHA-1 and insights gleaned from implementation of "off-the-record" (OTR) communication in the Gaim encryption plugin as described in <span class="ref" style="">Off-the-Record Communication</span>  [<a href="#nt-id2250769">5</a>]. The result is a protocol for encrypted sessions or "ESessions".</p>
<h2>2.
       <a name="background">Background</a>
</h2>
  <p class="" style="">As specified in <span class="ref" style="">RFC 3920</span>  [<a href="#nt-id2250545">6</a>], XMPP is an XML streaming protocol that enables the near-real-time exchange of XML fragments between any two (or more) network endpoints. To date, the main application built on top of the core XML streaming layer is instant messaging (IM) and presence, the base extensions for which are specified in <span class="ref" style="">RFC 3921</span>  [<a href="#nt-id2250575">7</a>]. There are three first-level elements of XML streams (&lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt;); each of these "XML stanza" types has different semantics, which can complicate the task of defining a generalized approach to end-to-end encryption for XMPP. In addition, XML stanzas can be extended (via properly-namespaced child elements) for a wide variety of functionality. The chosen approach should enable encryption of several complete XML elements rather than only parts thereof (e.g., only the XML character data of the message &lt;body/&gt; element as in <span style="font-weight: bold">JEP-0027</span>).</p>
  <p class="" style="">XMPP is a session-oriented communication technology: normally, a client authenticates with a server and maintains a long-lived connection that defines the client's XMPP session. Such stream-level sessions are secured via channel encryption using Transport Level Security (<span class="ref" style="">RFC 2246</span>  [<a href="#nt-id2250626">8</a>]), as specified in Section 5 of <span style="font-weight: bold">RFC 3920</span>. However, there is no guarantee that all hops will implement or enforce channel encryption (or that intermediate routers are trustworthy), which makes end-to-end encryption desirable.</p>
  <p class="" style="">The session metaphor also applies to communication between endpoints: for instance, in IM applications, most instant messaging exchanges occur in bursts within limited time periods (e.g., two people may send a fairly large number of messages during a five-minute chat and then not exchange messages again for hours or even days). The XML stanzas exchanged during such a session may not be limited to &lt;message/&gt; stanzas; for instance, the session may be triggered by a change in one of the parties' presence status (e.g., changing from away to available) and the session may involve the exchange of &lt;iq/&gt; stanzas (e.g., to transfer a file as specified in <span class="ref" style="">File Transfer</span>  [<a href="#nt-id2255633">9</a>]). Endpoints may want to encrypt the stanzas they send to each other in such a way that the stanzas cannot be understood by untrusted mediating entities (such as servers) except to the extent required to understand the necessary routing information. (One complicating factor is that routing information may include not only the stanza's 'to', 'from', 'type, and 'id' attributes, but also <span class="ref" style="">Advanced Message Processing</span>  [<a href="#nt-id2255661">10</a>] and <span class="ref" style="">Stanza Headers and Internet Metadata (SHIM)</span>  [<a href="#nt-id2255682">11</a>] data extensions.)</p>
  <p class="" style="">The foregoing XMPP communications exist in the context of a one-to-one communication session between two entities. However, several forms of XMPP communication exist outside the context of one-to-one communication sessions:</p>
  <ul>
    <li>Many-to-many sessions, such as a text conference in a chatroom as specified in <span class="ref" style="">Multi-User Chat</span>  [<a href="#nt-id2255715">12</a>].</li>
    <li>One-to-many "broadcast", such as undirected presence stanzas sent from one user to many contacts (see <span style="font-weight: bold">RFC 3921</span>) and data syndication implemented using <span class="ref" style="">Publish-Subscribe</span>  [<a href="#nt-id2255744">13</a>].</li>
    <li>One-to-one communications that are stored for later delivery rather than delivered immediately, such as so-called "offline messages".</li>
  </ul>
  <p class="" style="">Ideally, any technology for end-to-end encryption in XMPP could be extended to cover these scenarios as well as one-to-one communication sessions. However, for both many-to-many sessions and one-to-many broadcast are are deemed out of scope for this JEP. Offline communications are handled via a simple extension to the protocol for one-to-one sessions between two entities that are online simultaneously (see below).</p>
  <p class="" style="">Because XMPP is a session-oriented communication technology, encryption schemes that are appropriate for less dynamic technologies may not be appropriate for XMPP, and XMPP may be able to take advantage of encryption approaches that are not feasible for less dynamic technologies. In particular, existing approaches to encryption of Internet communications have generally assumed that the "thing" to be encrypted has a stable identity or is best understood as a standalone object (e.g., a file or email message); the term "object encryption" well captures this assumption. Both <span style="font-weight: bold">JEP-0027</span> and <span style="font-weight: bold">RFC 3923</span> assume that XMPP communications are more like the exchange of email messages than they are like an interactive session -- while <span style="font-weight: bold">JEP-0027</span> uses "old-style" PGP object encryption and <span style="font-weight: bold">RFC 3923</span> uses "new-style" S/MIME object encryption, both specify the use of object encryption. </p>
  <p class="" style="">However, the session-oriented nature of XMPP may imply that the focus should be on "session encryption" rather than "object encryption". The paradigm for XMPP encryption may be something closer to the widely-deployed Secure Shell technology (see <span class="ref" style="">SSH Protocol Architecture</span>  [<a href="#nt-id2255874">14</a>] and <span class="ref" style="">SSH Transport Layer Protocol</span>  [<a href="#nt-id2255845">15</a>]) than to traditional encryption of files and standalone email messages. In many ways, Secure Shell (or, more generally, opportunistic security) is the conceptual model for the current proposal.</p>
  <p class="" style="">Therefore, this JEP specifies a method for encrypted sessions ("ESessions") that takes advantage of the inherent possibilities and strengths of session encryption as opposed to object encryption. The basic concept is that of an encrypted session which acts as a secure tunnel between two endpoints. Once the tunnel is established, all one-to-one XML stanzas exchanged between the endpoints will be encrypted and then transmitted within a "wrapper" protocol element.</p>
<h2>3.
       <a name="terms">Terminology</a>
</h2>
  <div class="indent">
<h3>3.1 <a name="terms-personae">Dramatis Personae</a>
</h3>
    <p class="" style="">This JEP introduces two characters to help the reader follow the necessary exchanges:</p>
    <ol start="1" type="">
      <li>"Alice" is the name of the initiator of the ESession. Within the scope of this JEP, we stipulate that her fully-qualified JID is: &lt;alice@example.org/pda&gt;.</li>
      <li>"Bob" is the name of the other participant in the ESession started by Alice. Within the scope of this JEP, his fully-qualified JID is: &lt;bob@example.com/laptop&gt;.</li>
    </ol>
    <p class="" style="">While Alice and Bob are introduced as "end users", they are simply meant to be examples of Jabber entities. Any directly addressable Jabber entity may participate in an Esession.</p>
  </div>
<h2>4.
       <a name="reqs">Requirements</a>
</h2>
  <div class="indent">
<h3>4.1 <a name="reqs-sec">Security Requirements</a>
</h3>
    <p class="" style="">This JEP stipulates the following security requirements for end-to-end encryption of XMPP communications:</p>
    <ul>
      <li>Encryption</li>
      <li>Perfect forward security</li>
      <li>Authentication</li>
      <li>Repudiability</li>
    </ul>
    <p class="" style="">Each of these requirements is explained in greater depth below.</p>
    <div class="indent">
<h3>4.1.1 <a name="reqs-encrypt">Encryption</a>
</h3>
      <p class="" style="">The one-to-one XML stanzas exchanged between two entities MUST NOT be understandable to any other entity that might intercept the communications.</p>
    </div>
    <div class="indent">
<h3>4.1.2 <a name="reqs-forward">Perfect Forward Security</a>
</h3>
      <p class="" style="">The encrypted communication MUST NOT be revealed even if a system compromise occurs in the future (e.g., Steve steals Bob's computer).</p>
    </div>
    <div class="indent">
<h3>4.1.3 <a name="reqs-auth">Authentication</a>
</h3>
      <p class="" style="">Each party to a conversation MUST know that the other party is who he says he is (Alice must be able to know that Bob really is Bob, and vice versa).</p>
    </div>
    <div class="indent">
<h3>4.1.4 <a name="reqs-repudiate">Repudiability</a>
</h3>
      <p class="" style="">Alice and Bob MUST be able to repudiate any stanza that occurs within an Esession. After an Esession has finished, it SHOULD NOT be possible to <span style="font-style: italic">prove cryptographically</span> that any transcript has not been modified by a third party.  [<a href="#nt-id2256200">16</a>]</p>
    </div>
  </div>
  <div class="indent">
<h3>4.2 <a name="reqs-xmpp">Application Requirements</a>
</h3>
    <p class="" style="">In addition to the foregoing security profile, this JEP also stipulates the following application-specific requirements for encrypted communication in the context of Jabber/XMPP technologies:</p>
    <ol start="" type="">
      <li>Generality</li>
      <li>Implementability</li>
      <li>Usability</li>
      <li>Interoperability</li>
      <li>Offline "sessions"</li>
    </ol>
    <p class="" style="">Each of these is explained in greater depth below.</p>
    <div class="indent">
<h3>4.2.1 <a name="reqs-generality">Generality</a>
</h3>
      <p class="" style="">The solution should be generally applicable to any XML stanza type (&lt;message/&gt;, &lt;presence/&gt;, &lt;iq/&gt;) sent between two entities. It is deemed acceptable for now if the solution does not apply to many-to-many stanzas (e.g., groupchat messages sent within the context of multi-user chat) or one-to-many stanzas (e.g., presence "broadcasts" and pubsub notifications); end-to-end encryption of such stanzas may require separate solutions or extensions to the one-to-one session solution.</p>
    </div>
    <div class="indent">
<h3>4.2.2 <a name="reqs-implement">Implementability</a>
</h3>
      <p class="" style="">The only good security technology is an implemented security technology. The solution should be one that typical client developers can implemented in a relatively straightforward and consistent fashion.</p>
    </div>
    <div class="indent">
<h3>4.2.3 <a name="reqs-usable">Usability</a>
</h3>
      <p class="" style="">The requirement of usability takes implementability one step further by stipulating that the solution must be one that organizations can deploy and humans can use with 100% transparency (like https:). Experience has shown that: solutions requiring a full public key infrastructure do not get widely deployed, and solutions requiring any user action are not widely used. We can do better.</p>
    </div>
    <div class="indent">
<h3>4.2.4 <a name="reqs-usable">Interoperability</a>
</h3>
      <p class="" style="">Ideally, it would be possible for an XMPP user to exchange encrypted messages (and, potentially, presence information) with users of non-XMPP messaging systems.</p>
    </div>
    <div class="indent">
<h3>4.2.5 <a name="reqs-offline">Offline sessions</a>
</h3>
      <p class="" style="">Ideally, it should be possible to encrypt one-to-one communications that are stored for later delivery rather than delivered immediately, such as so-called "offline messages".</p>
    </div>
  </div>
<h2>5.
       <a name="disco">Discovering Support</a>
</h2>
  <p class="" style="">Before attempting to engage in an ESession with Bob, Alice SHOULD discover whether he supports this protocol, using either <span class="ref" style="">Service Discovery</span>  [<a href="#nt-id2256401">17</a>] or the presence-based profile of <span style="font-weight: bold">JEP-0030</span> specified in <span class="ref" style="">Entity Capabilities</span>  [<a href="#nt-id2256424">18</a>].</p>
  <p class="" style="">The normal course of events is for Alice to authenticate with her server, retrieve her roster (see <span style="font-weight: bold">RFC 3921</span>), send initial presence to her server, and then receive presence information from all the contacts in her roster. If the presence information she receives from some contacts does not include capabilities data (per <span style="font-weight: bold">JEP-0115</span>), Alice SHOULD then send a service discovery information ("disco#info") request to each of those contacts (in accordance with <span style="font-weight: bold">JEP-0030</span>). Such initial service discovery stanzas MUST NOT be considered part of encrypted communication sessions for the purposes of this JEP, since they perform a "bootstrapping" function that is a prerequisite to encrypted communications. The disco#info request sent from Alice to Bob might look as follows:</p>
  <p class="caption">Example 1. Alice Queries Bob for Esession Support via Disco</p>
<div class="indent"><pre>
&lt;iq from='alice@example.org/pda'
    to='bob@example.com/laptop'
    id='disco1'
    type='get'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'/&gt;
&lt;/iq&gt;
  </pre></div>
  <p class="" style="">If Bob sends a disco#info reply and he supports the protocol defined herein, then he MUST include a service discovery feature variable of "http://jabber.org/protocol/esession".</p>
  <p class="caption">Example 2. Bob Returns disco#info Data</p>
<div class="indent"><pre>
&lt;iq from='bob@example.com/laptop'
    from='alice@example.org/pda'
    id='disco1'
    type='result'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'&gt;
    &lt;identity category='client' type='pc'/&gt;
    ...
    &lt;feature var='http://jabber.org/protocol/esession'/&gt;
    ...
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
<h2>6.
       <a name="init">ESession Initiation</a>
</h2>
  <p class="" style="">The process for establishing an ESession is essentially a translation into XMPP syntax of the SSH transport mechanism for establishing a secure session over an insecure transport (see <span style="font-weight: bold">SSH Transport Layer Protocol</span>). Specifically, as in SSH, ESession uses a Diffie-Hellman key exchange algorithm (see <span class="ref" style="">RFC 2631</span>  [<a href="#nt-id2256523">19</a>]) in the initial negotation (although, as we shall see, it does not use SHA-1 as the hashing algorithm).</p>
  <p class="" style="">When Alice wishes to establish an ESession with Bob, Alice may choose between two different methods of performing the initial Diffie-Hellman key exchange, depending on whether Bob is online or not.</p>

  <div class="indent">
<h3>6.1 <a name="init-online">Online Diffie-Hellman Key Exchange</a>
</h3>
    <p class="" style="">If Alice believes Bob may be online then she SHOULD retrieve Bob's long-term public signature-verification keys (see <a href="#keys">Public Key Publication and Retrieval</a>) and then use the protocol specified in <span class="ref" style="">Chat Session Negotiation</span>  [<a href="#nt-id2256586">20</a>] to negotiate the initial Diffie-Hellman key. In this aggressive exchange the first two messages negotiate policy, swap Diffie-Hellman public values and the ancillary data necessary for the exchange and authentication. The second message also authenticates the responder. The third message authenticates the initiator and exchanges the final Diffie-Hellman public value.</p>
    <div class="indent">
<h3>6.1.1 <a name="init-request">Esession Request</a>
</h3>
      <p class="" style="">Alice MUST provide information about each of the Esession options (algorithms etc.) that she is willing to use, in her order of preference (see the <a href="#sec-mandatory">Mandatory to Implement Technologies</a> section of this document for further information):</p>
      <ol start="1" type="">
        <li><p class="" style="">The list of Modular Exponential (MODP) group numbers (as specified in <span class="ref" style="">RFC 2409</span>  [<a href="#nt-id2256653">21</a>] or <span class="ref" style="">RFC 3526</span>  [<a href="#nt-id2256677">22</a>]) she is willing to use for Diffie-Hellman key exchange (valid group numbers include 1,2,3,4,5,14,15,16,17 and 18)</p></li>
        <li><p class="" style="">Stanza symmetric encryption algorithm names</p></li>
        <li><p class="" style="">Hash algorithm names</p></li>
        <li><p class="" style="">Compression algorithm names</p></li>
        <li><p class="" style="">The list of stanza types she is willing to encrypt and decrypt</p></li>
        <li><p class="" style="">The minimum number of stanzas that MUST be exchanged before an entity MAY initiate a key re-exchange (1 - every stanza, 100 - every hundred stanzas). This value MUST be less than 2<span class="super" style="">32</span> (see <a href="#sec-rekey">Re-Keying Limits</a>)</p></li>
        <li><p class="" style="">The Base64 encoded (in accordance with Section 3 of <span class="ref" style="">RFC 3548</span>  [<a href="#nt-id2256771">23</a>]) SHA-256 fingerprint (PKID) of each of Bob's public signature-verification keys that she found acceptable (see <a href="#sec-keys">Verifying Keys</a>)</p></li>
      </ol>
    <p class="caption">Example 3. Alice Requests an ESession</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda'
         to='bob@example.com'
         id='es1'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x xmlns='jabber:x:data' type='form'&gt;
      &lt;field var='FORM_TYPE' type='hidden'&gt;
        &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
      &lt;/field&gt;
      ...
      &lt;field var='modp' type='list-single'&gt;
        &lt;option&gt;&lt;value&gt;5&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;14&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;2&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;1&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field var='encryption_algorithms' type='list-single'&gt;
        &lt;option&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;twofish256-ctr&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;aes128-ctr&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field var='hash_algorithms' type='list-single'&gt;
        &lt;option&gt;&lt;value&gt;whirlpool&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field var='compression' type='list-single'&gt;
        &lt;option&gt;&lt;value&gt;none&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;zlib&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field var='stanzas' type='list-multi'&gt;
        &lt;option&gt;&lt;value&gt;message&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;iq&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;presence&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field var='max_rekey_freq' type='text-single'&gt;
        &lt;value&gt;1&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='publickey_ids' type='list-multi'&gt;
        &lt;option&gt;&lt;value&gt; ** PKID ** &lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt; ** PKID ** &lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      ...
    &lt;/x&gt;
  &lt;/feature&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">If Bob does not support one or more of the options in each Esession field (except the 'publickey_ids' field), then he SHOULD return a &lt;feature-not-implemented/&gt; error (but he MAY return no error if, for example, he does not want to reveal his presence to Alice for whatever reason):</p>
    <p class="caption">Example 4. Bob Informs Alice that Her Options Are Not Supported</p>
<div class="indent"><pre>
&lt;message type='error'
         from='bob@example.com/laptop'
         to='alice@example.org/pda'
         id='es1'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x xmlns='jabber:x:data' type='form'&gt;
      &lt;field var='FORM_TYPE' type='hidden'&gt;
        &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
      &lt;/field&gt;
      ...
    &lt;/x&gt;
  &lt;/feature&gt;
  &lt;error code='501' type='cancel'&gt;
    &lt;feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
  &lt;/error&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">Either Bob or Alice MAY attempt to initiate a new ESession after any error during the initiation process. However, both MUST consider the previous negotiation to have failed and MUST discard any information learned through the previous negotiation.</p>
    </div>
    <div class="indent">
<h3>6.1.2 <a name="init-prep">Diffie-Hellman Preparation (Bob)</a>
</h3>
      <p class="" style="">If Bob is willing to start an ESession with Alice, he SHOULD retrieve Alice's long-term public signature-verification keys. He MUST select one of the options from each of the Esession fields he received from Alice including one of the MODP groups (see the Conclusion of <span class="ref" style="">RFC 3766</span>  [<a href="#nt-id2256878">24</a>] for recommendations regarding balancing the sizes of symmetric cipher blocks and Diffie-Hellman moduli). Each MODP group has at least two well known constants: a large prime number p, and a generator g for a subgroup of GF(p).</p>
      <p class="" style="">Bob MUST then perform the following computations (where n is the number of bits per encryption block for the selected encryption algorithm):</p>
      <ol start="1" type="">
        <li><p class="" style="">Generate the initial value of C<span class="sub" style="">A</span> with n-1 random bits (C<span class="sub" style="">A</span> is the encryption block counter for stanzas sent from Alice to Bob)</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> + 2<span class="super" style="">n-1</span> (where C<span class="sub" style="">B</span> is the counter for stanzas sent from Bob to Alice)</p></li>
        <li><p class="" style="">Generate a secret random number y (where 2<span class="super" style="">2n-1</span> &lt; y &lt; p - 1)</p></li>
        <li><p class="" style="">Calculate d = g<span class="super" style="">y</span> mod p</p></li>
        <li><p class="" style="">Generate an opaque unique key identifier (KID) for d</p></li>
        <li><p class="" style="">If Alice selected one or more of his public keys, and if Bob has access to a long-lived private signing key that corresponds to one of those keys (note that the keys may only be accessible to another of Bob's clients), calculate the signature of d using the selected private key</p></li>
      </ol>
    </div>
    <div class="indent">
<h3>6.1.3 <a name="init-response">Esession Response</a>
</h3>
    <p class="" style="">Bob responds to Alice specifying the Esession options he selected. Note: The value of the 'max_rekey_freq' field MUST be less than 2<span class="super" style="">32</span> and greater than or equal to the value specified by Alice. Instead of providing the PKID of his public key that he selected, Bob MUST specify the Base64 encoded SHA-256 fingerprint (PKID) of each of Alice's public signature-verification keys that he finds acceptable (see <a href="#sec-keys">Verifying Keys</a>). Note: The submited values for the 'publickey_ids' field do not correspond to the options he received.</p>
    <p class="" style="">Bob also includes C<span class="sub" style="">A</span>, the value of d and the signature of d (if it was possible to create one), all Base64 encoded.</p>
    <p class="caption">Example 5. Bob Responds to Alice</p>
<div class="indent"><pre>
&lt;message from='bob@example.com/laptop'
         to='alice@example.org/pda'
         id='es1'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x xmlns='jabber:x:data' type='submit'&gt;
      &lt;field var='FORM_TYPE' type='hidden'&gt;
        &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
      &lt;/field&gt;
      ...
      &lt;field var='modp'&gt;&lt;value&gt;5&lt;/value&gt;&lt;/field&gt;
      &lt;field var='encryption_algorithms'&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/field&gt;
      &lt;field var='hash_algorithms'&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/field&gt;
      &lt;field var='compression'&gt;&lt;value&gt;none&lt;/value&gt;&lt;/field&gt;
      &lt;field var='stanzas'&gt;&lt;value&gt;message&lt;/value&gt;&lt;/field&gt;
      &lt;field var='max_rekey_freq'&gt;&lt;value&gt;50&lt;/value&gt;&lt;/field&gt;
      &lt;field var='publickey_ids'&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
      &lt;/field&gt;
      ...
    &lt;/x&gt;
  &lt;/feature&gt;
  &lt;init xmlns='http://jabber.org/protocol/esession#init'&gt;
    &lt;key kid=' ** KID ** '&gt; ** base64 encoded value of d ** &lt;/key&gt;
    &lt;sign pkid=' ** PKID ** '&gt; ** base64 encoded signature of d ** &lt;/sign&gt;
    &lt;counter&gt; ** base64 encoded initial counter value ** &lt;/counter&gt;
  &lt;/init&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">If Alice provided a PKID but Bob did not provide a signature then she MAY send a failure notice to Bob. If Bob provided an invalid signature then she MUST send a failure notice to Bob.</p>
    <p class="caption">Example 6. Alice Signals that ESession Negotiation Failed (Unacceptable Signature)</p>
<div class="indent"><pre>
&lt;message type='error'
         from='alice@example.org/pda'
         to='bob@example.com/laptop'
         id='es2'&gt;
  &lt;error code='406' type='modify'&gt;
    &lt;feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
    &lt;invalid-signature xmlns='http://jabber.org/protocol/esession#error'/&gt;
  &lt;/error&gt;
&lt;/message&gt;
    </pre></div>

    </div>
    <div class="indent">
<h3>6.1.4 <a name="init-prep2">Diffie-Hellman Preparation (Alice)</a>
</h3>
      <p class="" style="">After verifying Bob's signature, Alice can be certain that the value of d was actually generated by Bob. Alice MUST use the value of d and the Esession options specified in Bob's response to perform the following steps (where n is the number of bits per encryption block for the agreed encryption algorithm):</p>
      <ol start="1" type="">
        <li><p class="" style="">Set the initial value of C<span class="sub" style="">A</span> to the counter value she received from Bob</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> + 2<span class="super" style="">n-1</span></p></li>
        <li><p class="" style="">Generate a secret random number x (where 2<span class="super" style="">2n-1</span> &lt; x &lt; p - 1)</p></li>
        <li><p class="" style="">Calculate e = g<span class="super" style="">x</span> mod p</p></li>
        <li><p class="" style="">Generate an opaque unique key identifier (KID) for e</p></li>
        <li><p class="" style="">If Bob selected one or more of her public keys, and if Alice has access to a long-lived private signing key that corresponds to one of those keys, calculate the signature of e using the selected private key</p></li>
        <li><p class="" style="">Calculate K = d<span class="super" style="">x</span> mod p (this is the shared secret)</p></li>
      </ol>
    </div>
    <div class="indent">
<h3>6.1.5 <a name="init-complete">Diffie-Hellman Completion</a>
</h3>
    <p class="" style="">Alice then completes the Diffie-Hellman negotiation by sending Bob the value of e and the signature of e (if it was possible to create one), both Base64 encoded. Alice MAY also send encrypted content (see the <a href="#exchange">Exchanging Stanzas</a> section of this document) in the same stanza as the Diffie-Hellman completion.</p>
    <p class="caption">Example 7. Alice Completes Diffie-Hellman Negotitation</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda'
         to='bob@example.com/laptop'&gt;
  &lt;init xmlns='http://jabber.org/protocol/esession#init'&gt;
    &lt;key kid=' ** KID ** '&gt; ** base64 encoded value of e ** &lt;/key&gt;
    &lt;sign pkid=' ** PKID ** '&gt; ** base64 encoded signature of e ** &lt;/sign&gt;
  &lt;/init&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data kid=' ** KID ** '&gt; ** base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">If Bob provided a PKID but Alice did not provide a valid signature, then he MUST ignore any encrypted content in the stanza and send a failure notice to Alice.</p>
    <p class="" style="">If no error occurs, Bob MUST calculate K = e<span class="super" style="">y</span> mod p (the shared secret). Alice and Bob then have the same value for K and the key exchange is complete.</p>
    </div>
  </div>



<div class="indent">
<h3>6.2 <a name="init-offline">Offline Diffie-Hellman Key Exchange</a>
</h3>

  <p class="" style="">As described below, offline negotiation of an ESession is in essence a special case of the online negotiation flow.</p>

    <div class="indent">
<h3>6.2.1 <a name="init-publish">Publishing Esession Options</a>
</h3>
      <p class="" style="">Just before Bob goes offline he SHOULD:</p>
      <ol start="1" type="">
        <li><p class="" style="">Select a MODP group (that defines the constants p and g)</p></li>
        <li><p class="" style="">Generate a secret random number y (where 2<span class="super" style="">2n-1</span> &lt; y &lt; p - 1, where n is the largest number of bits per encryption block for the encryption algorithms he is willing to use)</p></li>
        <li><p class="" style="">Calculate d = g<span class="super" style="">y</span> mod p</p></li>
        <li><p class="" style="">Generate an opaque unique key identifier (KID) for d</p></li>
      </ol>
      <p class="" style="">Bob SHOULD publish d and the KID along with information about each of the Esession options he is willing to use (see <a href="#init-request">Esession Request</a>) through his own server using the disco#publish-info feature (as <a href="http://mail.jabber.org/pipermail/standards-jig/2005-July/008131.html">NOT SPECIFIED</a> in <span style="font-weight: bold">JEP-0030</span>) or a similar protocol (out of scope for this JEP). Note: The single specified MODP group MUST be the one he used to generate d. The list of stanza types he is willing to decrypt MUST NOT include the value 'iq'. It is also RECOMMENDED that he includes a list of his public signature-verification keys and the corresponding signatures of d.</p>
      <p class="" style=""><span style="font-style: italic">Note: This publishing protocol is highly preliminary and depends on a separate proposal.</span></p>

      <p class="caption">Example 8. Bob Publishes His Esession Options</p>
<div class="indent"><pre>
&lt;iq from='bob@example.com/laptop'
    type='set'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/esession'&gt;
    &lt;x xmlns='jabber:x:data' type='submit'&gt;
      &lt;field var='FORM_TYPE' type='hidden'&gt;
        &lt;value&gt;http://jabber.org/protocol/esession&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='modp'&gt;
        &lt;value&gt;2&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='encryption_algorithms'&gt;
        &lt;value&gt;aes256-ctr&lt;/value&gt;
        &lt;value&gt;twofish256-ctr&lt;/value&gt;
        &lt;value&gt;aes128-ctr&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='hash_algorithms'&gt;
        &lt;value&gt;whirlpool&lt;/value&gt;
        &lt;value&gt;sha256&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='compression'&gt;
        &lt;value&gt;none&lt;/value&gt;
        &lt;value&gt;zlib&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='stanzas'&gt;
        &lt;value&gt;message&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='max_rekey_freq'&gt;
        &lt;value&gt;1&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='kid'&gt;
        &lt;value&gt; ** KID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='key'&gt;
        &lt;value&gt; ** base64 encoded value of d ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='publickey_ids'&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='sign'&gt;
        &lt;value&gt; ** base64 encoded signature of d ** &lt;/value&gt;
        &lt;value&gt; ** base64 encoded signature of d ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
      <p class="" style="">Bob MUST store the secret value of y that he used to calculate d in a secure way so that he can retrieve it when he next comes online. Note: Bob should idealy be able to access the value of y even if he comes online with a different client on a different machine, otherwise he will not be able to decrypt the stanzas sent to him while he was offline.</p>
    </div>
    <div class="indent">
<h3>6.2.2 <a name="init-start">Requesting Offline Esession Options</a>
</h3>
      <p class="" style="">If Alice believes Bob is offline then she SHOULD request his Esession options and his long-term public signature-verification keys (see <a href="#keys">Public Key Publication and Retrieval</a>) from his server.</p>
      <p class="caption">Example 9. Alice asks Bob's Server for his Esession Options</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='alice@example.org/pda'
    to='bob@example.com'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/esession'/&gt;
&lt;/iq&gt;
  </pre></div>
      <p class="" style="">If, after receiving Bob's Esession options and public keys, Alice is unable to verify any of Bob's Esession signatures then she MAY decide to proceed no further, since she cannot be sure who will be able to decrypt her stanzas.</p>
    </div>
    <div class="indent">
<h3>6.2.3 <a name="init-prep3">Diffie-Hellman Preparation (Offline)</a>
</h3>
      <p class="" style="">Alice MUST select one of the options from each of Bob's Esession fields. If she cannot support any of the options in a field (except the public key and signature fields) then she MUST not send encrypted stanzas to Bob while he is offline.</p>
      <p class="" style="">Alice MUST use the value of d and the MODP group specified in Bob's Esession options to perform the following steps (where n is the number of bits per encryption block for the selected encryption algorithm):</p>
      <ol start="1" type="">
        <li><p class="" style="">Generate the initial value of C<span class="sub" style="">A</span> with n-1 random bits (C<span class="sub" style="">A</span> is the encryption block counter for stanzas sent from Alice to Bob)</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> + 2<span class="super" style="">n-1</span> (where C<span class="sub" style="">B</span> is the counter for stanzas sent from Bob to Alice - in case Bob comes online before Alice terminates the Esession)</p></li>
        <li><p class="" style="">Generate a secret random number x (where 2<span class="super" style="">2n-1</span> &lt; x &lt; p - 1)</p></li>
        <li><p class="" style="">Calculate e = g<span class="super" style="">x</span> mod p</p></li>
        <li><p class="" style="">Generate an opaque unique key identifier (KID) for e</p></li>
        <li><p class="" style="">Calculate signatures of e using each of her long-lived private signing keys</p></li>
        <li><p class="" style="">Calculate K = d<span class="super" style="">x</span> mod p (the shared secret)</p></li>
      </ol>

    </div>
    <div class="indent">
<h3>6.2.4 <a name="init-start">Starting an Offline Esession</a>
</h3>
      <p class="" style="">Alice then sends Bob all the signatures of e, the value of e and C<span class="sub" style="">A</span> (all Base64 encoded). She also specifies which of his Esession options she selected. Note: The value of the 'max_rekey_freq' field MUST be less than 2<span class="super" style="">32</span> and greater than or equal to the value specified by Bob. Alice MAY also send encrypted content (see the <a href="#exchange">Exchanging Stanzas</a> section of this document) in the same stanza.</p>
      <p class="caption">Example 10. Alice Establishes an ESession Without Negotiation</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda'
         to='bob@example.com'&gt;
  &lt;init xmlns='http://jabber.org/protocol/esession#init'&gt;
    &lt;key kid=' ** KID ** '&gt; ** base64 encoded value of e ** &lt;/key&gt;
    &lt;sign pkid=' ** PKID ** '&gt; ** base64 encoded signature of e ** &lt;/sign&gt;
    &lt;sign pkid=' ** PKID ** '&gt; ** base64 encoded signature of e ** &lt;/sign&gt;
    &lt;counter&gt; ** base64 encoded initial counter value ** &lt;/counter&gt;
    &lt;x xmlns='jabber:x:data'&gt;
      &lt;field var='modp'&gt;&lt;value&gt;5&lt;/value&gt;&lt;/field&gt;
      &lt;field var='encryption_algorithms'&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/field&gt;
      &lt;field var='hash_algorithms'&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/field&gt;
      &lt;field var='compression'&gt;&lt;value&gt;none&lt;/value&gt;&lt;/field&gt;
      &lt;field var='max_rekey_freq'&gt;&lt;value&gt;1&lt;/value&gt;&lt;/field&gt;
      &lt;field var='stanzas'&gt;&lt;value&gt;message&lt;/value&gt;&lt;/field&gt;
    &lt;/x&gt;
  &lt;/init&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data kid=' ** KID ** '&gt; ** base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
      <p class="" style="">Alice can assume that she and Bob have the same value for K and that the key exchange is complete.</p>
    </div>
    <div class="indent">
<h3>6.2.5 <a name="init-start">Accepting an Offline Esession</a>
</h3>
      <p class="" style="">When Bob comes online and receives the key exchange stanza from Alice then he MUST perform the following steps:</p>
      <ol start="1" type="">
        <li><p class="" style="">Request Alice's public keys and, if possible, confirm that one of her signatures matches her value of e (if he is unable to verify any of her signatures then he MAY decide to proceed no further, since he cannot be sure who started the Esession)</p></li>
        <li><p class="" style="">Set the initial value of C<span class="sub" style="">A</span> to the counter value he received from Alice</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> + 2<span class="super" style="">n-1</span> (in case Alice has not yet terminated the Esession)</p></li>
        <li><p class="" style="">Calculate K = e<span class="super" style="">y</span> mod p (the shared secret)</p></li>
      </ol>
    </div>
  </div>

  <div class="indent">
<h3>6.3 <a name="init-keys">Generating Initial Session Keys</a>
</h3>
    <p class="" style="">Whichever method Alice used to perform the Diffie-Hellman key exchange (online or offline), once it is complete, then before Alice and Bob can start encrypting and decrypting stanzas they must both use the agreed hash algorithm ("HASH") to generate two sets of key data, one for each direction of the ESession.</p>
    <p class="" style="">For stanzas that Alice will send to Bob, the keys are calculated as:</p>
    <ol start="1" type="">
      <li><p class="" style="">Encryption key K-E<span class="sub" style="">A</span> = HASH(K, "A")</p></li>
      <li><p class="" style="">Integrity key K-M<span class="sub" style="">A</span> = HASH(K-E<span class="sub" style="">A</span>, "C")  [<a href="#nt-id2258073">25</a>]</p></li>
    </ol>
    <p class="" style="">For stanzas that Bob will send to Alice the keys are calculated as:</p>
    <ol start="4" type="">
      <li><p class="" style="">Encryption key K-E<span class="sub" style="">B</span> = HASH(K, "B")</p></li>
      <li><p class="" style="">Integrity key K-M<span class="sub" style="">B</span> = HASH(K-E<span class="sub" style="">B</span>, "D")</p></li>
    </ol>
    <p class="" style="">Once the two sets of key data have been calculated the value of K MUST be securely destroyed.</p>
    <p class="" style="">As many bytes of key data as are needed MUST be taken from the beginning of the hash output. When negotiating a hash, entities MUST ensure that the hash output is no shorter than the required key data. For algorithms with variable-length keys the maximum length (up to the hash output length) SHOULD be used.</p>

    <p class="" style="">With these keys computed and the algorithms agreed upon, ESession initiation is now complete. From this point forward, Alice and Bob MUST exchange only encrypted forms of the one-to-one stanza types they agreed upon (e.g., &lt;message/&gt; and &lt;iq/&gt; stanzas).</p>
  </div>
<h2>7.
       <a name="exchange">Exchanging Stanzas</a>
</h2>

  <p class="" style="">Once an Esession has been established, whenever Alice wants to send Bob an encrypted stanza she MUST only encrypt the XML content that would normally be ignored by the intermediate servers.</p>

  <p class="caption">Example 11. Unencrypted Stanza</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop' type='chat'&gt;
  &lt;body&gt;Hello, Bob!&lt;/body&gt;
  &lt;amp xmlns='http://jabber.org/protocol/amp' per-hop='true'&gt;
    &lt;rule condition='match-resource' value='exact' action='error'/&gt;
  &lt;/amp&gt;
  &lt;headers xmlns='http://jabber.org/protocol/shim'&gt;
    &lt;header name='Store'&gt;false&lt;/header&gt;
  &lt;/headers&gt;
  &lt;active xmlns='http://jabber.org/protocol/chatstates'/&gt;
&lt;/message&gt;
</pre></div>

  <p class="caption">Example 12. XML Content to be encrypted</p>
<div class="indent"><pre>
&lt;body&gt;Hello, Bob!&lt;/body&gt;
&lt;active xmlns='http://jabber.org/protocol/chatstates'/&gt;
</pre></div>

    <p class="" style="">Alice MUST perform the following steps to encrypt the XML content.</p>
    <ol start="1" type="">
      <li><p class="" style="">Serialize the XML content she wishes to send into an array of UTF-8 bytes, m.  [<a href="#nt-id2258282">26</a>]</p></li>
      <li>
        <p class="" style="">If compression was agreed upon, compress m using the negotiated algorithm. Typically, the compression context will be initialized after key exchange and is passed from one stanza to the next, with only a partial flush being performed at the end of the stanza. Note this means if Bob receives a stanza out-of-order, then he will fail to decrypt the stanza and be forced to terminate the Esession.</p>
        <p class="caption"></p>
<div class="indent"><pre>m_compressed = compress(m)</pre></div>
      </li>
      <li>
        <p class="" style="">Encrypt the data with the agreed algorithm in counter mode, using the encryption key K-E<span class="sub" style="">A</span>. Note: C<span class="sub" style="">A</span> MUST be incremented for each encrypted block, and if C<span class="sub" style="">A</span>=2<span class="super" style="">n</span>-1 (where n is the number of bits per encryption block for the agreed encryption algorithm) then C<span class="sub" style="">A</span> MUST be "incremented" to 1.</p>
        <p class="caption"></p>
<div class="indent"><pre>m_final = encrypt(K-E<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, m_compressed)</pre></div>
      </li>
      <li>
        <p class="" style="">The encrypted data and the value of Alice's encryption block counter C<span class="sub" style="">A</span> <span style="font-style: italic">before</span> the data was encrypted, are now processed through the HMAC algorithm (as defined in Section 2 of <span class="ref" style="">RFC 2104</span>  [<a href="#nt-id2258436">27</a>]), along with the agreed hash algorithm ("HASH") and the integrity key K-M<span class="sub" style="">A</span>.</p>
        <p class="caption"></p>
<div class="indent"><pre>a_mac = HMAC(HASH, K-M<span class="sub" style="">A</span>, m_final, C<span class="sub" style="">A</span>)</pre></div>
      </li>
    </ol>
    <p class="" style="">Note: C<span class="sub" style="">A</span> and C<span class="sub" style="">B</span> prevent replay attacks by ensuring that the Message Authentication Code (MAC) for a given stanza never repeats, even if the content of the stanza is identical.</p>

    <p class="" style="">Alice MUST now create an &lt;encrypted/&gt; XML element using a_mac, m_final and Bob's KID (the one that corresponds to the value of d used to encrypt the data). She MUST insert the element into the stanza in place of the original content and send it to Bob. There MUST NOT be more than one &lt;encrypted/&gt; element per stanza.</p>

    <p class="caption">Example 13. Stanza with Encrypted Content</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data kid=' ** KID ** '&gt; ** base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
  &lt;amp xmlns='http://jabber.org/protocol/amp' per-hop='true'&gt;
    &lt;rule condition='match-resource' value='exact' action='error'/&gt;
  &lt;/amp&gt;
  &lt;headers xmlns='http://jabber.org/protocol/shim'&gt;
    &lt;header name='Store'&gt;false&lt;/header&gt;
  &lt;/headers&gt;
&lt;/message&gt;
    </pre></div>

    <p class="" style="">When Bob receives the stanza from Alice, he extracts the values of m_final and a_mac from the content and performs the following steps. Note: Alice may not have received Bob's last re-key (see <a href="#rekey">Re-Keying</a>) before sending the stanza. So Bob MUST ensure he uses the values of K-E<span class="sub" style="">A</span> and K-M<span class="sub" style="">A</span> that correspond to his KID that Alice sent him in this stanza (and the current value of e that Alice sent him previously).</p>
    <ol start="1" type="">
      <li>
        <p class="" style="">Calculate the MAC for the encrypted data.</p>
        <p class="caption"></p>
<div class="indent"><pre>b_mac = HMAC(HASH, K-M<span class="sub" style="">A</span>, m_final, C<span class="sub" style="">A</span>)</pre></div>
      </li>
      <li>
        <p class="" style="">Verify that b_mac and a_mac match. If they are not identical, the encrypted content has been tampered with and Bob MUST terminate the ESession by sending an error to Alice. Note: If Bob receives a stanza out-of-order, then the MACs will not match because the values of C<span class="sub" style="">A</span> are not synchronized.</p>
      </li>
      <li>
        <p class="" style="">Decrypt m_final using the agreed algorithm, K-E<span class="sub" style="">A</span> and C<span class="sub" style="">A</span>. Note: C<span class="sub" style="">A</span> MUST be incremented for each decrypted block, and if C<span class="sub" style="">A</span>=2<span class="super" style="">n</span>-1 (where n is the number of bits per encryption block for the agreed encryption algorithm) then C<span class="sub" style="">A</span> MUST be "incremented" to 1.</p>
        <p class="caption"></p>
<div class="indent"><pre>m_compressed = decrypt(K-E<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, m_final)</pre></div>
      </li>
      <li>
        <p class="" style="">If compression was agreed upon, decompress m_compressed using the negotiated algorithm.</p>
        <p class="caption"></p>
<div class="indent"><pre>m = decompress(m_compressed)</pre></div>
      </li>
      <li>
        <p class="" style="">Replace the &lt;encrypted/&gt; element in the serialized XML stanza with m and feed the stanza into an XML parser. If the parser returns an XML format error then Bob MUST terminate the ESession by sending an error to Alice.</p>
      </li>
    </ol>
  <h2>8.
       <a name="rekey">Re-Key Exchange</a>
</h2>
<p class="" style="">Once an attacker has discovered an encryption key it could be used to decrypt all stanzas within a session, including stanzas that were intercepted <span style="font-style: italic">before</span> the key was discovered. To reduce the window of vulnerability, both Alice and Bob SHOULD change their values of x and y and re-exchange the encryption key as regularly as possible. They MUST also destroy all copies of keys as soon as they are no longer needed.</p>
<p class="" style="">Note: Although most entities are capable of re-keying after each stanza, clients running in constrained runtime environments may require a few seconds to re-key. During Esession initiation these clients MAY negotiate the minimum number of stanzas to be exchanged between re-keys at the cost of a larger window of vulnerability. Entities MUST NOT initiate key re-exchanges more frequently than the agreed limit.</p>

  <div class="indent">
<h3>8.1 <a name="rekey-init">Re-Key Initiation</a>
</h3>
    <p class="" style="">Either Alice or Bob MAY initiate a key re-exchange. Here we describe the process initiated by Alice. First she MUST calculate new values for the encryption parameters:</p>
    <ol start="1" type="">
      <li><p class="" style="">Generate a secret random number x (where 2<span class="super" style="">2n-1</span> &lt; x &lt; p - 1, where n is the number of bits per encryption block for the agreed encryption algorithm)</p></li>
      <li><p class="" style="">Calculate e = g<span class="super" style="">x</span> mod p</p></li>
      <li><p class="" style="">Generate an opaque unique key identifier (KID) for e</p></li>
      <li><p class="" style="">Calculate K = d<span class="super" style="">x</span> mod p (the new shared secret)</p></li>
      <li><p class="" style="">Calculate K-E<span class="sub" style="">A</span>, K-M<span class="sub" style="">A</span>, K-E<span class="sub" style="">B</span>, K-M<span class="sub" style="">B</span> (see <a href="#init-keys">Generating Initial Session Keys</a>)</p></li>
    </ol>
    <p class="" style="">To avoid extra stanzas, the new value of e SHOULD be sent to Bob along with an encrypted stanza. Note: Alice MUST NOT use the new K-E<span class="sub" style="">A</span> and K-M<span class="sub" style="">A</span> to encrypt this stanza or to calculate the MAC. However, she MUST use them when sending subsequent stanzas.</p>
    <p class="" style="">There is no need for Alice to provide a signature for e because the calculation of the MAC MUST include the new value of e (a_mac = HMAC(HASH, K-M<span class="sub" style="">A</span>, m_final, C<span class="sub" style="">A</span>, e), see <a href="#exchange">Exchanging Stanzas</a>).</p>
    <p class="caption">Example 14. Alice Sends Re-Key Stanza</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data kid=' ** KID ** '&gt; ** base64 encoded m_final ** &lt;/data&gt;
    &lt;key kid=' ** KID ** '&gt; ** base64 encoded value of new e ** &lt;/key&gt;
    &lt;mac&gt; ** base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">Note: Bob may not receive the new key before he sends his next stanzas (they may cross in transit). So, before destroying her old values of K-E<span class="sub" style="">B</span> and K-M<span class="sub" style="">B</span>, Alice MUST wait until either she receives a stanza encrypted with the new key, or a reasonable time has passed (60 seconds should cover a network round-trip and calculations by a constrained client). Similarly she MUST wait before destroying her old value of x, in case Bob sends two stanzas before receiving Alice's new key (the first stanza might include a re-key).</p>
  </div>
  <div class="indent">
<h3>8.2 <a name="rekey-accept">Re-Key Acceptance</a>
</h3>
    <p class="" style="">After Bob receives a stanza with a new value of e and he has decrypted the stanza with the old value of K-E<span class="sub" style="">A</span>, he MUST securely destroy all copies of K-E<span class="sub" style="">A</span> and K-E<span class="sub" style="">B</span> and perform the following calculations with the new value of e:</p>
    <ol start="1" type="">
      <li><p class="" style="">Calculate K = e<span class="super" style="">y</span> mod p</p></li>
      <li><p class="" style="">Calculate K-E<span class="sub" style="">A</span>, K-M<span class="sub" style="">A</span>, K-E<span class="sub" style="">B</span>, K-M<span class="sub" style="">B</span> (see <a href="#init-keys">Generating Initial Session Keys</a>)</p></li>
    </ol>
    <p class="" style="">He MUST use these new values to encrypt and decrypt all subsequent stanzas.</p>
    <p class="" style="">Note: If an entity fails to receive any stanza that includes a new key in the correct order, then it will fail to decrypt the next stanza it receives and be forced to terminate the Esession.</p>
  </div>
  <div class="indent">
<h3>8.3 <a name="rekey-publish">Publishing Old Values of K-M</a>
</h3>
    <p class="" style="">Either entity MAY publish old values of K-M<span class="sub" style="">A</span> and/or K-M<span class="sub" style="">B</span> as part of any encrypted stanza as long as it knows that all the stanzas that MAY use the old values have been received and validated. It MUST wait until it has received either a re-key or a stanza encrypted with a newer key from the other entity.</p>
    <p class="" style="">Once the expired MAC keys have been published, anyone could create valid arbitrary stanzas with them. This prevents anyone being able to prove the authenticity of a transcript of the Esession in the future.</p>
    <p class="caption">Example 15. Publishing Expired MAC Keys</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data kid=' ** KID ** '&gt; ** base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** base64 encoded a_mac ** &lt;/mac&gt;
    &lt;old&gt; ** base64 encoded old MAC key ** &lt;/old&gt;
    &lt;old&gt; ** base64 encoded old MAC key ** &lt;/old&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">Entities MUST ignore any &lt;old/&gt; elements they receive.</p>
  </div>
  <h2>9.
       <a name="sec">Security Considerations</a>
</h2>
  <div class="indent">
<h3>9.1 <a name="sec-prng">Verifying Keys</a>
</h3>
    <p class="" style="">Weak pseudo-random number generators (PRNG) enable successful attacks. Implementors MUST use a cryptographically strong PRNG to generate all random numbers (see <span class="ref" style="">RFC 1750</span>  [<a href="#nt-id2259334">28</a>]).</p>
  </div>
  <div class="indent">
<h3>9.2 <a name="sec-rekey">Re-Keying Limits</a>
</h3>
    <p class="" style="">After a key exchange an entity MUST NOT exchange a total of 2<span class="super" style="">32</span> encrypted blocks before it initiates a key re-exchange (see <span class="ref" style="">SSH Transport Layer Encryption Modes</span>  [<a href="#nt-id2259384">29</a>]).</p>
    <p class="" style="">Note: This policy also ensures the same key and counter values are never used to encrypt two different blocks using counter mode. This is necessary to prevent simple attacks.</p>
  </div>
  <div class="indent">
<h3>9.3 <a name="sec-keys">Verifying Keys</a>
</h3>
    <p class="" style="">The trust system outlined herein is based on Alice trusting that the public key presented by Bob is <span style="font-style: italic">actually</span> Bob's key. Determining this trust may be done in a variety of ways depending on the entities' support for different public key (certificate) formats, signing algorithms and signing authorities. For instance, if Bob publishes a PGP/GPG public key, Alice MAY verify that his key is signed by another key that she knows to be good. Or, if Bob provides an X.509 certificate, she MAY check that his key has been signed by a Certificate Authority that she trusts.</p>
    <p class="" style="">When trust cannot be achieved automatically, methods that are not transparent to the users may be employed. For example, Bob could communicate the SHA-256 fingerprint of his public key to Alice via secure out-of-band communication (e.g. face-to-face). This would enable Alice to confirm that the public key she receives in-band is valid. Note however that very few people bother to verify fingerprints in this way. So this method is exceptionally vulnerable to 'man-in-the-middle' attacks. In order to reduce the window of vulnerability, an entity SHOULD remember the fingerprints of all user-validated public keys and alert the user in the future if ever the fingerprint(s) it stored for an entity do not match any of the received public keys.</p>
    <p class="" style="">Alternatively Alice and Bob could agree a shared secret via secure out-of-band communication, Bob could then use it to create an HMAC of his public key that only Alice could verify.</p>
    <p class="" style="">Note: If no keys are acceptable to Alice (because Alice has never verified any of the keys, and because either the keys are not signed, or Alice does not support the signature algorithms of the keys, or she cannot parse the certificate formats, or she does not recognise the authorities that signed the keys) then, although the Esession can still be encrypted, she cannot be sure she is communicating with Bob.</p>
  </div>
  <div class="indent">
<h3>9.4 <a name="sec-general">Extra Responsabilities of Implementors</a>
</h3>
    <p class="" style="">Cryptography plays only a small part in an entity's security. Even if it implements this protocol perfectly it may still be vulnerable to other attacks. For example, an implementation might save private keys to a file in cleartext! Implementors MUST take very great care when developing applications with secure technologies.</p>
  </div>
  <div class="indent">
<h3>9.5 <a name="sec-mandatory">Mandatory to Implement Technologies</a>
</h3>
    <p class="" style="">Note: The security parameter names mentioned below are related to secure shell; see <span style="font-weight: bold">SSH Transport Layer Encryption Modes</span> for encryption algorithm details; see the <span class="ref" style="">IANA Secure Shell Protocol Parameters</span>  [<a href="#nt-id2259544">30</a>] for other names.</p>
    <div class="indent">
<h3>9.5.1 <a name="sec-mandatory-encryption">Encryption Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support at least the following encryption algorithm:</p>
      <ul>
        <li>aes128-ctr (see <span class="ref" style="">Advanced Encryption Standard</span>  [<a href="#nt-id2259592">31</a>])</li>
      </ul>
      <p class="" style="">The block length of an encryption algorithm's cipher SHOULD be at least 128 bits. Other compliant algorithm names include:</p>
      <ul>
        <li>aes256-ctr</li>
        <li>aes192-ctr</li>
        <li>twofish256-ctr (see <span class="ref" style="">Twofish</span>  [<a href="#nt-id2259636">32</a>])</li>
        <li>twofish192-ctr</li>
        <li>twofish128-ctr</li>
        <li>serpent256-ctr (see <span class="ref" style="">Serpent</span>  [<a href="#nt-id2259670">33</a>])</li>
        <li>serpent192-ctr</li>
        <li>serpent128-ctr</li>
      </ul>
    </div>
    <div class="indent">
<h3>9.5.2 <a name="sec-mandatory-sign">Key Signing Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support at least the following signing algorithms:</p>
      <ul>
        <li>rsa (see <span class="ref" style="">RFC 2437</span>  [<a href="#nt-id2259721">34</a>])</li>
        <li>dss (see <span class="ref" style="">Digital Signature Standard</span>  [<a href="#nt-id2259744">35</a>])</li>
      </ul>
    </div>
    <div class="indent">
<h3>9.5.3 <a name="sec-mandatory-public">Public Signature-Verification-Key Formats</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support at least the following public key formats:</p>
      <ul>
        <li>ssh-rsa</li>
        <li>ssh-dss</li>
      </ul>
      <p class="" style="">An implementation of ESession SHOULD also support at least the following public key formats:</p>
      <ul>
        <li>x509v3-sign-rsa (see <span class="ref" style="">X.509 Authentication in SSH2</span>  [<a href="#nt-id2259808">36</a>])</li>
        <li>x509v3-sign-dss</li>
        <li>pgp-sign-rsa</li>
        <li>pgp-sign-dss</li>
      </ul>
      <p class="" style="">An implementation of ESession MAY also support the following public key formats:</p>
      <ul>
        <li>spki-sign-rsa</li>
        <li>spki-sign-dss</li>
      </ul>
    </div>
    <div class="indent">
<h3>9.5.4 <a name="sec-mandatory-hash">Hash Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support at least the following hash algorithms (sha1 and md5 are NOT RECOMMENDED):</p>
      <ul>
        <li>sha256 (see <span class="ref" style="">Secure Hash Standard</span>  [<a href="#nt-id2259887">37</a>])</li>
        <li>whirlpool (see <span class="ref" style="">Whirlpool</span>  [<a href="#nt-id2259916">38</a>])</li>
      </ul>
    </div>
    <div class="indent">
<h3>9.5.5 <a name="sec-mandatory-compress">Compression Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support the following compression algorithm:</p>
      <ul>
        <li>none (no compression)</li>
      </ul>
      <p class="" style="">It is RECOMMENDED that an implementation of ESession also support the following compression algorithm:</p>
      <ul>
        <li>zlib (see <span class="ref" style="">RFC 1950</span>  [<a href="#nt-id2259971">39</a>])</li>
      </ul>
    </div>
  </div>
<h2>10.
       <a name="iana">IANA Considerations</a>
</h2>
  <p class="" style="">This JEP requires no interaction with the <span class="ref" style="">Internet Assigned Numbers Authority (IANA)</span>  [<a href="#nt-id2260012">40</a>]. </p>
<h2>11.
       <a name="registrar">Jabber Registrar Considerations</a>
</h2>
  <div class="indent">
<h3>11.1 <a name="registrar-ns">Namespaces</a>
</h3>
    <p class="" style="">Upon approval of this JEP, the <span class="ref" style="">Jabber Registrar</span>  [<a href="#nt-id2260060">41</a>] shall register the following namespaces:</p>
    <ul>
      <li>http://jabber.org/protocol/esession</li>
      <li>http://jabber.org/protocol/esession#init</li>
      <li>http://jabber.org/protocol/esession#error</li>
    </ul>
  </div>
  <div class="indent">
<h3>11.2 <a name="registrar-formtype">Field Standardization</a>
</h3>
    <p class="" style="">The Jabber Registrar shall reserve the following fields within the scope of Data Forms used for ESession negotation:</p>
    <p class="caption">Registry Submission</p>
<div class="indent"><pre>
&lt;form_type&gt;
  &lt;name&gt;http://jabber.org/protocol/esession&lt;/name&gt;
  &lt;jep&gt;JEP-0116&lt;/jep&gt;
  &lt;desc&gt;ESession negotiation forms&lt;/desc&gt;
  &lt;field
      var='modp'
      type='list-single'
      label='MODP group number'/&gt;
  &lt;field
      var='encryption_algorithms'
      type='list-single'
      label='Symmetric block cipher options'/&gt;
  &lt;field
      var='hash_algorithms'
      type='list-single'
      label='Hash algorithm options'/&gt;
  &lt;field
      var='compression'
      type='list-single'
      label='Compression algorithm options'/&gt;
  &lt;field
      var='stanzas'
      type='list-multi'
      label='Stanzas types to encrypt'/&gt;
  &lt;field
      var='max_rekey_freq'
      type='text-single'
      label='Minimum number of stanzas between key exchanges'/&gt;
  &lt;field
      var='publickey_ids'
      type='list-multi'
      label='Public key IDs'/&gt;
  &lt;field
      var='kid'
      type='text-single'
      label='Diffie-Hellman key ID'/&gt;
  &lt;field
      var='key'
      type='text-single'
      label='Diffie-Hellman key'/&gt;
  &lt;field
      var='sign'
      type='list-multi'
      label='Diffie-Hellman key signatures'/&gt;
&lt;/form_type&gt;
    </pre></div>
  </div>
<h2>12.
       <a name="schema">XML Schemas</a>
</h2>
  <p class="" style="">To follow.</p>
<h2>13.
       <a name="keys">Public Key Publication and Retrieval</a>
</h2>
  <p class="" style=""><span style="font-style: italic">Note: This section is highly preliminary and will probably be specified in a separate proposal.</span></p>
  <p class="" style="">Entities SHOULD publish their long-term public signature-verification keys through their own server using the disco#publish-info feature (as <a href="http://mail.jabber.org/pipermail/standards-jig/2005-July/008131.html">NOT SPECIFIED</a> in <span style="font-weight: bold">JEP-0030</span>).</p>

  <p class="caption">Example 16. Entity Publishes Public Keys to Server</p>
<div class="indent"><pre>
&lt;iq type='set'
    from='alice@example.org/pda'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/publickeys'&gt;
    &lt;x xmlns='jabber:x:data' type='submit'&gt;
      &lt;field var='FORM_TYPE' type='hidden'&gt;
        &lt;value&gt;http://jabber.org/protocol/publickeys&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='types'&gt;
        &lt;value&gt;x509v3-sign-rsa&lt;/value&gt;
        &lt;value&gt;pgp-sign-dss&lt;/value&gt;
        &lt;value&gt;ssh-rsa&lt;/value&gt;
        &lt;value&gt;ssh-dss&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='keys'&gt;
        &lt;value&gt; ** base64 encoded x509 certificate containing RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** base64 encoded OpenPGP certificate containing DSS public key ** &lt;/value&gt;
        &lt;value&gt; ** base64 encoded unsigned RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** base64 encoded unsigned DSS public key ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>

  <p class="" style="">Before initiating an ESession, if Bob does not already possess one of Alice's signature-verification keys, he SHOULD retrieve them from Alice's server.</p>
  <p class="caption">Example 17. Bob Requests Public Keys from Alice's Server</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='bob@example.com/laptop'
    to='alice@example.org'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/publickeys'/&gt;
&lt;/iq&gt;
  </pre></div>

  <p class="caption">Example 18. Server Returns Public Keys</p>
<div class="indent"><pre>
&lt;iq type='result'
    from='alice@example.org'
    to='bob@example.com/laptop'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/publickeys'&gt;
    &lt;x xmlns='jabber:x:data' type='result'&gt;
      &lt;field var='FORM_TYPE' type='hidden'&gt;
        &lt;value&gt;http://jabber.org/protocol/publickeys&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='types'&gt;
        &lt;value&gt;x509v3-sign-rsa&lt;/value&gt;
        &lt;value&gt;pgp-sign-dss&lt;/value&gt;
        &lt;value&gt;ssh-rsa&lt;/value&gt;
        &lt;value&gt;ssh-dss&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='keys'&gt;
        &lt;value&gt; ** base64 encoded x509 certificate containing RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** base64 encoded OpenPGP certificate containing DSS public key ** &lt;/value&gt;
        &lt;value&gt; ** base64 encoded unsigned RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** base64 encoded unsigned DSS public key ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
  <p class="" style="">Bob should examine all the public keys and identify which ones are acceptable (see <a href="#sec-keys">Verifying Keys</a>).</p>
<h2>14.
       <a name="open">Open Issues</a>
</h2>
  <ol start="" type="">
    <li>Specify that entities should use multiple XML parser instances to guard against presence of non-well-formed XML (not checked by server).</li>
    <li>Define session tear-down (entities SHOULD do this automatically after some period of inactivity).</li>
    <li>Give examples of specific errors and discuss error scenarios (e.g. What should Bob do if he is not offline and he receives an offline key exchange stanza?) throughout document.</li>
    <li>Discuss signature formats in greater detail.</li>
    <li>Discuss in-order processing.</li>
    <li>Discuss the risk of Bob divulging his presence status if anyone can monitor changes to his offline DH key. (Can access be limited to people who are subscribing to his presence?)</li>
    <li>Specify that stanzas should be cached (for a few seconds) and resent in any new session that is established as a result of an error in the old session?</li>
    <li>Examine potential use of a SID in key calculations (see SSH/OTR).</li>
    <li>Separate public key publishing into a disco item for each key?</li>
    <li>Should entities signs the whole init element (instead of just the value of d or e (see OTR)?</li>
    <li>Should entities HMAC the whole encrypted element - the KID as well as the encrpted data etc (see OTR)?</li>
    <li>Could the protocol approximate SSH or IPsec even more closely without losing the benefits of OTR?</li>
  </ol>
<p><hr></p>
<a name="notes"></a><h2>Notes</h2>
<div class="indent">
<p><a name="nt-id2250515">1</a>. JEP-0027: Current Jabber OpenPGP Usage &lt;<a href="http://www.jabber.org/jeps/jep-0027.html">http://www.jabber.org/jeps/jep-0027.html</a>&gt;.</p>
<p><a name="nt-id2250681">2</a>. RFC 3862: Common Presence and Instant Messaging (CPIM): Message Format &lt;<a href="http://www.ietf.org/rfc/rfc3862.txt">http://www.ietf.org/rfc/rfc3862.txt</a>&gt;.</p>
<p><a name="nt-id2250702">3</a>. RFC 3863: Presence Information Data Format (PIDF) &lt;<a href="http://www.ietf.org/rfc/rfc3863.txt">http://www.ietf.org/rfc/rfc3863.txt</a>&gt;.</p>
<p><a name="nt-id2250725">4</a>. RFC 3923: End-to-End Signing and Object Encryption for the Extensible Messaging and Presence Protocol (XMPP) &lt;<a href="http://www.ietf.org/rfc/rfc3923.txt">http://www.ietf.org/rfc/rfc3923.txt</a>&gt;.</p>
<p><a name="nt-id2250769">5</a>. Off-the-Record Communication, or, Why Not to Use PGP &lt;<a href="http://www.isaac.cs.berkeley.edu/~iang/pubs/otr-wpes.pdf">http://www.isaac.cs.berkeley.edu/~iang/pubs/otr-wpes.pdf</a>&gt;.</p>
<p><a name="nt-id2250545">6</a>. RFC 3920: Extensible Messaging and Presence Protocol (XMPP): Core &lt;<a href="http://www.ietf.org/rfc/rfc3920.txt">http://www.ietf.org/rfc/rfc3920.txt</a>&gt;.</p>
<p><a name="nt-id2250575">7</a>. RFC 3921: Extensible Messaging and Presence Protocol (XMPP): Instant Messaging and Presence &lt;<a href="http://www.ietf.org/rfc/rfc3921.txt">http://www.ietf.org/rfc/rfc3921.txt</a>&gt;.</p>
<p><a name="nt-id2250626">8</a>. RFC 2246: The TLS Protocol Version 1.0 &lt;<a href="http://www.ietf.org/rfc/rfc2246.txt">http://www.ietf.org/rfc/rfc2246.txt</a>&gt;.</p>
<p><a name="nt-id2255633">9</a>. JEP-0096: File Transfer &lt;<a href="http://www.jabber.org/jeps/jep-0096.html">http://www.jabber.org/jeps/jep-0096.html</a>&gt;.</p>
<p><a name="nt-id2255661">10</a>. JEP-0079: Advanced Message Processing &lt;<a href="http://www.jabber.org/jeps/jep-0079.html">http://www.jabber.org/jeps/jep-0079.html</a>&gt;.</p>
<p><a name="nt-id2255682">11</a>. JEP-0131: Stanza Headers and Internet Metadata (SHIM) &lt;<a href="http://www.jabber.org/jeps/jep-0131.html">http://www.jabber.org/jeps/jep-0131.html</a>&gt;.</p>
<p><a name="nt-id2255715">12</a>. JEP-0045: Multi-User Chat &lt;<a href="http://www.jabber.org/jeps/jep-0045.html">http://www.jabber.org/jeps/jep-0045.html</a>&gt;.</p>
<p><a name="nt-id2255744">13</a>. JEP-0060: Publish-Subscribe &lt;<a href="http://www.jabber.org/jeps/jep-0060.html">http://www.jabber.org/jeps/jep-0060.html</a>&gt;.</p>
<p><a name="nt-id2255874">14</a>. SSH Protocol Architecture &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-architecture-22.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-architecture-22.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2255845">15</a>. SSH Transport Layer Protocol &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-transport-24.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-transport-24.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2256200">16</a>. Naturally, it is possible that Alice or Bob may retain cleartext versions of the exchanged communications; however, that threat is out of scope for this JEP.</p>
<p><a name="nt-id2256401">17</a>. JEP-0030: Service Discovery &lt;<a href="http://www.jabber.org/jeps/jep-0030.html">http://www.jabber.org/jeps/jep-0030.html</a>&gt;.</p>
<p><a name="nt-id2256424">18</a>. JEP-0115: Entity Capabilities &lt;<a href="http://www.jabber.org/jeps/jep-0115.html">http://www.jabber.org/jeps/jep-0115.html</a>&gt;.</p>
<p><a name="nt-id2256523">19</a>. RFC 2631: Diffie-Hellman Key Agreement Method &lt;<a href="http://www.ietf.org/rfc/rfc2631.txt">http://www.ietf.org/rfc/rfc2631.txt</a>&gt;.</p>
<p><a name="nt-id2256586">20</a>. JEP-0155: Chat Session Negotiation &lt;<a href="http://www.jabber.org/jeps/jep-0155.html">http://www.jabber.org/jeps/jep-0155.html</a>&gt;.</p>
<p><a name="nt-id2256653">21</a>. RFC 2409: The Internet Key Exchange (IKE) &lt;<a href="http://www.ietf.org/rfc/rfc2409.txt">http://www.ietf.org/rfc/rfc2409.txt</a>&gt;.</p>
<p><a name="nt-id2256677">22</a>. RFC 3526: More Modular Exponential (MODP) Diffie-Hellman Groups &lt;<a href="http://www.ietf.org/rfc/rfc3526.txt">http://www.ietf.org/rfc/rfc3526.txt</a>&gt;.</p>
<p><a name="nt-id2256771">23</a>. RFC 3548: The Base16, Base32, and Base64 Data Encodings &lt;<a href="http://www.ietf.org/rfc/rfc3548.txt">http://www.ietf.org/rfc/rfc3548.txt</a>&gt;.</p>
<p><a name="nt-id2256878">24</a>. RFC 3766: Determining Strengths For Public Keys Used For Exchanging Symmetric Keys &lt;<a href="http://www.ietf.org/rfc/rfc3766.txt">http://www.ietf.org/rfc/rfc3766.txt</a>&gt;.</p>
<p><a name="nt-id2258073">25</a>. K-M<span class="sub" style="">A</span> is a hash of K-E<span class="sub" style="">A</span> (not K) to ensure that if an attacker recovers the decryption key she will not be able to cryptographically convince anyone that it was not her who created the stanza.</p>
<p><a name="nt-id2258282">26</a>. Although counter mode encryption requires no padding, implementations MAY still disguise the length of m by appending a random number of white-space characters.</p>
<p><a name="nt-id2258436">27</a>. RFC 2104: HMAC: Keyed-Hashing for Message Authentication &lt;<a href="http://www.ietf.org/rfc/rfc2104.txt">http://www.ietf.org/rfc/rfc2104.txt</a>&gt;.</p>
<p><a name="nt-id2259334">28</a>. RFC 1750: Randomness Recommendations for Security &lt;<a href="http://www.ietf.org/rfc/rfc1750.txt">http://www.ietf.org/rfc/rfc1750.txt</a>&gt;.</p>
<p><a name="nt-id2259384">29</a>. SSH Transport Layer Encryption Modes &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-04.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-04.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2259544">30</a>. IANA registry of parameters related to secure shell &lt;<a href="http://www.iana.org/assignments/ssh-parameters">http://www.iana.org/assignments/ssh-parameters</a>&gt;.</p>
<p><a name="nt-id2259592">31</a>. Advanced Encryption Standard: Federal Information Processing Standards Publication 197 &lt;<a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf</a>&gt;.</p>
<p><a name="nt-id2259636">32</a>. The Twofish Block Cipher &lt;<a href="http://www.schneier.com/twofish.html">http://www.schneier.com/twofish.html</a>&gt;.</p>
<p><a name="nt-id2259670">33</a>. The Serpent Block Cipher &lt;<a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">http://www.cl.cam.ac.uk/~rja14/serpent.html</a>&gt;.</p>
<p><a name="nt-id2259721">34</a>. RFC 2437: PKCS #1: RSA Cryptography Specifications Version 2.0 &lt;<a href="http://www.ietf.org/rfc/rfc2437.txt">http://www.ietf.org/rfc/rfc2437.txt</a>&gt;.</p>
<p><a name="nt-id2259744">35</a>. Digital Signature Standard: Federal Information Processing Standards Publication 186  &lt;<a href="http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf">http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf</a>&gt;.</p>
<p><a name="nt-id2259808">36</a>. X.509 Authentication in SSH2 &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-x509-02.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-x509-02.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2259887">37</a>. Secure Hash Standard: Federal Information Processing Standards Publication 180-2  &lt;<a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">http://csrc.nist.gov/publications/fips/fips180-2/fips186-2withchangenotice.pdf</a>&gt;.</p>
<p><a name="nt-id2259916">38</a>. The Whirlpool Hash Function &lt;<a href="http://paginas.terra.com.br/informatica/paulobarreto/WhirlpoolPage.html">http://paginas.terra.com.br/informatica/paulobarreto/WhirlpoolPage.html</a>&gt;.</p>
<p><a name="nt-id2259971">39</a>. RFC 1950: ZLIB Compressed Data Format Specification version 3.3 &lt;<a href="http://www.ietf.org/rfc/rfc1950.txt">http://www.ietf.org/rfc/rfc1950.txt</a>&gt;.</p>
<p><a name="nt-id2260012">40</a>. The Internet Assigned Numbers Authority (IANA) is the central coordinator for the assignment of unique parameter values for Internet protocols, such as port numbers and URI schemes. For further information, see &lt;<a href="http://www.iana.org/">http://www.iana.org/</a>&gt;.</p>
<p><a name="nt-id2260060">41</a>. The Jabber Registrar maintains a list of reserved Jabber protocol namespaces as well as registries of parameters used in the context of protocols approved by the Jabber Software Foundation. For further information, see &lt;<a href="http://www.jabber.org/registrar/">http://www.jabber.org/registrar/</a>&gt;.</p>
</div>
<p><hr></p>
<a name="revs"></a><h2>Revision History</h2>
<div class="indent">
<h4>Version 0.3 (2005-08-02)</h4>
<div class="indent">Changed status from Retracted to Experimental; complete rewrite; new Introduction, Background, Requirements and Security Considerations; new OTR-inspired protocol; JEP-0155-based negotiation; counter mode encryption; more secure hashes; offline sessions; re-keying; mac publishing; preliminary key and options publishing protocol. (ip/psa)
    </div>
<h4>Version 0.2 (2004-07-26)</h4>
<div class="indent">At the request of the JEP author, changed status to Retracted. (psa)
    </div>
<h4>Version 0.1 (2003-09-09)</h4>
<div class="indent">Initial version. (dss/psa)
    </div>
</div>
<p><hr></p>
<p>END</p>
</body>
</html>
