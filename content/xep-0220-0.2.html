<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>XEP-0220: Server Dialback</title><link rel="stylesheet" type="text/css" href="../xmpp.css" /><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" /><meta name="DC.Title" content="Server Dialback" /><meta name="DC.Creator" content="Peter Saint-Andre" /><meta name="DC.Creator" content="Jeremie Miller" /><meta name="DC.Description" content="This specification defines the Server Dialback protocol, which is used between XMPP servers to provide identity verification. Server Dialback uses the Domain Name System (DNS) as the basis for verifying identity; the basic approach is that when a receiving server receives a server-to-server connection request from an originating server, it does not accept the request until it has verified a key with an authoritative server for the domain asserted by the originating server. Although Server Dialback does not provide strong authentication or trusted federation and although it is subject to DNS poisoning attacks, since its development in the year 2000 it has effectively prevented most instances of address spoofing on the XMPP network." /><meta name="DC.Publisher" content="XMPP Standards Foundation" /><meta name="DC.Contributor" content="XMPP Extensions Editor" /><meta name="DC.Date" content="2008-06-18" /><meta name="DC.Type" content="XMPP Extension Protocol" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="XEP-0220" /><meta name="DC.Language" content="en" /><meta name="DC.Rights" content="This XMPP Extension Protocol is copyright (c) 1999 - 2008 by the XMPP Standards Foundation (XSF)." /></head><body><h1>XEP-0220: Server Dialback</h1><p>This specification defines the Server Dialback protocol, which is used between XMPP servers to provide identity verification. Server Dialback uses the Domain Name System (DNS) as the basis for verifying identity; the basic approach is that when a receiving server receives a server-to-server connection request from an originating server, it does not accept the request until it has verified a key with an authoritative server for the domain asserted by the originating server. Although Server Dialback does not provide strong authentication or trusted federation and although it is subject to DNS poisoning attacks, since its development in the year 2000 it has effectively prevented most instances of address spoofing on the XMPP network.</p><hr /><p style="color:red">WARNING: This Standards-Track document is Experimental. Publication as an XMPP Extension Protocol does not imply approval of this proposal by the XMPP Standards Foundation. Implementation of the protocol described herein is encouraged in exploratory implementations, but production systems should not deploy implementations of this protocol until it advances to a status of Draft.</p><hr /><h2>Document Information</h2><p class="indent">
            Series: <a href="http://www.xmpp.org/extensions/">XEP</a><br />
            Number: 0220<br />
            Publisher: <a href="/xsf/">XMPP Standards Foundation</a><br />
            Status: 
            <a href="http://www.xmpp.org/extensions/xep-0001.html#states-Experimental">Experimental</a><br />
            Type:
            <a href="http://www.xmpp.org/extensions/xep-0001.html#types-Standards Track">Standards Track</a><br />
            Version: 0.2<br />
            Last Updated: 2008-06-18<br />
                Approving Body: <a href="http://www.xmpp.org/council/">XMPP Council</a><br />Dependencies: XMPP Core<br />
                Supersedes: None<br />
                Superseded By: None<br />
            Short Name: dialback<br />
              Wiki Page: &lt;<a href="http://wiki.jabber.org/index.php/Server Dialback (XEP-0220)">http://wiki.jabber.org/index.php/Server Dialback (XEP-0220)</a>&gt;
            </p><hr /><h2>Author Information</h2><div class="indent"><h3>Peter Saint-Andre</h3><p class="indent">
        JabberID: 
        <a href="xmpp:stpeter@jabber.org">stpeter@jabber.org</a><br />
        URI: 
        <a href="https://stpeter.im/">https://stpeter.im/</a><br /></p><h3>Jeremie Miller</h3><p class="indent">
        Email:
        <a href="mailto:jer@jabber.org">jer@jabber.org</a><br />
        JabberID: 
        <a href="xmpp:jer@jabber.org">jer@jabber.org</a><br /></p></div><hr /><h2>Legal Notices</h2><div class="indent"><h3>Copyright</h3>This XMPP Extension Protocol is copyright (c) 1999 - 2008 by the XMPP Standards Foundation (XSF).<h3>Permissions</h3>Permission is hereby granted, free of charge, to any person obtaining a copy of this specification (the "Specification"), to make use of the Specification without restriction, including without limitation the rights to implement the Specification in a software program, deploy the Specification in a network service, and copy, modify, merge, publish, translate, distribute, sublicense, or sell copies of the Specification, and to permit persons to whom the Specification is furnished to do so, subject to the condition that the foregoing copyright notice and this permission notice shall be included in all copies or substantial portions of the Specification. Unless separate permission is granted, modified works that are redistributed shall not contain misleading information regarding the authors, title, number, or publisher of the Specification, and shall not claim endorsement of the modified works by the authors, any organization or project to which the authors belong, or the XMPP Standards Foundation.<h3>Disclaimer of Warranty</h3><span style="font-weight: bold">## NOTE WELL: This Specification is provided on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. In no event shall the XMPP Standards Foundation or the authors of this Specification be liable for any claim, damages, or other liability, whether in an action of contract, tort, or otherwise, arising from, out of, or in connection with the Specification or the implementation, deployment, or other use of the Specification. ##</span><h3>Limitation of Liability</h3>In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall the XMPP Standards Foundation or any author of this Specification be liable for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising out of the use or inability to use the Specification (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if the XMPP Standards Foundation or such author has been advised of the possibility of such damages.<h3>IPR Conformance</h3>This XMPP Extension Protocol has been contributed in full conformance with the XSF's Intellectual Property Rights Policy (a copy of which may be found at &lt;<a href="http://www.xmpp.org/extensions/ipr-policy.shtml">http://www.xmpp.org/extensions/ipr-policy.shtml</a>&gt; or obtained by writing to XSF, P.O. Box 1641, Denver, CO 80201 USA).</div><hr /><h2>Discussion Venue</h2><p class="indent">The preferred venue for discussion of this document is the Standards discussion list: &lt;<a href="http://mail.jabber.org/mailman/listinfo/standards">http://mail.jabber.org/mailman/listinfo/standards</a>&gt;.</p><p class="indent">Errata may be sent to &lt;<a href="mailto:editor@xmpp.org">editor@xmpp.org</a>&gt;.</p><h2>Relation to XMPP</h2><p class="indent">The Extensible Messaging and Presence Protocol (XMPP) is defined in the XMPP Core (RFC 3920) and XMPP IM (RFC 3921) specifications contributed by the XMPP Standards Foundation to the Internet Standards Process, which is managed by the Internet Engineering Task Force in accordance with RFC 2026. Any protocol defined in this document has been developed outside the Internet Standards Process and is to be understood as an extension to XMPP rather than as an evolution, development, or modification of XMPP itself.</p><h2>Conformance Terms</h2><p class="indent">The following keywords as used in this document are to be interpreted as described in <a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>: "MUST", "SHALL", "REQUIRED"; "MUST NOT", "SHALL NOT"; "SHOULD", "RECOMMENDED"; "SHOULD NOT", "NOT RECOMMENDED"; "MAY", "OPTIONAL".</p><hr /><h2>Table of Contents</h2><div class="indent"><p><br />1.  <a href="#intro">Introduction</a><br />   
      1.1.  <a href="#intro-why">Why Dialback?</a><br />   
      1.2.  <a href="#intro-models">Federation Models</a><br />   
      1.3.  <a href="#intro-what">What Dialback Accomplishes</a><br />   
      1.4.  <a href="#intro-when">When Dialback Is Used</a><br />   
      1.5.  <a href="#intro-howitworks">How Dialback Works</a><br />2.  <a href="#protocol">Protocol</a><br />   
      2.1.  <a href="#o2r">Stream Setup Between Originating Server and Receiving Server</a><br />      
      2.1.1.  <a href="#o2r-resolve">Originating Server Resolves Receiving Server</a><br />      
      2.1.2.  <a href="#o2r-connect">Originating Server Opens TCP Connection</a><br />      
      2.1.3.  <a href="#o2r-sendinitial">Originating Server Sends Initial Stream Header</a><br />      
      2.1.4.  <a href="#o2r-processinitial">Receiving Server Processes Initial Stream Header</a><br />        
      2.1.4.1.  <a href="#o2r-processinitial-success">Success Case</a><br />        
      2.1.4.2.  <a href="#o2r-processinitial-error">Error Cases</a><br />      
      2.1.5.  <a href="#o2r-processresponse">Originating Server Processes Response Stream Header</a><br />        
      2.1.5.1.  <a href="#o2r-processresponse-success">Success Case</a><br />        
      2.1.5.2.  <a href="#o2r-response-error">Error Cases</a><br />   
      2.2.  <a href="#key">Generation and Exchange of Dialback Key</a><br />      
      2.2.1.  <a href="#key-gen">Originating Server Generates Dialback Key</a><br />      
      2.2.2.  <a href="#key-send">Originating Server Sends Dialback Key</a><br />      
      2.2.3.  <a href="#key-process">Receiving Server Processes Dialback Key</a><br />   
      2.3.  <a href="#r2a">Stream Setup Between Receiving Server and Authoritative Server</a><br />      
      2.3.1.  <a href="#r2a-resolve">Receiving Server Resolves Authoritative Server</a><br />      
      2.3.2.  <a href="#r2a-connect">Receiving Server Opens TCP Connection</a><br />      
      2.3.3.  <a href="#r2a-sendinitial">Receiving Server Sends Initial Stream Header</a><br />      
      2.3.4.  <a href="#r2a-processinitial">Authoritative Server Processes Initial Stream Header</a><br />        
      2.3.4.1.  <a href="#r2a-processinitial-success">Success Case</a><br />        
      2.3.4.2.  <a href="#r2a-processinitial-error">Error Cases</a><br />      
      2.3.5.  <a href="#r2a-processresponse">Receiving Server Processes Response Stream Header</a><br />        
      2.3.5.1.  <a href="#r2a-processresponse-success">Success Case</a><br />        
      2.3.5.2.  <a href="#r2a-response-error">Error Cases</a><br />   
      2.4.  <a href="#verify">Exchange of Verification Request</a><br />      
      2.4.1.  <a href="#verify-send">Receiving Server Sends Verification Request</a><br />      
      2.4.2.  <a href="#verify-process">Authoritative Server Processes Verification Request</a><br />        
      2.4.2.1.  <a href="#verify-process-success">Success Case</a><br />        
      2.4.2.2.  <a href="#verify-process-error">Error Cases</a><br />   
      2.5.  <a href="#validate">Validation of Dialback Key and Exchange of Validation Result</a><br />      
      2.5.1.  <a href="#validate-determine">Authoritative Server Determines Validity of Dialback Key</a><br />      
      2.5.2.  <a href="#validate-send">Authoritative Server Sends Validation Result</a><br />      
      2.5.3.  <a href="#validate-process">Receiving Server Processes Validation Result</a><br />        
      2.5.3.1.  <a href="#validate-process-success">Success Case</a><br />        
      2.5.3.2.  <a href="#validate-process-error">Error Cases</a><br />   
      2.6.  <a href="#result">Communication and Handling of Verification Result</a><br />      
      2.6.1.  <a href="#result-communicate">Receiving Server Communicates Verification Result</a><br />      
      2.6.2.  <a href="#result-handle">Receiving Server Handles Verification Result</a><br />        
      2.6.2.1.  <a href="#result-handle-invalid">Invalid Connection</a><br />        
      2.6.2.2.  <a href="#result-handle-valid">Valid Connection</a><br />3.  <a href="#piggybacking">Reuse of Negotiated Connections (Piggybacking)</a><br />4.  <a href="#security">Security Considerations</a><br />5.  <a href="#iana">IANA Considerations</a><br />6.  <a href="#registrar">XMPP Registrar Considerations</a><br />   
      6.1.  <a href="#registrar-ns">Protocol Namespaces</a><br />   
      6.2.  <a href="#registrar-stream">Stream Features</a><br />7.  <a href="#schema">XML Schema</a><br />   
      7.1.  <a href="#schema-dialback">Dialback</a><br />   
      7.2.  <a href="#schema-dialbackfeature">Stream Feature</a><br /><a href="#notes">Notes</a><br /><a href="#revs">Revision History</a></p></div><hr /><h2>1.
       <a name="intro" id="intro">Introduction</a></h2>

  <div class="indent"><h3>1.1 <a name="intro-why" id="intro-why">Why Dialback?</a></h3>
    <p class="" style="">When Jabber technologies were first developed in 1998, they were conceived of as a client-server system similar to email, wherein a client would connect to a server in order to communicate with other clients. Similarly, servers would connect with peer servers to provide inter-domain communication (often called "federation"). In a system that allows federation, it is important for a server to be able to determine the identity of a peer server; accepting a connection from any peer without determining its identity would result in the use of merely asserted identities and a completely uncontrolled approach to federation, which would rapidly devolve into chaos on the open Internet. Clearly such a state of affairs would be unsustainable for a network protocol aiming for widespread deployment.</p>
    <p class="" style="">Unfortunately, that was the state of affairs on the Jabber network during the earliest releases of the original <span class="ref" style=""><a href="http://jabberd.org/">jabberd</a></span>  [<a href="#nt-id2252861">1</a>] server codebase (up through the 1.0 release in May 2000). Therefore the open-source developer community designed a protocol ("Server Dialback") for weak identity verification based on the Domain Name System (DNS), built support for that protocol into the jabberd 1.2 server (released in October 2000), and mandated support for that protocol on the emerging Jabber server network.</p>
    <p class="" style="">When the core Jabber protocols were formalized by the XMPP Working Group of the <span class="ref" style=""><a href="http://www.ietf.org/">Internet Engineering Task Force (IETF)</a></span>  [<a href="#nt-id2252912">2</a>] in 2002-2004, support for strong identity verification was added. That support takes the form of Transport Layer Security (TLS) for encryption of server-to-server XML streams and the Simple Authentication and Security Layer (SASL) for authentication of such streams, using digital certificates issued by trusted root certification authorities (CAs). Documentation of TLS and SASL within XMPP is provided in <span class="ref" style=""><a href="http://tools.ietf.org/html/rfc3920">XMPP Core</a></span>  [<a href="#nt-id2251398">3</a>]. However, the Server Dialback protocol is still in wide use, and probably will be for the foreseeable future given the difficulty (real or perceived) of obtaining digital certificates issued by common certification authorities (CAs). Therefore it is important to maintain accurate documentation of the Server Dialback protocol. Such documentation was originally provided in <span class="ref" style=""><a href="http://tools.ietf.org/html/rfc3920">RFC 3920</a></span>  [<a href="#nt-id2251427">4</a>]. Although that documentation was removed from <span class="ref" style=""><a href="http://tools.ietf.org/html/draft-saintandre-rfc3920bis">rfc3920bis</a></span>  [<a href="#nt-id2251454">5</a>], it is still provided in this specification for the sake of interoperability.</p>
  </div>

  <div class="indent"><h3>1.2 <a name="intro-models" id="intro-models">Federation Models</a></h3>
    <p class="" style="">There are at least four levels of server-to-server federation in Jabber/XMPP networks:</p>
    <ol start="1" class="" style="">
      <li class="" style=""><p class="" style="">Permissive Federation -- a server accepts a connection from any other peer on the network, even without verifiying the identity of the peer based on DNS lookups. The lack of peer verification or authentication means that domains can be spoofed.</p></li>
      <li class="" style=""><p class="" style="">Verified Federation -- a server accepts a connection from a peer only after the identity of the peer has been weakly verified via based on information obtained via the Domain Name System (DNS). However, the connection is not encrypted or authenticated. The use of identity verification effectively prevents domain spoofing, but federation requires proper DNS setup and is still subject to DNS poisoning attacks.</p></li>
      <li class="" style=""><p class="" style="">Encrypted Federation -- a server accepts a connection from a peer only if the peer supports Transport Layer Security (TLS) as defined for XMPP in <span class="ref" style=""><a href="http://tools.ietf.org/html/rfc3920">RFC 3920</a></span>  [<a href="#nt-id2251539">6</a>] and the peer presents a digital certificate. However, the certificate may be self-signed, in which case mutual authentication is typically not possible. Therefore, after STARTTLS negotiation the parties proceed to weakly verify identity based on DNS information as under Verified Federation. This combination results in an encrypted connection with weak identity verification.</p></li>
      <li class="" style=""><p class="" style="">Trusted Federation -- a server accepts a connection from a peer only if the peer supports Transport Layer Security (TLS) and the peer presents a digital certificate issued by a trusted root certification authority (CA). The list of trusted root CAs is determined by local service policy, as is the level of trust accorded to various types of certificates (i.e., Class 1, Class 2, or Class 3). The use of trusted domain certificates effectively prevents DNS poisoning attacks and results in mutual authentication.</p></li>
    </ol>
    <p class="" style="">This specification documents the technology that enabled the Jabber server network to advance beyond Permissive Federation to Verified Federation. Combined with the use of TLS, Server Dialback can also result in Encrypted Federation. However, Trusted Federation is not possible with Server Dialback.</p>
    <p class="" style="">Note: For detailed examples showing the protocol flows and outcomes of dialback negotiation for a wide variety of federation scenarios, refer to <span class="ref" style=""><a href="http://www.xmpp.org/extensions/xep-0238.html">XMPP Protocol Flows for Inter-Domain Federation</a></span>  [<a href="#nt-id2251624">7</a>].</p>
  </div>

  <div class="indent"><h3>1.3 <a name="intro-what" id="intro-what">What Dialback Accomplishes</a></h3>
    <p class="" style="">Server Dialback is a method for weak identify verification. Such verification depends on the Domain Name System (DNS) and the use of keys based on a shared secret known to all XMPP servers within a given trust domain (e.g., the trust domain associated with a given second-level DNS domain such as "example.com" and all of its subdomains).</p>
    <p class="" style="">Since October 2000, the use of Server Dialback has made it more difficult to spoof the hostnames of servers (and therefore the addresses of sent messages) on the XMPP network. However, Server Dialback does not provide authentication between servers and is not a security mechanism. Domains requiring high security are advised to use TLS and SASL with certificates issued by trusted roots.</p>
    <p class="" style="">Server Dialback is uni-directional, and results in weak identity verification for one XML stream in one direction. Because Server Dialback is not an authentication mechanism, mutual authentication is not possible via dialback. Therefore, Server Dialback must be completed in each direction in order to enable bi-directional communication between two domains.</p>
  </div>

  <div class="indent"><h3>1.4 <a name="intro-when" id="intro-when">When Dialback Is Used</a></h3>
    <p class="" style="">Server Dialback is typically used in two scenarios:</p>
    <ol start="1" class="" style="">
      <li class="" style=""><p class="" style="">When a peer service does not support XMPP 1.0 as defined in <span class="ref">RFC 3920</span> or, more generally, does not offer negotiation of TLS.</p></li>
      <li class="" style=""><p class="" style="">When STARTTLS negotiation succeeds with a peer service but the peer's certificate is not strong enough to result in mutual authentication via SASL (e.g., because the certificate presented by the peer service during TLS negotiation is self-signed and and local service policies stipulate that it is preferable to weakly identify the peer service via Server Dialback rather than depend on the self-signed certificate for identity verification).</p></li>
    </ol>
    <p class="" style="">Both of these scenarios result in an untrusted connection (verified federation in the first scenario and encrypted federation in the second scenario). However, depending on local security policies, a server may accept such an untrusted connection if the use of Server Dialback results in weak identity verification.</p>
    <p class="" style="">Dialback is not used if SASL is used for server-to-server authentication, since SASL provides strong authentication using certificates, pre-established passwords, or other credentials.</p>
    <p class="" style="">A service cannot begin negotiation of Server Dialback unless its peer advertises support for the Server Dialback protocol. As described under <a href="o2r-processinitial">Receiving Server Processes Initial Stream Header</a>, a peer advertises support through inclusion of the Server Dialback namespace declaration in its response stream header and (for XMPP 1.0 servers) through inclusion of the Server Dialback stream feature.</p>
  </div>

  <div class="indent"><h3>1.5 <a name="intro-howitworks" id="intro-howitworks">How Dialback Works</a></h3>
    <p class="" style="">The basic idea behind Server Dialback is that a receiving server does not accept XMPP traffic from a sending server until it has "called back" the authoritative server for the domain asserted by the sending server, and verified that the sending server is truly authorized to generate XMPP traffic for that domain.</p>
    <p class="" style="">A helpful analogy might be the following telephone scenario:</p>
    <ol start="1" class="" style="">
      <li class="" style="">A customer service representative from your bank calls you on the phone.</li>
      <li class="" style="">Rather than immediately accepting the phone call, you ask for his employee ID number and put him on hold.</li>
      <li class="" style="">You open the phone book, find the authoritative phone number for the bank's headquarters, and give them a call.</li>
      <li class="" style="">After being transferred to the customer service department, you ask if a rep with that particular ID number is authorized to be calling your number.</li>
      <li class="" style="">The bank tells you that the rep is authorized, so you thank them and hang up.</li>
      <li class="" style="">You then take the rep off hold and continue the conversation.</li>
    </ol>
    <p class="" style="">In Server Dialback, the equivalent of the customer service representative is the ORIGINATING SERVER, i.e., the machine that wants to send a message to an entity at a destination domain and thus is attempting to establish a connection between the two servers. The equivalent of the person being called is the RECEIVING SERVER, i.e., the machine to which the originating server has opened a connection for the purpose of sending the message and thus is trying to authenticate that the Originating Server represents the domain which it claims to be. And the equivalent of the bank is the AUTHORITATIVE SERVER, i.e., the machine that answers to a DNS lookup for the domain asserted by the originating server (which is not necessarily the machine associated with the originating server); for basic environments this will be the Originating Server, but it could be a separate machine in the Originating Server's network (where "network" is defined by knowledge of a shared secret for verification of dialback keys).</p>
    <p class="" style="">The basic flow of events in Server Dialback is as follows:</p>
    <ol start="1" class="" style="">
      <li class="" style="">The Originating Server performs a DNS lookup on the hostname of the Receiving Server, opens a TCP connection to the discovered IP address and port, and establishes an XML stream with the Receiving Server.</li>
      <li class="" style="">The Originating Server generates a dialback key and sends that value over its XML stream with the Receiving Server.</li>
      <li class="" style="">The Receiving Server does not immediately accept the connection but instead performs a DNS lookup on the hostname of the Authoritative Server, opens a TCP connection to the discovered IP address and port, and establishes an XML stream with the Authoritative Server.</li>
      <li class="" style="">The Receiving Server sends the same dialback key over its XML stream with the Authoritative Server for verification.</li>
      <li class="" style="">The Authoritative Server replies that key is valid or invalid.</li>
      <li class="" style="">The Receiving Server informs the Originating Server whether its identify has been verified or not.</li>
    </ol>
    <p class="" style="">We can represent this flow of events graphically as follows.</p>
    <p class="caption"></p><div class="indent"><pre>
Originating               Receiving
  Server                    Server
-----------               ---------
    |                         |
    |   perform DNS lookup,   |
    |   open TCP connection,  |
    |   and establish stream  |
    | ----------------------&gt; |
    |                         |                   Authoritative
    |   send dialback key     |                       Server
    | ----------------------&gt; |                   -------------
    |                         |                         |
    |                         |   perform DNS lookup,   |
    |                         |   open TCP connection,  |
    |                         |   and establish stream  |
    |                         | ----------------------&gt; |
    |                         |                         |
    |                         |   send verify request   |
    |                         | ----------------------&gt; |
    |                         |                         |
    |                         |   send verify response  |
    |                         | &lt;---------------------- |
    |                         |
    |  report dialback result |
    | &lt;---------------------- |
    |                         |
    </pre></div>
    <p class="" style="">Note: In Steps 1 and 3, it is not always necessary to open a new TCP connection and establish a new stream; for details, see the section on <a href="#piggybacking">Reuse of Negotiated Connections (Piggybacking)</a>.</p>
  </div>

<h2>2.
       <a name="protocol" id="protocol">Protocol</a></h2>

  <p class="" style="">This section describes the detailed protocol interaction between the Originating Server, the Receiving Server, and the Authoritative Server.</p>
  <p class="" style="">The examples in this section use the following domain names, IP addresses, stream IDs, and shared secret:</p>
  <ul class="" style="">
    <li class="" style="">The Originating Server is "example.org" (there is no IP address associated with this domain since it is merely asserted by the Originating Server).</li>
    <li class="" style="">The Receiving Server is "xmpp.example.com" and the discovered IP address for the XMPP service at that domain is "192.0.2.1" or "192.0.2.2" (see below).</li>
    <li class="" style="">The Authoritative Server is "example.org" and the discovered IP address for the XMPP service at that domain is "192.0.2.23".</li>
    <li class="" style="">The stream ID of the stream from the Originating Server to the Receiving Server is "D60000229F".</li>
    <li class="" style="">The shared secret known by the Authoritative Server's network is "s3cr3tf0rd14lb4ck".</li>
  </ul>
  <p class="" style="">To assist the reader, the following conventions are used to clarify the flow of packets:</p>
  <ul class="" style="">
    <li class="" style="">"O2R:" -- packets sent from the Originating Server to the Receiving Server.</li>
    <li class="" style="">"R2O:" -- packets sent from the Receiving Server to the Originating Server.</li>
    <li class="" style="">"R2A:" -- packets sent from the Receiving Server to the Authoritative Server.</li>
    <li class="" style="">"A2R:" -- packets sent from the Authoritative Server to the Receiving Server.</li>
  </ul>
  <p class="" style="">Note: Any error that occurs during dialback negotiation MUST be considered a stream error, resulting in termination of the stream and potentially of the underlying TCP connection. The possible error conditions are specified in the protocol description below.</p>
  <p class="" style="">The flow of events is as follows.</p>

  <div class="indent"><h3>2.1 <a name="o2r" id="o2r">Stream Setup Between Originating Server and Receiving Server</a></h3>

    <div class="indent"><h3>2.1.1 <a name="o2r-resolve" id="o2r-resolve">Originating Server Resolves Receiving Server</a></h3>
      <p class="" style="">Before opening a TCP connection to the Receiving Server, the Originating Server must first determine the appropriate IP address and port at which to connect. This is done by resolving the Receiving Server's hostname ("xmpp.example.com") using the Domain Name System. As described in <span class="ref">XMPP Core</span>, the Originating Server shall first attempt to resolve a TCP service of _xmpp-server for that hostname using DNS SRV records. Here we assume that example.com has the following records in its DNS configuration:</p>
      <p class="caption"><a name="example-1" id="example-1"></a>Example 1. DNS SRV Record for Receiving Server</p><div class="indent"><pre>
_xmpp-server._tcp.xmpp.example.com. 86400 IN SRV 10 0 5269 x1.example.com
_xmpp-server._tcp.xmpp.example.com. 86400 IN SRV 20 0 9625 x2.example.com
      </pre></div>
      <p class="" style="">These records show that server-to-server connections for the XMPP service "xmpp.example.com" are serviced by two machines: x1.example.com at port 5269 and x2.example.com at port 9625.</p>
      <p class="" style="">The Originating Server would then choose one of these machines to resolve further. Here we assume that the Originating Server chooses x2.example.com and that a standard A lookup for x2.example.com yields an IP address of "192.0.2.2".</p>
      <p class="" style="">Note: As described in <span class="ref">XMPP Core</span>, if the Receiving Server does not provide appropriate DNS SRV records then in order to resolve the hostname of the Receiving Server the Originating Server may fall back to normal IPv4/IPv6 address record resolution to determine the IP address and assume a port of 5269 as registered with the IANA.</p>
    </div>

    <div class="indent"><h3>2.1.2 <a name="o2r-connect" id="o2r-connect">Originating Server Opens TCP Connection</a></h3>
      <p class="" style="">Once the Originating Server has resolved "xmpp.example.com" to an IP address of 192.0.2.2 and port of 9625, it opens a TCP connection to that IP and port.</p>
      <p class="" style="">Note: Instead of opening a new TCP connection to the Receiving Server, the Originating Server MAY reuse an existing TCP connnection; for details, see the <a href="piggybacking">Reuse of Negotiated Connections (Piggybacking)</a> section of this document.</p>
    </div>

    <div class="indent"><h3>2.1.3 <a name="o2r-sendinitial" id="o2r-sendinitial">Originating Server Sends Initial Stream Header</a></h3>
      <p class="" style="">Once the Originating Server has opened a TCP connection to the resolved IP address and port of the Receiving Server, it sends an initial stream header to the Receiving Server as described in <span class="ref">XMPP Core</span>.</p>
      <p class="caption"><a name="example-2" id="example-2"></a>Example 2. Initial Stream Header</p><div class="indent"><pre>
O2R: &lt;stream:stream
          xmlns='jabber:server'
          xmlns:db='jabber:server:dialback'
          xmlns:stream='http://etherx.jabber.org/streams'
          from='example.org'
          to='xmpp.example.com'
          version='1.0'&gt;
      </pre></div>
      <p class="" style="">In addition to the core XMPP rules regarding initial stream headers, the following dialback-related rules apply to the initial stream header:</p>
      <ol start="1" class="" style="">
        <li class="" style="">It MUST include a declaration for the Server Dialback namespace.</li>
        <li class="" style="">The Server Dialback namespace MUST be 'jabber:server:dialback'.</li>
        <li class="" style="">The prefix for the Server Dialback namespace SHOULD be 'db:'.</li>
      </ol>
      <p class="" style="">Until the initial stream has been validated, the Originating Server MUST NOT send any further XML data to the Receiving Server over that stream.</p>
    </div>

    <div class="indent"><h3>2.1.4 <a name="o2r-processinitial" id="o2r-processinitial">Receiving Server Processes Initial Stream Header</a></h3>
      <p class="" style="">When the Receiving Server receives the initial stream header from the Originating Server, it MUST proceed as follows.</p>
      <div class="indent"><h3>2.1.4.1 <a name="o2r-processinitial-success" id="o2r-processinitial-success">Success Case</a></h3>
        <p class="" style="">If the Receiving Server can successfully process the initial stream header, it MUST return a response stream header to the Originating Server over the same TCP connection.</p>
        <p class="caption"><a name="example-3" id="example-3"></a>Example 3. Response Stream Header</p><div class="indent"><pre>
R2O: &lt;stream:stream
         xmlns='jabber:server'
         xmlns:db='jabber:server:dialback'
         xmlns:stream='http://etherx.jabber.org/streams'
         from='xmpp.example.com'
         id='D60000229F'
         to='example.org'
         version='1.0'&gt;
        </pre></div>
        <p class="" style="">In addition to the core XMPP rules regarding response stream headers, the following dialback-related rules apply to the response stream header:</p>
        <ol start="1" class="" style="">
          <li class="" style="">If the initial stream header included a Server Dialback namespace declaration and the Receiving Server supports the Server Dialback protocol, the response stream header also MUST include a declaration for the Server Dialback namespace.</li>
          <li class="" style="">If the initial stream header did not include a Server Dialback namespace declaration and the Receiving Server supports the Server Dialback protocol, the response stream header MAY include a Server Dialback namespace declaration.</li>
          <li class="" style="">If the response stream header includes a Server Dialback namespace declaration, the Server Dialback namespace MUST be 'jabber:server:dialback' and the prefix for the Server Dialback namespace SHOULD be 'db:'.</li>
        </ol>
        <p class="" style="">After sending the response stream header, the Receiving Server shall also send stream features to the Originating Server. The Receiving Server SHOULD include the dialback feature in its initial stream features advertisement, including an indication of whether Server Dialback negotiation is optional or required.</p>
        <p class="caption"><a name="example-4" id="example-4"></a>Example 4. Stream Features</p><div class="indent"><pre>
R2O: &lt;stream:features&gt;
       &lt;dialback xmlns='urn:xmpp:features:dialback'&gt;
         &lt;required/&gt;
       &lt;/dialback&gt;
     &lt;/stream:features&gt;
        </pre></div>
        <p class="" style="">Note: If the Receiving Server receives any XML stanzas from the Originating Server before the initial stream has been validated, the Receiving Server MUST silently drop those stanzas.</p>
      </div>
      <div class="indent"><h3>2.1.4.2 <a name="o2r-processinitial-error" id="o2r-processinitial-error">Error Cases</a></h3>
        <p class="" style="">There are several reasons why processing of the initial stream header might fail:</p>
        <ol start="1" class="" style="">
          <li class="" style="">The Server Dialback namespace name provided by the Originating Server is incorrect.</li>
          <li class="" style="">The Server Dialback namespace prefix provided by the Originating Server is not supported by the Receiving Server (note: an implementation MAY accept only the 'db:' namespace prefix).</li>
          <li class="" style="">The value of the 'to' address provided by the Originating Server does not match a hostname serviced by the Receiving Server.</li>
          <li class="" style="">The Receiving Server does not accept communication with the hostname of the 'from' address provided by the Originating Server.</li>
        </ol>
        <p class="" style="">These error cases are described more fully in the rest of this section.</p>
        <p class="" style="">If the Server Dialback namespace name is incorrect, then the Receiving Server SHOULD generate an &lt;invalid-namespace/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-5" id="example-5"></a>Example 5. Invalid Namespace</p><div class="indent"><pre>
R2O: &lt;stream:error&gt;
       &lt;invalid-namespace
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2O: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the Server Dialback namespace prefix is not supported by the Receiving Server, then the Receiving Server SHOULD generate a &lt;bad-namespace-prefix/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-6" id="example-6"></a>Example 6. Bad Namespace Prefix</p><div class="indent"><pre>
R2O: &lt;stream:error&gt;
       &lt;bad-namespace-prefix
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2O: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the value of the 'to' address provided by the Originating Server does not match a hostname serviced by the Receiving Server, then the Receiving Server SHOULD generate a &lt;host-unknown/&gt; or &lt;host-gone/&gt; stream error condition (as appropriate) and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-7" id="example-7"></a>Example 7. Host Unknown</p><div class="indent"><pre>
R2O: &lt;stream:error&gt;
       &lt;host-unknown
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2O: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the Receiving Server does not allow communication with the hostname of the 'from' address provided by the Originating Server, then the Receiving Server SHOULD generate a &lt;not-authorized/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-8" id="example-8"></a>Example 8. Not Authorized</p><div class="indent"><pre>
R2O: &lt;stream:error&gt;
       &lt;not-authorized
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2O: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">Note: The foregoing error flows specify that the Receiving Server SHOULD return a stream error. However, depending on local security policies, the Receiving Server MAY silently terminate the XML stream and underlying TCP connection instead of returning a stream error (e.g., to prevent certain denial of service attacks).</p>
      </div>
    </div>

    <div class="indent"><h3>2.1.5 <a name="o2r-processresponse" id="o2r-processresponse">Originating Server Processes Response Stream Header</a></h3>

      <p class="" style="">When the Originating Server receives the response stream header from the Receiving Server, it MUST proceed as follows.</p>

      <div class="indent"><h3>2.1.5.1 <a name="o2r-processresponse-success" id="o2r-processresponse-success">Success Case</a></h3>
        <p class="" style="">If the response stream header can be successfully processed, the Originating Server MUST generate and send a dialback key as described under <a href="key">Generation and Exchange of Dialback Key</a>.</p>
      </div>

      <div class="indent"><h3>2.1.5.2 <a name="o2r-response-error" id="o2r-response-error">Error Cases</a></h3>
        <p class="" style="">There are several reasons why processing of the response stream header and stream features might fail:</p>
        <ol start="1" class="" style="">
          <li class="" style="">The Server Dialback namespace name provided by the Receiving Server is incorrect.</li>
          <li class="" style="">The Server Dialback namespace prefix provided by the Receiving Server is not supported by the Originating Server (note: an implementation MAY accept only the 'db:' namespace prefix).</li>
          <li class="" style="">The value of the 'to' address provided by the Receiving Server does not match a hostname serviced by the Originating Server.</li>
          <li class="" style="">The Originating Server does not accept communication with the hostname of the 'from' address provided by the Receiving Server.</li>
          <li class="" style="">The Receiving Server does not advertise support for Server Dialback via a Server Dialback namespace declaration or stream feature.</li>
        </ol>
        <p class="" style="">These error cases are described more fully in the rest of this section.</p>
        <p class="" style="">If the Server Dialback namespace name is incorrect, then the Originating Server SHOULD generate an &lt;invalid-namespace/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-9" id="example-9"></a>Example 9. Invalid Namespace</p><div class="indent"><pre>
O2R: &lt;stream:error&gt;
       &lt;invalid-namespace
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

O2R: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the Server Dialback namespace prefix is not supported by the Originating Server, then the Originating Server SHOULD generate a &lt;bad-namespace-prefix/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-10" id="example-10"></a>Example 10. Bad Namespace Prefix</p><div class="indent"><pre>
O2R: &lt;stream:error&gt;
       &lt;bad-namespace-prefix
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

O2R: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the value of the 'to' address provided by the Receiving Server does not match a hostname serviced by the Originating Server, then the Originating Server SHOULD generate a &lt;host-unknown/&gt; or &lt;host-gone/&gt; stream error condition (as appropriate) and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-11" id="example-11"></a>Example 11. Host Unknown</p><div class="indent"><pre>
O2R: &lt;stream:error&gt;
       &lt;host-unknown
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

O2R: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the Originating Server does not allow communication with the hostname of the 'from' address provided by the Receiving Server, then the Originating Server SHOULD generate a &lt;not-authorized/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-12" id="example-12"></a>Example 12. Not Authorized</p><div class="indent"><pre>
O2R: &lt;stream:error&gt;
       &lt;not-authorized
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

O2R: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">Note: The foregoing error flows specify that the Originating Server SHOULD return a stream error. However, depending on local security policies, the Originating Server MAY silently terminate the XML stream and underlying TCP connection instead of returning a stream error (e.g., to prevent certain denial of service attacks).</p>
        <p class="" style="">If the Receiving Server does not advertise support for Server Dialback via a Server Dialback namespace declaration or stream feature, then the Originating Server's attempt to negotiate Server Dialback fails and the Originating Server SHOULD return a &lt;remote-server-timeout/&gt; stanza error to the local entity that generated the stanza that triggered the Server Dialback attempt in the first place (if any).</p>
      </div>

    </div>

  </div>

  <div class="indent"><h3>2.2 <a name="key" id="key">Generation and Exchange of Dialback Key</a></h3>

    <div class="indent"><h3>2.2.1 <a name="key-gen" id="key-gen">Originating Server Generates Dialback Key</a></h3>
      <p class="" style="">Once the Originating Server has established an XML stream with the Receiving Server, it MUST generate a dialback key for verification by the Authoritative Server.</p>
      <p class="" style="">The method for generating (and verifying) the keys used in Server Dialback MUST take into account the following pieces of information:</p>
      <ul class="" style="">
        <li class="" style="">the hostname of the Originating Server</li>
        <li class="" style="">the hostname of the Receiving Server</li>
        <li class="" style="">the Stream ID</li>
        <li class="" style="">a shared secret known by the Authoritative Server's network</li>
      </ul>
      <p class="" style="">The stream ID is security-critical in Server Dialback and therefore MUST be both unpredictable and non-repeating (see <span class="ref" style=""><a href="http://tools.ietf.org/html/rfc4086">RFC 4086</a></span>  [<a href="#nt-id2262983">8</a>] for recommendations regarding randomness for security purposes).</p>
      <p class="" style="">It is RECOMMENDED for the dialback key to be the hexadecimal representation of a Keyed-Hash Message Authentication Code (see <span class="ref" style=""><a href="http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf">HMAC</a></span>  [<a href="#nt-id2263011">9</a>]) generated using the SHA256 hashing algorithm (see <span class="ref" style=""><a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">SHA</a></span>  [<a href="#nt-id2263055">10</a>]), as follows.</p>
      <p class="caption"><a name="example-13" id="example-13"></a>Example 13. HMAC</p><div class="indent"><pre>
HMAC-SHA256
( 
  SHA256(secret), 
  {Receiving Server, ' ', Originating Server, ' ', Stream ID} 
)
      </pre></div>
      <p class="" style="">The shared secret SHOULD either be set up in a configuration option for each host or process within the Authoritative Server's network or generated as a random string when starting each host or process. The secret's length SHOULD be at least 128 bits or 16 characters long.</p>
      <p class="" style="">Consider the following scenario:</p>
      <ul class="" style="">
        <li class="" style="">The Originating Server is "example.org"</li>
        <li class="" style="">The Receiving Server is "xmpp.example.com"</li>
        <li class="" style="">The Stream ID is "D60000229F"</li>
        <li class="" style="">The secret is "s3cr3tf0rd14lb4ck"</li>
      </ul>
      <p class="" style="">The resulting dialback key would be:</p>
      <p class="caption"><a name="example-14" id="example-14"></a>Example 14. A Key</p><div class="indent"><pre>
HMAC-SHA256
( 
  SHA256(secret), 
  {Receiving Server, ' ', Originating Server, ' ', Stream ID} 
)

that is,

HMAC-SHA256
(SHA256('s3cr3tf0rd14lb4ck'),
{'xmpp.example.net',' ','example.org',' ','D60000229F'})

that is,

HMAC-SHA256
('a7136eb1f46c9ef18c5e78c36ca257067c69b3d518285f0b18a96c33beae9acc',
{'xmpp.example.com chat.example.org D60000229F'})

that is,

37c69b1cf07a3f67c04a5ef5902fa5114f2c76fe4a2686482ba5b89323075643
      </pre></div>
    </div>

    <div class="indent"><h3>2.2.2 <a name="key-send" id="key-send">Originating Server Sends Dialback Key</a></h3>
      <p class="" style="">Once the Originating Server has processed the response stream header from the Receiving Server and has generated a dialback key for verification by the Receiving Server, it MUST then send that key to the Receiving Server. This is done by creating a &lt;db:result/&gt; element whose XML character data is the dialback key; the element MUST possess a 'from' attribute whose value is the hostname of the Originating Server and MUST possess a 'to' attribute whose value is the hostname of the Receiving Server.</p>
      <p class="" style="">Note: All XML elements qualified by the Server Dialback namespace MUST be prefixed with the namespace prefix advertised on the stream header originally sent by the entity sending the element.</p>
      <p class="caption"><a name="example-15" id="example-15"></a>Example 15. Originating Server Sends Dialback Key</p><div class="indent"><pre>
O2R: &lt;db:result
         from='example.org'
         to='xmpp.example.com'&gt;
       37c69b1cf07a3f67c04a5ef5902fa5114f2c76fe4a2686482ba5b89323075643
     &lt;/db:result&gt;
      </pre></div>
    </div>

    <div class="indent"><h3>2.2.3 <a name="key-process" id="key-process">Receiving Server Processes Dialback Key</a></h3>
      <p class="" style="">When the Receiving Server receives the dialback key, it MUST proceed as follows.</p>
      <p class="" style="">If the Server Dialback namespace prefix is not supported by the Originating Server, then the Originating Server SHOULD generate a &lt;bad-namespace-prefix/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
      <p class="caption"><a name="example-16" id="example-16"></a>Example 16. Bad Namespace Prefix</p><div class="indent"><pre>
O2R: &lt;stream:error&gt;
       &lt;bad-namespace-prefix
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

O2R: &lt;/stream:stream&gt;
      </pre></div>
      <p class="" style="">If the value of the 'to' address provided by the Originating Server does not match a hostname serviced by the Receiving Server, then the Receiving Server SHOULD generate a &lt;host-unknown/&gt; or &lt;host-gone/&gt; stream error condition (as appropriate) and terminate both the XML stream and the underlying TCP connection.</p>
      <p class="caption"><a name="example-17" id="example-17"></a>Example 17. Host Unknown</p><div class="indent"><pre>
O2R: &lt;stream:error&gt;
       &lt;host-unknown
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

O2R: &lt;/stream:stream&gt;
      </pre></div>
      <p class="" style="">If the Originating Server does not allow communication with the hostname of the 'from' address provided by the Receiving Server, then the Originating Server SHOULD generate a &lt;not-authorized/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
      <p class="caption"><a name="example-18" id="example-18"></a>Example 18. Not Authorized</p><div class="indent"><pre>
O2R: &lt;stream:error&gt;
       &lt;not-authorized
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

O2R: &lt;/stream:stream&gt;
      </pre></div>
      <p class="" style="">Otherwise, the Receiving Server MUST attempt to open a connection to the Authoritative Server and then ask the Authoritative Server to validate the key provided by the Originating Server, as described in the following sections.</p>
      <p class="" style="">Note: The dialback key is not examined by the Receiving Server, since the key is validated by the Authoritative Server.</p>
    </div>

  </div>

  <div class="indent"><h3>2.3 <a name="r2a" id="r2a">Stream Setup Between Receiving Server and Authoritative Server</a></h3>

    <div class="indent"><h3>2.3.1 <a name="r2a-resolve" id="r2a-resolve">Receiving Server Resolves Authoritative Server</a></h3>
      <p class="" style="">Before opening a TCP connection to the Authoritative Server, the Receiving Server must first determine the appropriate IP address and port at which to connect. This is done by resolving the Authoritative Server's hostname ("example.org") using the Domain Name System. As described in <span class="ref">XMPP Core</span>, the Receiving Server shall first attempt to resolve a TCP service of _xmpp-server for that hostname using DNS SRV records. Here we assume that example.org has the following records in its DNS configuration:</p>
      <p class="caption"><a name="example-19" id="example-19"></a>Example 19. DNS SRV Record for Authoritative Server</p><div class="indent"><pre>
_xmpp-server._tcp.example.org. 86400 IN SRV 10 0 5269 foo.example.org
      </pre></div>
      <p class="" style="">These records show that server-to-server connections for the XMPP service "example.org" are serviced by the physical machine foo.example.org at port 5269.</p>
      <p class="" style="">The Receiving Server would then resolve that machine to an IP address, in this case "192.0.2.23".</p>
      <p class="" style="">Note: As described in <span class="ref">XMPP Core</span>, if the Authoritative Server does not provide appropriate DNS SRV records then in order to resolve the hostname of the Authoritative Server the Receiving Server may fall back to normal IPv4/IPv6 address record resolution to determine the IP address and assume a port of 5269 as registered with the IANA.</p>
    </div>

    <div class="indent"><h3>2.3.2 <a name="r2a-connect" id="r2a-connect">Receiving Server Opens TCP Connection</a></h3>
      <p class="" style="">Once the Receiving Server has resolved "example.org" to an IP address of 192.0.2.23 and port of 5269, it opens a TCP connection to that IP and port.</p>
      <p class="" style="">Note: Instead of opening a new TCP connection to the Authoritative Server, the Receiving Server MAY reuse an existing TCP connnection; for details, see the <a href="piggybacking">Reuse of Negotiated Connections (Piggybacking)</a> section of this document.</p>
    </div>

    <div class="indent"><h3>2.3.3 <a name="r2a-sendinitial" id="r2a-sendinitial">Receiving Server Sends Initial Stream Header</a></h3>
      <p class="" style="">Once the Receiving Server has opened a TCP connection to the resolved IP address and port of the Authoritative Server, it sends an initial stream header to the Authoritative Server as described in <span class="ref">XMPP Core</span>.</p>
      <p class="caption"><a name="example-20" id="example-20"></a>Example 20. Initial Stream Header</p><div class="indent"><pre>
R2A: &lt;stream:stream
          xmlns='jabber:server'
          xmlns:db='jabber:server:dialback'
          xmlns:stream='http://etherx.jabber.org/streams'
          from='xmpp.example.com'
          to='example.org'
          version='1.0'&gt;
      </pre></div>
      <p class="" style="">In addition to the core XMPP rules regarding initial stream headers, the following dialback-related rules apply to the initial stream header:</p>
      <ol start="1" class="" style="">
        <li class="" style="">It MUST include a declaration for the Server Dialback namespace.</li>
        <li class="" style="">The Server Dialback namespace MUST be 'jabber:server:dialback'.</li>
        <li class="" style="">The prefix for the Server Dialback namespace SHOULD be 'db:'.</li>
      </ol>
      <p class="" style="">Note: An implementation MAY accept only the 'db:' namespace prefix.</p>
    </div>

    <div class="indent"><h3>2.3.4 <a name="r2a-processinitial" id="r2a-processinitial">Authoritative Server Processes Initial Stream Header</a></h3>
      <p class="" style="">When the Authoritative Server receives the initial stream header from the Receiving Server, it MUST proceed as follows.</p>
      <div class="indent"><h3>2.3.4.1 <a name="r2a-processinitial-success" id="r2a-processinitial-success">Success Case</a></h3>
        <p class="" style="">If the Authoritative Server can successfully process the initial stream header, it MUST return a response stream header to the Receiving Server over the same TCP connection.</p>
        <p class="caption"><a name="example-21" id="example-21"></a>Example 21. Response Stream Header</p><div class="indent"><pre>
A2R: &lt;stream:stream
         xmlns='jabber:server'
         xmlns:db='jabber:server:dialback'
         xmlns:stream='http://etherx.jabber.org/streams'
         from='example.org'
         id='D60000229F'
         to='xmpp.example.com'
         version='1.0'&gt;
        </pre></div>
        <p class="" style="">In addition to the core XMPP rules regarding response stream headers, the following dialback-related rules apply to the response stream header:</p>
        <ol start="1" class="" style="">
          <li class="" style="">If the initial stream header included a Server Dialback namespace declaration and the Authoritative Server supports the Server Dialback protocol, the response stream header also MUST include a declaration for the Server Dialback namespace.</li>
          <li class="" style="">If the initial stream header did not include a Server Dialback namespace declaration and the Authoritative Server supports the Server Dialback protocol, the response stream header MAY include a Server Dialback namespace declaration.</li>
          <li class="" style="">If the response stream header includes a Server Dialback namespace declaration, the Server Dialback namespace MUST be 'jabber:server:dialback' and the prefix for the Server Dialback namespace SHOULD be 'db:'.</li>
        </ol>
        <p class="" style="">After sending the response stream header, the Authoritative Server shall also send stream features to the Receiving Server. The Authoritative Server SHOULD include the dialback feature in its initial stream features advertisement, including an indication of whether Server Dialback negotiation is optional or required.</p>
        <p class="caption"><a name="example-22" id="example-22"></a>Example 22. Stream Features</p><div class="indent"><pre>
A2R: &lt;stream:features&gt;
       &lt;dialback xmlns='urn:xmpp:features:dialback'&gt;
         &lt;optional/&gt;
       &lt;/dialback&gt;
     &lt;/stream:features&gt;
        </pre></div>
      </div>
      <div class="indent"><h3>2.3.4.2 <a name="r2a-processinitial-error" id="r2a-processinitial-error">Error Cases</a></h3>
        <p class="" style="">There are several reasons why processing of the initial stream header might fail:</p>
        <ol start="1" class="" style="">
          <li class="" style="">The Server Dialback namespace name provided by the Receiving Server is incorrect.</li>
          <li class="" style="">The Server Dialback namespace prefix provided by the Receiving Server is not supported by the Authoritative Server (note: an implementation MAY accept only the 'db:' namespace prefix).</li>
          <li class="" style="">The value of the 'to' address provided by the Receiving Server does not match a hostname serviced by the Authoritative Server.</li>
          <li class="" style="">The Authoritative Server does not accept communication with the hostname of the 'from' address provided by the Receiving Server.</li>
        </ol>
        <p class="" style="">These error cases are described more fully in the remainder of this section.</p>
        <p class="" style="">If the Server Dialback namespace name is incorrect, then the Authoritative Server SHOULD generate an &lt;invalid-namespace/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-23" id="example-23"></a>Example 23. Invalid Namespace</p><div class="indent"><pre>
A2R: &lt;stream:error&gt;
       &lt;invalid-namespace
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

A2R: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the Server Dialback namespace prefix is not supported by the Authoritative Server, then the Authoritative Server SHOULD generate a &lt;bad-namespace-prefix/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-24" id="example-24"></a>Example 24. Bad Namespace Prefix</p><div class="indent"><pre>
A2R: &lt;stream:error&gt;
       &lt;bad-namespace-prefix
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

A2R: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the value of the 'to' address provided by the Receiving Server does not match a hostname serviced by the Authoritative Server, then the Authoritative Server SHOULD generate a &lt;host-unknown/&gt; or &lt;host-gone/&gt; stream error condition (as appropriate) and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-25" id="example-25"></a>Example 25. Host Unknown</p><div class="indent"><pre>
A2R: &lt;stream:error&gt;
       &lt;host-unknown
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

A2R: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the Authoritative Server does not allow communication with the hostname of the 'from' address provided by the Receiving Server, then the Authoritative Server SHOULD generate a &lt;not-authorized/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-26" id="example-26"></a>Example 26. Not Authorized</p><div class="indent"><pre>
A2R: &lt;stream:error&gt;
       &lt;not-authorized
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

A2R: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">Note: The foregoing error flows specify that the Authoritative Server SHOULD return a stream error. However, depending on local security policies, the Authoritative Server MAY silently terminate the XML stream and underlying TCP connection instead of returning a stream error (e.g., to prevent certain denial of service attacks).</p>
      </div>
    </div>

    <div class="indent"><h3>2.3.5 <a name="r2a-processresponse" id="r2a-processresponse">Receiving Server Processes Response Stream Header</a></h3>

      <p class="" style="">When the Receiving Server receives the response stream header from the Authoritative Server, it MUST proceed as follows.</p>

      <div class="indent"><h3>2.3.5.1 <a name="r2a-processresponse-success" id="r2a-processresponse-success">Success Case</a></h3>
        <p class="" style="">If the response stream header can be successfully processed, the Receiving Server MUST send the dialback key it received from the Originating Server as described under <a href="verify">Exchange of Verification Request between Receiving Server and Authoritative Server</a>.</p>
      </div>

      <div class="indent"><h3>2.3.5.2 <a name="r2a-response-error" id="r2a-response-error">Error Cases</a></h3>
        <p class="" style="">There are several reasons why processing of the response stream header and stream features might fail:</p>
        <ol start="1" class="" style="">
          <li class="" style="">The Server Dialback namespace name provided by the Authoritative Server is incorrect.</li>
          <li class="" style="">The Server Dialback namespace prefix provided by the Authoritative Server is not supported by the Receiving Server (note: an implementation MAY accept only the 'db:' namespace prefix).</li>
          <li class="" style="">The value of the 'to' address provided by the Authoritative Server does not match a hostname serviced by the Receiving Server.</li>
          <li class="" style="">The Receiving Server does not accept communication with the hostname of the 'from' address provided by the Authoritative Server.</li>
          <li class="" style="">The Authoritative Server does not advertise support for Server Dialback via a Server Dialback namespace declaration or stream feature.</li>
        </ol>
        <p class="" style="">These error cases are described more fully in the remainder of this section.</p>
        <p class="" style="">If the Server Dialback namespace name is incorrect, then the Receiving Server SHOULD generate an &lt;invalid-namespace/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-27" id="example-27"></a>Example 27. Invalid Namespace</p><div class="indent"><pre>
R2A: &lt;stream:error&gt;
       &lt;invalid-namespace
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2A: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the Server Dialback namespace prefix is not supported by the Receiving Server, then the Receiving Server SHOULD generate a &lt;bad-namespace-prefix/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-28" id="example-28"></a>Example 28. Bad Namespace Prefix</p><div class="indent"><pre>
R2A: &lt;stream:error&gt;
       &lt;bad-namespace-prefix
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2A: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the value of the 'to' address provided by the Authoritative Server does not match a hostname serviced by the Receiving Server, then the Receiving Server SHOULD generate a &lt;host-unknown/&gt; or &lt;host-gone/&gt; stream error condition (as appropriate) and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-29" id="example-29"></a>Example 29. Host Unknown</p><div class="indent"><pre>
R2A: &lt;stream:error&gt;
       &lt;host-unknown
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2A: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the Receiving Server does not allow communication with the hostname of the 'from' address provided by the Authoritative Server, then the Receiving Server SHOULD generate a &lt;not-authorized/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-30" id="example-30"></a>Example 30. Not Authorized</p><div class="indent"><pre>
R2A: &lt;stream:error&gt;
       &lt;not-authorized
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2A: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">Note: The foregoing error flows specify that the Receiving Server SHOULD return a stream error. However, depending on local security policies, the Receiving Server MAY silently terminate the XML stream and underlying TCP connection instead of returning a stream error (e.g., to prevent certain denial of service attacks).</p>
        <p class="" style="">If the Authoritative Server does not advertise support for Server Dialback via a Server Dialback namespace declaration or stream feature, then the Receiving Server's attempt to request verification of the Originating Server's dialback key fails and the Receiving Server MUST return a &lt;remote-connection-failed/&gt; stream error to the Originating Server.</p>
      </div>

    </div>

  </div>

  <div class="indent"><h3>2.4 <a name="verify" id="verify">Exchange of Verification Request</a></h3>
    <div class="indent"><h3>2.4.1 <a name="verify-send" id="verify-send">Receiving Server Sends Verification Request</a></h3>
      <p class="" style="">Once the Receiving Server has established an XML stream with the Authoritative Server, it MUST send to the Authoritative Server the dialback key it received from the Originating Server. This is done by creating a &lt;db:verify/&gt; element whose XML character data is the dialback key; the element MUST possess a 'from' attribute whose value is the hostname of the Receiving Server, MUST possess a 'to' attribute whose value is the hostname of the Originating Server, and MUST possess an 'id' attribute whose value is the stream identifier from the Receiving Server's response stream header to the Originating Server.</p>
      <p class="" style="">Note: All XML elements qualified by the Server Dialback namespace MUST be prefixed with the namespace prefix advertised on the stream header originally sent by the entity sending the element.</p>
      <p class="caption"><a name="example-31" id="example-31"></a>Example 31. Receiving Server Sends Verification Request</p><div class="indent"><pre>
R2A: &lt;db:verify
         from='xmpp.example.com'
         id='D60000229F'
         to='example.org'&gt;
       37c69b1cf07a3f67c04a5ef5902fa5114f2c76fe4a2686482ba5b89323075643
     &lt;/db:verify&gt;
      </pre></div>
    </div>

    <div class="indent"><h3>2.4.2 <a name="verify-process" id="verify-process">Authoritative Server Processes Verification Request</a></h3>

      <div class="indent"><h3>2.4.2.1 <a name="verify-process-success" id="verify-process-success">Success Case</a></h3>
        <p class="" style="">If the verification request can be successfully processed, the Authoritative Server MUST validate the dialback key it received from the Receiving Server as described under <a href="validate">Validation of Dialback Key by Authoritative Server</a>.</p>
      </div>

      <div class="indent"><h3>2.4.2.2 <a name="verify-process-error" id="verify-process-error">Error Cases</a></h3>
        <p class="" style="">There are several reasons why processing of the verification request might fail:</p>
        <ol start="1" class="" style="">
          <li class="" style="">The value of the 'to' address provided by the Receiving Server does not match a hostname serviced by the Authoritative Server's network.</li>
          <li class="" style="">The value of the 'from' address provided by the Receiving Server does not match the hostname sent by the Receiving Server in the 'from' address of the initial stream header it sent to the Authoritative Server.</li>
        </ol>
        <p class="" style="">These error cases are described more fully in the remainder of this section.</p>
        <p class="" style="">If the value of the 'to' address provided by the Receiving Server does not match a hostname serviced by the Authoritative Server's network, then the Authoritative Server MUST generate a &lt;host-unknown/&gt; or &lt;host-gone/&gt; stream error condition (as appropriate) and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-32" id="example-32"></a>Example 32. Host Unknown</p><div class="indent"><pre>
R2A: &lt;stream:error&gt;
       &lt;host-unknown
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2A: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the value of the 'from' address provided by the Receiving Server does not match the hostname sent by the Receiving Server in the 'from' address of the initial stream header it sent to the Authoritative Server, then the Authoritative Server MUST generate an &lt;invalid-from/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-33" id="example-33"></a>Example 33. Invalid From</p><div class="indent"><pre>
R2A: &lt;stream:error&gt;
       &lt;invalid-from
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2A: &lt;/stream:stream&gt;
        </pre></div>
      </div>

    </div>

  </div>

  <div class="indent"><h3>2.5 <a name="validate" id="validate">Validation of Dialback Key and Exchange of Validation Result</a></h3>

    <div class="indent"><h3>2.5.1 <a name="validate-determine" id="validate-determine">Authoritative Server Determines Validity of Dialback Key</a></h3>
      <p class="" style="">If the Authoritative Server can successfully process the verification request, it MUST determine whether the key is valid or invalid.</p>
    <p class="" style="">The key shall be considered <span class="em">valid</span> if the Authoritative Server determines that the key matches the output it would have produced using its key generation algorithm with the inputs specified in the XML attributes of the verification request along with its shared secret.</p>
      <p class="" style="">The key shall be considered <span class="em">invalid</span> if the Authoritative Server determines that the key does not match the output it would have produced using its key generation algorithm with the inputs specified in the XML attributes of the verification request along with its shared secret.</p>
    </div>

    <div class="indent"><h3>2.5.2 <a name="validate-send" id="validate-send">Authoritative Server Sends Validation Result</a></h3>
      <p class="" style="">Once the Authoritative Server determines whether the key is valid or invalid, it MUST inform the Receiving Server of its determination. This is done by creating a &lt;db:verify/&gt; element whose XML character data is the dialback key; the element MUST possess a 'from' attribute whose value is the hostname of the Originating Server, MUST possess a 'to' attribute whose value is the hostname of the Receiving Server, MUST possess an 'id' attribute whose value is the stream identifier from the Receiving Server's response stream header to the Originating Server as communicated in the verification request, and MUST possess a 'type' attribute whose value is either "valid" or "invalid".</p>
      <p class="caption"><a name="example-34" id="example-34"></a>Example 34. Key is Valid</p><div class="indent"><pre>
A2R: &lt;db:verify
         from='example.org'
         id='D60000229F'
         to='xmpp.example.com'
         type='valid'&gt;
       37c69b1cf07a3f67c04a5ef5902fa5114f2c76fe4a2686482ba5b89323075643
     &lt;/db:verify&gt;
      </pre></div>
      <p class="" style="">Or:</p>
      <p class="caption"><a name="example-35" id="example-35"></a>Example 35. Key is Invalid</p><div class="indent"><pre>
A2R: &lt;db:verify
         from='example.org'
         id='D60000229F'
         to='xmpp.example.com'
         type='invalid'&gt;
       37c69b1cf07a3f67c04a5ef5902fa5114f2c76fe4a2686482ba5b89323075643
     &lt;/db:verify&gt;
      </pre></div>
    </div>

    <div class="indent"><h3>2.5.3 <a name="validate-process" id="validate-process">Receiving Server Processes Validation Result</a></h3>

      <div class="indent"><h3>2.5.3.1 <a name="validate-process-success" id="validate-process-success">Success Case</a></h3>
        <p class="" style="">If the validation result can be successfully processed, the Receiving Server MUST inform the Originating Server of the Server Dialback results described under <a href="result">Communication of Result from Receiving Server to Originating Server</a>. The Receiving Server then SHOULD also terminate the XML stream and the underlying TCP connection between the Receiving Server and the Authoritative Server.</p>
      </div>

      <div class="indent"><h3>2.5.3.2 <a name="validate-process-error" id="validate-process-error">Error Cases</a></h3>
        <p class="" style="">There are several reasons why processing of the validation result might fail:</p>
        <ol start="1" class="" style="">
          <li class="" style="">The value of the 'id' attribute does not match that provided by the Receiving Server in the verification request.</li>
          <li class="" style="">The value of the 'from' address does not match the hostname represented by the Originating Server in the 'from' address of the initial stream header it sent to the Receiving Server.</li>
          <li class="" style="">The value of the 'to' address does not match a hostname serviced by the Receiving Server.</li>
        </ol>
        <p class="" style="">These error cases are described more fully in the remainder of this section.</p>
        <p class="" style="">If the value of the 'id' attribute does not match that provided by the Receiving Server in the verification request, then the Receiving Server MUST generate an &lt;invalid-id/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection between it and the Authoritative Server.</p>
        <p class="caption"><a name="example-36" id="example-36"></a>Example 36. Invalid ID</p><div class="indent"><pre>
R2A: &lt;stream:error&gt;
       &lt;invalid-id
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2A: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">The value of the 'from' address does not match the hostname represented by the Originating Server in the 'from' address of the initial stream header it sent to the Receiving Server, then the Receiving Server MUST generate an &lt;invalid-from/&gt; stream error condition and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-37" id="example-37"></a>Example 37. Invalid From</p><div class="indent"><pre>
R2A: &lt;stream:error&gt;
       &lt;invalid-from
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2A: &lt;/stream:stream&gt;
        </pre></div>
        <p class="" style="">If the value of the 'to' address does not match a hostname serviced by the Receiving Server, then the Receiving Server MUST generate a &lt;host-unknown/&gt; or &lt;host-gone/&gt; stream error condition (as appropriate) and terminate both the XML stream and the underlying TCP connection.</p>
        <p class="caption"><a name="example-38" id="example-38"></a>Example 38. Host Unknown</p><div class="indent"><pre>
R2A: &lt;stream:error&gt;
       &lt;host-unknown
           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
     &lt;/stream:error&gt;

R2A: &lt;/stream:stream&gt;
        </pre></div>
      </div>

    </div>

  </div>

  <div class="indent"><h3>2.6 <a name="result" id="result">Communication and Handling of Verification Result</a></h3>

    <div class="indent"><h3>2.6.1 <a name="result-communicate" id="result-communicate">Receiving Server Communicates Verification Result</a></h3>
      <p class="" style="">Once the Receiving Server successfully processes the validation result it received from the Authoritative Server, it informs the Originating Server of the result. This is done by creating a &lt;db:result/&gt; element whose XML character data is the dialback key; the element MUST possess a 'from' attribute whose value is the hostname of the Receiving Server, MUST possess a 'to' attribute whose value is the hostname of the Originating Server, MUST possess an 'id' attribute whose value is the stream identifier from the Receiving Server's response stream header to the Originating Server, and MUST possess a 'type' attribute whose value is either "valid" or "invalid".</p>
      <p class="caption"><a name="example-39" id="example-39"></a>Example 39. Receiving Server Sends Verification Result</p><div class="indent"><pre>
R2O: &lt;db:result
         from='xmpp.example.com'
         to='example.org'
         type='valid'&gt;
       37c69b1cf07a3f67c04a5ef5902fa5114f2c76fe4a2686482ba5b89323075643
     &lt;/db:result&gt;
      </pre></div>
    </div>

    <div class="indent"><h3>2.6.2 <a name="result-handle" id="result-handle">Receiving Server Handles Verification Result</a></h3>

      <div class="indent"><h3>2.6.2.1 <a name="result-handle-invalid" id="result-handle-invalid">Invalid Connection</a></h3>
        <p class="" style="">If the Authoritative Server reported the dialback key as invalid, then the Receiving Server MUST terminate both the XML stream and the underlying TCP connection between itself and the Originating Server.</p>
      </div>

      <div class="indent"><h3>2.6.2.2 <a name="result-handle-valid" id="result-handle-valid">Valid Connection</a></h3>
        <p class="" style="">If the Authoritative Server reported the dialback key as valid, the Receiving Server has verified the identity of the Originating Server. As a result, the Receiving Server may now accept XML stanzas from the Originating Server over the validated connection (i.e., over the "initial stream" from the Originating Server to the Receiving Server). However, in accordance with <span class="ref">XMPP Core</span>, the Receiving Server MUST follow the rules specified therein regarding inclusion and checking of 'from' and 'to' attributes on all XML stanzas it receives from the Originating Server. These checks help to prevent address spoofing.</p>
        <p class="" style="">Note: If the Receiving Server receives any XML stanzas from the Originating Server before the initial stream has been validated, the Receiving Server MUST silently drop those stanzas.</p>
        <p class="" style="">As mentioned, Server Dialback results in weak identity verification in one direction only (in the foregoing text, verification of the Originating Server by the Receiving Server). In order to proceed with bi-directional communication so that the Receiving Server may send XML stanzas to the Originating Server, the Receiving Server MUST now also initiate a dialback negotiation with the Originating Server (i.e., assume the role of an originating server in a new dialback negotiation).</p>
      </div>

    </div>

  </div>

<h2>3.
       <a name="piggybacking" id="piggybacking">Reuse of Negotiated Connections (Piggybacking)</a></h2>
  <p class="" style="">After the Receiving Server has validated a connection from the Originating Server, the Originating Server may wish to reuse that connection for validation of additional domains. This feature is called PIGGYBACKING. Support for piggybacking is OPTIONAL.</p>
  <p class="" style="">One common motivation for such reuse is the existence of additional services associated with the Originating Server but hosted at subdomains of the Originating Server (the use of subdomains helps to ensure proper routing of XML stanzas to the hosted services). For example, the "example.org" XMPP server may host a groupchat service at "chat.example.org". In order to accept XML stanzas from rooms at "chat.example.org" intended for addresses at "xmpp.example.com", the "xmpp.example.com" domain will need to validate the "chat.example.org" domain (just as it already did for the "example.org" domain). Thus the "example.org" server would now initiate a dialback negotiation with "xmpp.example.com" but specify the Originating Server as "chat.example.org".</p>
  <p class="" style="">However, because the "example.org" server already has a validated connection open to the Receiving Server ("xmpp.example.com"), it MAY send a &lt;db:result/&gt; element with the key to be validated for the new Originating Server ("chat.example.org") over the XML stream that has already been negotiated, rather than opening a new TCP connection and XML stream.</p>
  <p class="caption"><a name="example-40" id="example-40"></a>Example 40. Piggybacked Key</p><div class="indent"><pre>
O2R: &lt;db:result
         from='chat.example.org'
         to='xmpp.example.com'&gt;
       88a96894060d5f4258c37cd51b772e5a483430d8203f71d3782cac72a0866458
     &lt;/db:result&gt;
  </pre></div>
  <p class="" style="">The Receiving Server SHOULD accept this &lt;db:result/&gt; element (as it did for the first &lt;db:result/&gt; element) and process it according to the rules already specified. If that process is successful, it would eventually result in sending of a &lt;db:result/&gt; element from the Receiving Server to the Originating Server.</p>
  <p class="caption"><a name="example-41" id="example-41"></a>Example 41. Piggybacked Result</p><div class="indent"><pre>
R2O: &lt;db:result
         from='xmpp.example.com'
         to='chat.example.org'
         type='valid'&gt;
       88a96894060d5f4258c37cd51b772e5a483430d8203f71d3782cac72a0866458
     &lt;/db:result&gt;
  </pre></div>
  <p class="" style="">However, if the Receiving Server does not allow reuse of the existing connection, it MUST return an error of the following form to the Originating Server.</p>
  <p class="caption"><a name="example-42" id="example-42"></a>Example 42. Piggybacking Not Supported</p><div class="indent"><pre>
R2O: &lt;db:result
         from='xmpp.example.com'
         to='chat.example.org'
         type='error'&gt;
       88a96894060d5f4258c37cd51b772e5a483430d8203f71d3782cac72a0866458
     &lt;/db:result&gt;
  </pre></div>
  <p class="" style="">Note: a &lt;db:result/&gt; element of type "error" MUST NOT be considered a stream error and therefore MUST NOT result in termination of the stream and the underlying TCP connection, which presumably is being used for sending XML stanzas from the Originating Server to the Receiving Server.</p>
<h2>4.
       <a name="security" id="security">Security Considerations</a></h2>
  <p class="" style="">Server Dialback helps protect against domain spoofing, thus making it more difficult to spoof XML stanzas. It is not a mechanism for authenticating, securing, or encrypting streams between servers as is done via SASL and TLS, and results in weak verification of server identities only. Furthermore, it is susceptible to DNS poisoning attacks unless DNSSEC (see <span class="ref" style=""><a href="http://tools.ietf.org/html/rfc4033">RFC 4033</a></span>  [<a href="#nt-id2265042">11</a>]) is used. Even if the DNS information is accurate, Server Dialback cannot protect against attacks where the attacker is capable of hijacking the IP address of the remote domain. Domains requiring robust security SHOULD use TLS and SASL. If SASL is used for server-to-server authentication, Server Dialback SHOULD NOT be used since it is unnecessary.</p>
<h2>5.
       <a name="iana" id="iana">IANA Considerations</a></h2>
  <p class="" style="">This document requires no interaction with the <span class="ref" style=""><a href="http://www.iana.org/">Internet Assigned Numbers Authority (IANA)</a></span>  [<a href="#nt-id2265090">12</a>].</p> 
<h2>6.
       <a name="registrar" id="registrar">XMPP Registrar Considerations</a></h2>
  <div class="indent"><h3>6.1 <a name="registrar-ns" id="registrar-ns">Protocol Namespaces</a></h3>
    <p class="" style="">The <span class="ref" style=""><a href="http://www.xmpp.org/registrar/">XMPP Registrar</a></span>  [<a href="#nt-id2265143">13</a>] includes 'jabber:server:dialback' in its registry of protocol namespaces (see &lt;<a href="http://www.xmpp.org/registrar/namespaces.html">http://www.xmpp.org/registrar/namespaces.html</a>&gt;).</p>
  </div>
  <div class="indent"><h3>6.2 <a name="registrar-stream" id="registrar-stream">Stream Features</a></h3>
    <p class="" style="">The XMPP Registrar includes 'urn:xmpp:features:dialback' in its registry of stream features (see &lt;<a href="http://www.xmpp.org/registrar/stream-features.html">http://www.xmpp.org/registrar/stream-features.html</a>&gt;).</p>
  </div>
<h2>7.
       <a name="schema" id="schema">XML Schema</a></h2>
  <div class="indent"><h3>7.1 <a name="schema-dialback" id="schema-dialback">Dialback</a></h3>
    <p class="caption"></p><div class="indent"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='jabber:server:dialback'
    xmlns='jabber:server:dialback'
    elementFormDefault='qualified'&gt;

  &lt;xs:element name='result'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:simpleContent&gt;
        &lt;xs:extension base='xs:NMTOKEN'&gt;
          &lt;xs:attribute name='from' type='xs:string' use='required'/&gt;
          &lt;xs:attribute name='to' type='xs:string' use='required'/&gt;
          &lt;xs:attribute name='type' use='optional'&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base='xs:NCName'&gt;
                &lt;xs:enumeration value='error'/&gt;
                &lt;xs:enumeration value='invalid'/&gt;
                &lt;xs:enumeration value='valid'/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name='verify'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:simpleContent&gt;
        &lt;xs:extension base='xs:NMTOKEN'&gt;
          &lt;xs:attribute name='from' type='xs:string' use='required'/&gt;
          &lt;xs:attribute name='id' type='xs:NMTOKEN' use='required'/&gt;
          &lt;xs:attribute name='to' type='xs:string' use='required'/&gt;
          &lt;xs:attribute name='type' use='optional'&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base='xs:NCName'&gt;
                &lt;xs:enumeration value='error'/&gt;
                &lt;xs:enumeration value='invalid'/&gt;
                &lt;xs:enumeration value='valid'/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

&lt;/xs:schema&gt;
    </pre></div>
  </div>
  <div class="indent"><h3>7.2 <a name="schema-dialbackfeature" id="schema-dialbackfeature">Stream Feature</a></h3>
    <p class="caption"></p><div class="indent"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:xmpp:features:dialback'
    xmlns='urn:xmpp:features:dialback'
    elementFormDefault='qualified'&gt;

  &lt;xs:element name='dialback'&gt;
    &lt;xs:complexType&gt;
      &lt;xs:choice minOccurs='1' maxOccurs='1'&gt;
        &lt;xs:element name='optional' type='empty'/&gt;
        &lt;xs:element name='required' type='empty'/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;

  &lt;xs:simpleType name='empty'&gt;
    &lt;xs:restriction base='xs:string'&gt;
      &lt;xs:enumeration value=''/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;
    </pre></div>
  </div>
<hr /><h2><a name="notes" id="notes"></a>Notes</h2><div class="indent"><p><a name="nt-id2252861" id="nt-id2252861">1</a>. The jabberd server is the original server implementation of the Jabber/XMPP protocols, first developed by Jeremie Miller, inventor of Jabber. For further information, see &lt;<a href="http://jabberd.org/">http://jabberd.org/</a>&gt;.</p><p><a name="nt-id2252912" id="nt-id2252912">2</a>. The Internet Engineering Task Force is the principal body engaged in the development of new Internet standard specifications, best known for its work on standards such as HTTP and SMTP. For further information, see &lt;<a href="http://www.ietf.org/">http://www.ietf.org/</a>&gt;.</p><p><a name="nt-id2251398" id="nt-id2251398">3</a>. RFC 3920: Extensible Messaging and Presence Protocol (XMPP): Core &lt;<a href="http://tools.ietf.org/html/rfc3920">http://tools.ietf.org/html/rfc3920</a>&gt;.</p><p><a name="nt-id2251427" id="nt-id2251427">4</a>. RFC 3920: Extensible Messaging and Presence Protocol (XMPP): Core &lt;<a href="http://tools.ietf.org/html/rfc3920">http://tools.ietf.org/html/rfc3920</a>&gt;.</p><p><a name="nt-id2251454" id="nt-id2251454">5</a>. rfc3920bis: proposed revisions to Extensible Messaging and Presence Protocol (XMPP): Core &lt;<a href="http://tools.ietf.org/html/draft-saintandre-rfc3920bis">http://tools.ietf.org/html/draft-saintandre-rfc3920bis</a>&gt;. (work in progress)</p><p><a name="nt-id2251539" id="nt-id2251539">6</a>. RFC 3920: Extensible Messaging and Presence Protocol (XMPP): Core &lt;<a href="http://tools.ietf.org/html/rfc3920">http://tools.ietf.org/html/rfc3920</a>&gt;.</p><p><a name="nt-id2251624" id="nt-id2251624">7</a>. XEP-0238: XMPP Protocol Flows for Inter-Domain Federation &lt;<a href="http://www.xmpp.org/extensions/xep-0238.html">http://www.xmpp.org/extensions/xep-0238.html</a>&gt;.</p><p><a name="nt-id2262983" id="nt-id2262983">8</a>. RFC 4086: Randomness Requirements for Security &lt;<a href="http://tools.ietf.org/html/rfc4086">http://tools.ietf.org/html/rfc4086</a>&gt;.</p><p><a name="nt-id2263011" id="nt-id2263011">9</a>. The Keyed-Hash Message Authentication Code (HMAC): Federal Information Processing Standards Publication 198 &lt;<a href="http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf">http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf</a>&gt;.</p><p><a name="nt-id2263055" id="nt-id2263055">10</a>. Secure Hash Standard: Federal Information Processing Standards Publication 180-2  &lt;<a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">http://csrc.nist.gov/publications/fips/fips180-2/fips186-2withchangenotice.pdf</a>&gt;.</p><p><a name="nt-id2265042" id="nt-id2265042">11</a>. RFC 4033: DNS Security Introduction and Requirements &lt;<a href="http://tools.ietf.org/html/rfc4033">http://tools.ietf.org/html/rfc4033</a>&gt;.</p><p><a name="nt-id2265090" id="nt-id2265090">12</a>. The Internet Assigned Numbers Authority (IANA) is the central coordinator for the assignment of unique parameter values for Internet protocols, such as port numbers and URI schemes. For further information, see &lt;<a href="http://www.iana.org/">http://www.iana.org/</a>&gt;.</p><p><a name="nt-id2265143" id="nt-id2265143">13</a>. The XMPP Registrar maintains a list of reserved protocol namespaces as well as registries of parameters used in the context of XMPP extension protocols approved by the XMPP Standards Foundation. For further information, see &lt;<a href="http://www.xmpp.org/registrar/">http://www.xmpp.org/registrar/</a>&gt;.</p></div><hr /><h2><a name="revs" id="revs"></a>Revision History</h2><div class="indent"><h4>Version 0.2 (2008-06-18)</h4><div class="indent">
      <ul class="" style="">
        <li class="" style="">Rewrote introduction.</li>
        <li class="" style="">Provided motivating text about why dialback is used.</li>
        <li class="" style="">Added text about different federation models.</li>
        <li class="" style="">More clearly described what dialback accomplishes and what it does not accomplish.</li>
        <li class="" style="">Added explanatory text about scenarios in which Server Dialback is used and not used.</li>
        <li class="" style="">Clarified basic description of how dialback works.</li>
        <li class="" style="">Clarified discovery of dialback support.</li>
        <li class="" style="">Separated sections into subsections, as has been done for rfc3920bis and rfc3921bis.</li>
        <li class="" style="">Described the protocol flows in much greater detail.</li>
        <li class="" style="">Explained and illustrated failure cases more completely.</li>
        <li class="" style="">Clarified reuse of negotiated connections, a.k.a. piggybacking.</li>
      </ul>
     (psa)
    </div><h4>Version 0.1 (2007-07-11)</h4><div class="indent"><p class="" style="">Initial published version.</p> (psa)
    </div><h4>Version 0.0.1 (2007-06-22)</h4><div class="indent"><p class="" style="">Content moved from rfc3920bis.</p> (psa)
    </div></div><hr /><p>END</p></body></html>
