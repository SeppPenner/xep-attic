<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JEP-0116: Encrypted Sessions</title>
<link rel="stylesheet" type="text/css" href="jep.css">
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
<meta name="DC.Title" content="Encrypted Sessions">
<meta name="DC.Creator" content="Ian Paterson">
<meta name="DC.Creator" content="Peter Saint-Andre">
<meta name="DC.Creator" content="Dave Smith">
<meta name="DC.Description" content="This JEP specifies a protocol for session-based, end-to-end encryption of XMPP communications.">
<meta name="DC.Publisher" content="Jabber Software Foundation">
<meta name="DC.Contributor" content="JEP Editor">
<meta name="DC.Date" content="2005-09-27">
<meta name="DC.Type" content="Jabber Enhancement Proposal">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="JEP-0116">
<meta name="DC.Language" content="en">
<meta name="DC.Rights" content="This Jabber Enhancement Proposal is copyright 1999 - 2005 by the Jabber Software Foundation (JSF) and is in full conformance with the JSF's Intellectual Property Rights Policy &lt;http://www.jabber.org/jsf/ipr-policy.shtml&gt;. This material may be distributed only subject to the terms and conditions set forth in the Creative Commons Attribution License (&lt;http://creativecommons.org/licenses/by/2.5/&gt;).">
</head>
<body>
<h1>JEP-0116: Encrypted Sessions</h1>
<p>This JEP specifies a protocol for session-based, end-to-end encryption of XMPP communications.</p>
<p><hr></p>
<p style="color:red">WARNING: This Standards-Track JEP is Experimental. Publication as a Jabber Enhancement Proposal does not imply approval of this proposal by the Jabber Software Foundation. Implementation of the protocol described herein is encouraged in exploratory implementations, but production systems should not deploy implementations of this protocol until it advances to a status of Draft.</p>
<p><hr></p>
<h2>JEP Information</h2>
<p class="indent">
            Status: Experimental<br>
            Type: Standards Track<br>
            Number: 0116<br>
            Version: 0.8<br>
            Last Updated: 2005-09-27<br>
            JIG: Standards JIG<br>
                Approving Body: Jabber Council<br>Dependencies: XMPP Core, RFC 2104, RFC 2409, RFC 3526, RFC 3548, xml-c14n, JEP-0004, JEP-0020, JEP-0030, JEP-0068, JEP-0079, JEP-0155<br>
                Supersedes: None<br>
                Superseded By: None<br>
            Short Name: esession<br>
            Wiki Page: &lt;<a href="http://wiki.jabber.org/index.php/Encrypted%20Sessions%20(JEP-0116)">http://wiki.jabber.org/index.php/Encrypted Sessions (JEP-0116)</a>&gt;
          </p>
<h2>Author Information</h2>
<div class="indent">
<h3>Ian Paterson</h3>
<p class="indent">
        Email: ian.paterson@clientside.co.uk<br>
        JID: ian@zoofy.com</p>
<h3>Peter Saint-Andre</h3>
<p class="indent">
        Email: stpeter@jabber.org<br>
        JID: stpeter@jabber.org</p>
<h3>Dave Smith</h3>
<p class="indent">
        Email: dizzyd@jabber.org<br>
        JID: dizzyd@jabber.org</p>
</div>
<h2>Legal Notice</h2>
<p class="indent">This Jabber Enhancement Proposal is copyright 1999 - 2005 by the <a href="http://www.jabber.org/jsf/">Jabber Software Foundation</a> (JSF) and is in full conformance with the JSF's Intellectual Property Rights Policy &lt;<a href="http://www.jabber.org/jsf/ipr-policy.shtml">http://www.jabber.org/jsf/ipr-policy.shtml</a>&gt;. This material may be distributed only subject to the terms and conditions set forth in the Creative Commons Attribution License (&lt;<a href="http://creativecommons.org/licenses/by/2.5/">http://creativecommons.org/licenses/by/2.5/</a>&gt;).</p>
<h2>Discussion Venue</h2>
<p class="indent">The preferred venue for discussion of this document is the Standards-JIG discussion list: &lt;<a href="http://mail.jabber.org/mailman/listinfo/standards-jig">http://mail.jabber.org/mailman/listinfo/standards-jig</a>&gt;.</p>
<p class="indent">Given that this JEP normatively references IETF technologies, discussion on the JSF-IETF list may also be appropriate (see &lt;<a href="http://mail.jabber.org/mailman/listinfo/jsf-ietf">http://mail.jabber.org/mailman/listinfo/jsf-ietf</a>&gt; for details).</p>
<h2>Relation to XMPP</h2>
<p class="indent">The Extensible Messaging and Presence Protocol (XMPP) is defined in the XMPP Core (RFC 3920) and XMPP IM (RFC 3921) specifications contributed by the Jabber Software Foundation to the Internet Standards Process, which is managed by the Internet Engineering Task Force in accordance with RFC 2026. Any protocol defined in this JEP has been developed outside the Internet Standards Process and is to be understood as an extension to XMPP rather than as an evolution, development, or modification of XMPP itself.</p>
<h2>Conformance Terms</h2>
<p class="indent">The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.</p>
<p><hr></p>
<h2>Table of Contents</h2>
<div class="indent"><dl>
<dt>1.  <a href="#intro">Introduction</a>
</dt>
<dt>2.  <a href="#background">Background</a>
</dt>
<dt>3.  <a href="#terms">Terminology</a>
</dt>
<dl><dt>3.1.  <a href="#terms-personae">Dramatis Personae</a>
</dt></dl>
<dt>4.  <a href="#reqs">Requirements</a>
</dt>
<dl>
<dt>4.1.  <a href="#reqs-sec">Security Requirements</a>
</dt>
<dl>
<dt>4.1.1.  <a href="#reqs-encrypt">Confidentiality</a>
</dt>
<dt>4.1.2.  <a href="#reqs-integrity">Integrity</a>
</dt>
<dt>4.1.3.  <a href="#reqs-replay">Replay Protection</a>
</dt>
<dt>4.1.4.  <a href="#reqs-forward">Perfect Forward Secrecy</a>
</dt>
<dt>4.1.5.  <a href="#reqs-auth">Authentication</a>
</dt>
<dt>4.1.6.  <a href="#reqs-repudiate">Repudiability</a>
</dt>
</dl>
<dt>4.2.  <a href="#reqs-xmpp">Application Requirements</a>
</dt>
<dl>
<dt>4.2.1.  <a href="#reqs-generality">Generality</a>
</dt>
<dt>4.2.2.  <a href="#reqs-implement">Implementability</a>
</dt>
<dt>4.2.3.  <a href="#reqs-usable">Usability</a>
</dt>
<dt>4.2.4.  <a href="#reqs-efficient">Efficiency</a>
</dt>
<dt>4.2.5.  <a href="#reqs-flexible">Flexibility</a>
</dt>
<dt>4.2.6.  <a href="#reqs-usable">Interoperability</a>
</dt>
<dt>4.2.7.  <a href="#reqs-offline">Offline Sessions</a>
</dt>
<dt>4.2.8.  <a href="#reqs-offline">Object Encryption</a>
</dt>
</dl>
</dl>
<dt>5.  <a href="#synopses">Synopses</a>
</dt>
<dl>
<dt>5.1.  <a href="#synopses-params">Parameter Descriptions</a>
</dt>
<dt>5.2.  <a href="#synopses-online">Online Esession Negotiation</a>
</dt>
<dt>5.3.  <a href="#synopses-offline">Offline Esession Negotiation</a>
</dt>
</dl>
<dt>6.  <a href="#disco">Discovering Support</a>
</dt>
<dt>7.  <a href="#init">ESession Initiation</a>
</dt>
<dl>
<dt>7.1.  <a href="#init-online">Online Diffie-Hellman Key Exchange</a>
</dt>
<dl>
<dt>7.1.1.  <a href="#init-online-request">Esession Request</a>
</dt>
<dt>7.1.2.  <a href="#init-online-bobprep">Diffie-Hellman Preparation (Bob)</a>
</dt>
<dt>7.1.3.  <a href="#init-online-response">Esession Response</a>
</dt>
<dt>7.1.4.  <a href="#init-online-aliceprep">Diffie-Hellman Preparation (Alice)</a>
</dt>
<dt>7.1.5.  <a href="#init-online-complete">Diffie-Hellman Completion</a>
</dt>
</dl>
<dt>7.2.  <a href="#init-offline">Offline Diffie-Hellman Key Exchange</a>
</dt>
<dl>
<dt>7.2.1.  <a href="#init-offline-publish">Publishing Esession Options</a>
</dt>
<dt>7.2.2.  <a href="#init-offline-request">Requesting Offline Esession Options</a>
</dt>
<dt>7.2.3.  <a href="#init-offline-prep">Diffie-Hellman Preparation (Offline)</a>
</dt>
<dt>7.2.4.  <a href="#init-offline-start">Starting an Offline Esession</a>
</dt>
<dt>7.2.5.  <a href="#init-offline-accept">Accepting Offline Esessions</a>
</dt>
</dl>
<dt>7.3.  <a href="#init-keys">Generating Session Keys</a>
</dt>
</dl>
<dt>8.  <a href="#exchange">Exchanging Stanzas</a>
</dt>
<dl>
<dt>8.1.  <a href="#exchange-separate">Encryptable Content</a>
</dt>
<dt>8.2.  <a href="#exchange-encrypt">Encryption</a>
</dt>
<dt>8.3.  <a href="#exchange-send">Sending an Encrypted Stanza</a>
</dt>
<dt>8.4.  <a href="#exchange-decrypt">Decryption</a>
</dt>
</dl>
<dt>9.  <a href="#rekey">Re-Key Exchange</a>
</dt>
<dl>
<dt>9.1.  <a href="#rekey-init">Re-Key Initiation</a>
</dt>
<dt>9.2.  <a href="#rekey-accept">Re-Key Acceptance</a>
</dt>
<dt>9.3.  <a href="#rekey-publish">Publishing Old MAC Values</a>
</dt>
</dl>
<dt>10.  <a href="#terminate">Esession Termination</a>
</dt>
<dt>11.  <a href="#sign">Signature Generation and Verification</a>
</dt>
<dl>
<dt>11.1.  <a href="#sign-normal">XML Normalization</a>
</dt>
<dt>11.2.  <a href="#sign-hash">Hash</a>
</dt>
<dt>11.3.  <a href="#sign-calc">Generation</a>
</dt>
<dl>
<dt>11.3.1.  <a href="#sign-rsa-gen">RSA</a>
</dt>
<dt>11.3.2.  <a href="#sign-dsa-gen">DSA</a>
</dt>
</dl>
<dt>11.4.  <a href="#sign-format">Signature Format</a>
</dt>
<dl>
<dt>11.4.1.  <a href="#sign-rsa-format">RSA</a>
</dt>
<dt>11.4.2.  <a href="#sign-dsa-format">DSA</a>
</dt>
</dl>
<dt>11.5.  <a href="#sign-calc">Verification</a>
</dt>
<dl>
<dt>11.5.1.  <a href="#sign-rsa-verify">RSA</a>
</dt>
<dt>11.5.2.  <a href="#sign-dsa-verify">DSA</a>
</dt>
</dl>
</dl>
<dt>12.  <a href="#sec">Security Considerations</a>
</dt>
<dl>
<dt>12.1.  <a href="#sec-prng">Random Numbers</a>
</dt>
<dt>12.2.  <a href="#sec-rekey">Re-Keying Limits</a>
</dt>
<dt>12.3.  <a href="#sec-keys">Verifying Keys</a>
</dt>
<dt>12.4.  <a href="#sec-replay">Replay Attacks</a>
</dt>
<dt>12.5.  <a href="#sec-unencrypted">Unencrypted Esessions</a>
</dt>
<dt>12.6.  <a href="#sec-storage">Storage</a>
</dt>
<dt>12.7.  <a href="#sec-offline">Offline Esessions</a>
</dt>
<dt>12.8.  <a href="#sec-general">Extra Responsabilities of Implementors</a>
</dt>
<dt>12.9.  <a href="#sec-mandatory">Mandatory to Implement Technologies</a>
</dt>
<dl>
<dt>12.9.1.  <a href="#sec-mandatory-encryption">Block Cipher Algorithms</a>
</dt>
<dt>12.9.2.  <a href="#sec-mandatory-sign">Key Signing Algorithms</a>
</dt>
<dt>12.9.3.  <a href="#sec-mandatory-public">Public Signature-Verification-Key Formats</a>
</dt>
<dt>12.9.4.  <a href="#sec-mandatory-hash">Hash Algorithms</a>
</dt>
<dt>12.9.5.  <a href="#sec-mandatory-compress">Compression Algorithms</a>
</dt>
</dl>
</dl>
<dt>13.  <a href="#iana">IANA Considerations</a>
</dt>
<dt>14.  <a href="#registrar">Jabber Registrar Considerations</a>
</dt>
<dl>
<dt>14.1.  <a href="#registrar-ns">Namespaces</a>
</dt>
<dt>14.2.  <a href="#registrar-formtype">Field Standardization</a>
</dt>
</dl>
<dt>15.  <a href="#schema">XML Schemas</a>
</dt>
<dt>16.  <a href="#keys">Public Key Publication and Retrieval</a>
</dt>
<dt>17.  <a href="#open">Open Issues</a>
</dt>
<dl>
<dt>17.1.  <a href="#open-tothink">To Think About</a>
</dt>
<dt>17.2.  <a href="#open-todo">To Do</a>
</dt>
</dl>
<dt><a href="#notes">Notes</a></dt>
<dt><a href="#revs">Revision History</a></dt>
</dl></div>
<p><hr></p>
<h2>1.
       <a name="intro">Introduction</a>
</h2>
  <p class="" style="">End-to-end encryption is a desirable feature for any communication technology. Ideally, such a technology would design encryption in from the beginning and would forbid unencrypted communications. Realistically, most communication technologies have not been designed in that manner, and Jabber/XMPP technologies are no exception. In particular, the original Jabber technologies developed in 1999 did not include end-to-end encryption by default. PGP-based encryption of message bodies and signing of presence information was added as an extension to the core protocols in the year 2000; this extension is documented in <span class="ref" style="">Current Jabber OpenPGP Usage</span>  [<a href="#nt-id2250835">1</a>]. When the core protocols were formalized within the Internet Standards Process by the IETF's XMPP Working Group in 2003, a different extension was defined using S/MIME-based signing and encryption of CPIM-formatted messages (see <span class="ref" style="">RFC 3862</span>  [<a href="#nt-id2250790">2</a>]) and PIDF-formatted presence information (see <span class="ref" style="">RFC 3863</span>  [<a href="#nt-id2250818">3</a>]); this extension is specified in <span class="ref" style="">RFC 3923</span>  [<a href="#nt-id2250566">4</a>].</p>
  <p class="" style="">For reasons described more fully below, the foregoing proposals (and others not mentioned) have not been widely implemented and deployed. This is unfortunate, since an open communication protocol needs to enable end-to-end encryption in order to be seriously considered for deployment by a broad range of users. This proposal describes a different approach to end-to-end encryption for use by entities that communicate using XMPP. The approach taken herein essentially translates the semantics of the secure shell protocol (SSH) into the syntax of XMPP, with some adjustments that reflect reports of security issues with SHA-1 and insights gleaned from implementation of "off-the-record" (OTR) communication in the Gaim encryption plugin as described in <span class="ref" style="">Off-the-Record Communication</span>  [<a href="#nt-id2250609">5</a>]. The result is a protocol for encrypted sessions or "ESessions".</p>
<h2>2.
       <a name="background">Background</a>
</h2>
  <p class="" style="">As specified in <span class="ref" style="">RFC 3920</span>  [<a href="#nt-id2250676">6</a>], XMPP is an XML streaming protocol that enables the near-real-time exchange of XML fragments between any two (or more) network endpoints. To date, the main application built on top of the core XML streaming layer is instant messaging (IM) and presence, the base extensions for which are specified in <span class="ref" style="">RFC 3921</span>  [<a href="#nt-id2250646">7</a>]. There are three first-level elements of XML streams (&lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt;); each of these "XML stanza" types has different semantics, which can complicate the task of defining a generalized approach to end-to-end encryption for XMPP. In addition, XML stanzas can be extended (via properly-namespaced child elements) for a wide variety of functionality. The chosen approach should enable encryption of several complete XML elements rather than only parts thereof (e.g., only the XML character data of the message &lt;body/&gt; element as in <span style="font-weight: bold">JEP-0027</span>).</p>
  <p class="" style="">XMPP is a session-oriented communication technology: normally, a client authenticates with a server and maintains a long-lived connection that defines the client's XMPP session. Such stream-level sessions are secured via channel encryption using Transport Level Security (<span class="ref" style="">RFC 2246</span>  [<a href="#nt-id2256421">8</a>]), as specified in Section 5 of <span style="font-weight: bold">RFC 3920</span>. However, there is no guarantee that all hops will implement or enforce channel encryption (or that intermediate routers are trustworthy), which makes end-to-end encryption desirable.</p>
  <p class="" style="">The session metaphor also applies to communication between endpoints: for instance, in IM applications, most instant messaging exchanges occur in bursts within limited time periods (e.g., two people may send a fairly large number of messages during a five-minute chat and then not exchange messages again for hours or even days). The XML stanzas exchanged during such a session may not be limited to &lt;message/&gt; stanzas; for instance, the session may be triggered by a change in one of the parties' presence status (e.g., changing from away to available) and the session may involve the exchange of &lt;iq/&gt; stanzas (e.g., to transfer a file as specified in <span class="ref" style="">File Transfer</span>  [<a href="#nt-id2256470">9</a>]). Endpoints may want to encrypt the stanzas they send to each other in such a way that the stanzas cannot be understood by untrusted mediating entities (such as servers) except to the extent required to understand the necessary routing information. (One complicating factor is that routing information may include not only the stanza's 'to', 'from', 'type, and 'id' attributes, but also <span class="ref" style="">Advanced Message Processing</span>  [<a href="#nt-id2256493">10</a>] extensions.)</p>
  <p class="" style="">The foregoing XMPP communications exist in the context of a one-to-one communication session between two entities. However, several forms of XMPP communication exist outside the context of one-to-one communication sessions:</p>
  <ul>
    <li>Many-to-many sessions, such as a text conference in a chatroom as specified in <span class="ref" style="">Multi-User Chat</span>  [<a href="#nt-id2256529">11</a>].</li>
    <li>One-to-many "broadcast", such as undirected presence stanzas sent from one user to many contacts (see <span style="font-weight: bold">RFC 3921</span>) and data syndication implemented using <span class="ref" style="">Publish-Subscribe</span>  [<a href="#nt-id2256558">12</a>].</li>
    <li>One-to-one communications that are stored for later delivery rather than delivered immediately, such as so-called "offline messages".</li>
  </ul>
  <p class="" style="">Ideally, any technology for end-to-end encryption in XMPP could be extended to cover these scenarios as well as one-to-one communication sessions. However, both many-to-many sessions and one-to-many broadcast are deemed out of scope for this JEP. Offline communications are handled via a simple extension to the protocol for one-to-one sessions between two entities that are online simultaneously (see below).</p>
  <p class="" style="">Because XMPP is a session-oriented communication technology, encryption schemes that are appropriate for less dynamic technologies may not be appropriate for XMPP. XMPP, with its in-order delivery of XML stanzas, is able to take advantage of encryption approaches that are not feasible for less dynamic technologies. In particular, existing approaches to encryption of Internet communications have generally assumed that the "thing" to be encrypted has a stable identity or is best understood as a standalone object (e.g., a file or email message); the term "object encryption" well captures this assumption. Both <span style="font-weight: bold">JEP-0027</span> and <span style="font-weight: bold">RFC 3923</span> assume that XMPP communications are more like the exchange of email messages than they are like an interactive session -- while <span style="font-weight: bold">JEP-0027</span> uses "old-style" PGP object encryption and <span style="font-weight: bold">RFC 3923</span> uses "new-style" S/MIME object encryption, both specify the use of object encryption. </p>
  <p class="" style="">However, the session-oriented nature of XMPP may imply that the focus should be on "session encryption" rather than "object encryption". The paradigm for XMPP encryption may be something closer to the widely-deployed Secure Shell technology (see <span class="ref" style="">SSH Protocol Architecture</span>  [<a href="#nt-id2256688">13</a>] and <span class="ref" style="">SSH Transport Layer Protocol</span>  [<a href="#nt-id2256661">14</a>]) than to traditional encryption of files and standalone email messages. In many ways, Secure Shell (or, more specifically, OTR) is the conceptual model for the current proposal.</p>
  <p class="" style="">Therefore, this JEP specifies a method for encrypted sessions ("ESessions") that takes advantage of the inherent possibilities and strengths of session encryption as opposed to object encryption. The basic concept is that of an encrypted session which acts as a secure tunnel between two endpoints. Once the tunnel is established, the content of all one-to-one XML stanzas exchanged between the endpoints will be encrypted and then transmitted within a "wrapper" protocol element.</p>
<h2>3.
       <a name="terms">Terminology</a>
</h2>
  <div class="indent">
<h3>3.1 <a name="terms-personae">Dramatis Personae</a>
</h3>
    <p class="" style="">This JEP introduces two characters to help the reader follow the necessary exchanges:</p>
    <ol start="1" type="">
      <li>"Alice" is the name of the initiator of the ESession. Within the scope of this JEP, we stipulate that her fully-qualified JID is: &lt;alice@example.org/pda&gt;.</li>
      <li>"Bob" is the name of the other participant in the ESession started by Alice. Within the scope of this JEP, his fully-qualified JID is: &lt;bob@example.com/laptop&gt;.</li>
    </ol>
    <p class="" style="">While Alice and Bob are introduced as "end users", they are simply meant to be examples of Jabber entities. Any directly addressable Jabber entity may participate in an Esession.</p>
  </div>
<h2>4.
       <a name="reqs">Requirements</a>
</h2>
  <div class="indent">
<h3>4.1 <a name="reqs-sec">Security Requirements</a>
</h3>
    <p class="" style="">This JEP stipulates the following security requirements for end-to-end encryption of XMPP communications:</p>
    <ul>
      <li>Confidentiality</li>
      <li>Integrity</li>
      <li>Replay protection</li>
      <li>Perfect forward secrecy</li>
      <li>Authentication</li>
      <li>Repudiability</li>
    </ul>
    <p class="" style="">Each of these requirements is explained in greater depth below.</p>
    <div class="indent">
<h3>4.1.1 <a name="reqs-encrypt">Confidentiality</a>
</h3>
      <p class="" style="">The one-to-one XML stanzas exchanged between two entities MUST NOT be understandable to any other entity that might intercept the communications.</p>
    </div>
    <div class="indent">
<h3>4.1.2 <a name="reqs-integrity">Integrity</a>
</h3>
      <p class="" style="">Alice and Bob MUST be sure that no other entity may change the content of the XML stanzas they exchange, or remove or insert stanzas into the Esession undetected.</p>
    </div>
    <div class="indent">
<h3>4.1.3 <a name="reqs-replay">Replay Protection</a>
</h3>
      <p class="" style="">Alice or Bob MUST be able to identify and reject any communications that are copies of their previous communications resent by another entity.</p>
    </div>
    <div class="indent">
<h3>4.1.4 <a name="reqs-forward">Perfect Forward Secrecy</a>
</h3>
      <p class="" style="">The encrypted communication MUST NOT be revealed even if long-lived keys are compromised in the future (e.g., Steve steals Bob's computer).</p>
    </div>
    <div class="indent">
<h3>4.1.5 <a name="reqs-auth">Authentication</a>
</h3>
      <p class="" style="">Each party to a conversation MUST know that the other party is who he says he is (Alice must be able to know that Bob really is Bob, and vice versa).  [<a href="#nt-id2256898">15</a>]</p>
    </div>
    <div class="indent">
<h3>4.1.6 <a name="reqs-repudiate">Repudiability</a>
</h3>
      <p class="" style="">Alice and Bob MUST be able to repudiate any stanza that occurs within an Esession. After an Esession has finished, it SHOULD NOT be possible to <span style="font-style: italic">prove cryptographically</span> that any transcript has not been modified by a third party.  [<a href="#nt-id2256925">16</a>]</p>
    </div>
  </div>
  <div class="indent">
<h3>4.2 <a name="reqs-xmpp">Application Requirements</a>
</h3>
    <p class="" style="">In addition to the foregoing security profile, this JEP also stipulates the following application-specific requirements for encrypted communication in the context of Jabber/XMPP technologies:</p>
    <ul>
      <li>Generality</li>
      <li>Implementability</li>
      <li>Usability</li>
      <li>Efficiency</li>
      <li>Flexibility</li>
      <li>Interoperability</li>
      <li>Offline "sessions"</li>
      <li>Object encryption</li>
    </ul>
    <p class="" style="">Each of these is explained in greater depth below.</p>
    <div class="indent">
<h3>4.2.1 <a name="reqs-generality">Generality</a>
</h3>
      <p class="" style="">The solution should be generally applicable to any XML stanza type (&lt;message/&gt;, &lt;presence/&gt;, &lt;iq/&gt;) sent between two entities. It is deemed acceptable for now if the solution does not apply to many-to-many stanzas (e.g., groupchat messages sent within the context of multi-user chat) or one-to-many stanzas (e.g., presence "broadcasts" and pubsub notifications); end-to-end encryption of such stanzas may require separate solutions or extensions to the one-to-one session solution.</p>
    </div>
    <div class="indent">
<h3>4.2.2 <a name="reqs-implement">Implementability</a>
</h3>
      <p class="" style="">The only good security technology is an implemented security technology. The solution should be one that typical client developers can implement in a relatively straightforward and interoperable fashion.</p>
    </div>
    <div class="indent">
<h3>4.2.3 <a name="reqs-usable">Usability</a>
</h3>
      <p class="" style="">The requirement of usability takes implementability one step further by stipulating that the solution must be one that organizations may deploy and humans may use with 100% transparency (with the ease-of-use of https:). Experience has shown that: solutions requiring a full public key infrastructure do not get widely deployed, and solutions requiring any user action are not widely used. We can do better.</p>
    </div>
    <div class="indent">
<h3>4.2.4 <a name="reqs-efficient">Efficiency</a>
</h3>
      <p class="" style="">Cryptographic operations are highly CPU intensive, particularly public key and Diffie-Hellman operations. Cryptographic data structures can be relatively large especially public keys and certificates. The solution should perform efficiently even when CPU and network bandwidth are constrained.</p>
    </div>
    <div class="indent">
<h3>4.2.5 <a name="reqs-flexible">Flexibility</a>
</h3>
      <p class="" style="">The solution should be compatible with existing (and future) cryptographic algorithms and identity certification schemes (including X.509 and PGP).</p>
    </div>
    <div class="indent">
<h3>4.2.6 <a name="reqs-usable">Interoperability</a>
</h3>
      <p class="" style="">Ideally, it would be possible for an XMPP user to exchange encrypted messages (and, potentially, presence information) with users of non-XMPP messaging systems.</p>
    </div>
    <div class="indent">
<h3>4.2.7 <a name="reqs-offline">Offline Sessions</a>
</h3>
      <p class="" style="">Ideally, it should be possible to encrypt one-to-one communications that are stored for later delivery rather than delivered immediately, such as so-called "offline messages".</p>
    </div>
    <div class="indent">
<h3>4.2.8 <a name="reqs-offline">Object Encryption</a>
</h3>
      <p class="" style="">For cases where a session is not desired, it should be possible to encrypt, sign and send a single stanza in isolation, so-called "object encryption".</p>
    </div>
  </div>
<h2>5.
       <a name="synopses">Synopses</a>
</h2>
  <p class="" style=""><span style="font-style: italic">This section is informative, not normative.</span></p>
  <div class="indent">
<h3>5.1 <a name="synopses-params">Parameter Descriptions</a>
</h3>
    <p class="caption">Table 1: Online and Offline Negotiation</p>
<table border="1" cellpadding="3" cellspacing="0">
      <tr class="body">
        <th colspan="" rowspan="">Parameter</th>
        <th colspan="" rowspan="">Description</th>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">C<span class="sub" style="">A</span>, C<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">Block cipher initial counter value for blocks sent by Alice and Bob</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">pubKeys<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The IDs of all of Bob's public keys that either, Alice has validated (online), or Bob can sign for (offline)</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">options</td>
        <td align="" colspan="" rowspan="">Includes a set of possible values for each Esession parameter (see <a href="#init-online-request">Esession Request</a>)</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">chosen</td>
        <td align="" colspan="" rowspan="">Includes a chosen value for each Esession parameter</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">p, g</td>
        <td align="" colspan="" rowspan="">Diffie-Hellman prime and generator</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">HASH</td>
        <td align="" colspan="" rowspan="">Selected hash algorithm</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">CIPHER</td>
        <td align="" colspan="" rowspan="">Selected block cipher algorithm</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">n</td>
        <td align="" colspan="" rowspan="">Block size of CIPHER in bits</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">x, y</td>
        <td align="" colspan="" rowspan="">Alice and Bob's private Diffie-Hellman keys</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">e, d</td>
        <td align="" colspan="" rowspan="">Alice and Bob's public Diffie-Hellman keys</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">pubKeys<span class="sub" style="">A</span>
</td>
        <td align="" colspan="" rowspan="">The IDs of all of Alice's public keys that either, Bob has validated (online), or Alice can sign for (offline)</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">K</td>
        <td align="" colspan="" rowspan="">Shared secret</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">JID<span class="sub" style="">A</span>, JID<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">Alice and Bob's full Jabber IDs</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">K-C<span class="sub" style="">A</span>, K-C<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The cipher keys that Alice and Bob use to encrypt stanzas</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">K-M<span class="sub" style="">A</span>, K-M<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The MAC keys that Alice and Bob use to 'sign' encrypted stanzas</td>
      </tr>
    </table>

    <p class="caption">Table 2: Online Negotiation Only</p>
<table border="1" cellpadding="3" cellspacing="0">
      <tr class="body">
        <td align="" colspan="" rowspan="">signKey<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The private key that Bob uses to sign form<span class="sub" style="">B</span>
</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">pubKey<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">The public key that Alice should use to verify Bob's signature of form<span class="sub" style="">B</span>
</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">signKey<span class="sub" style="">A</span>
</td>
        <td align="" colspan="" rowspan="">The private key that Alice uses to sign form<span class="sub" style="">C</span>
</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">pubKey<span class="sub" style="">A</span>
</td>
        <td align="" colspan="" rowspan="">The public key that Bob should use to verify Alice's signature of form<span class="sub" style="">C</span>
</td>
      </tr>
    </table>

    <p class="caption">Table 3: Offline Negotiation Only</p>
<table border="1" cellpadding="3" cellspacing="0">
      <tr class="body">
        <th colspan="" rowspan="">Parameter</th>
        <th colspan="" rowspan="">Description</th>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">hashes<span class="sub" style="">A</span>
</td>
        <td align="" colspan="" rowspan="">The set of hashes of form<span class="sub" style="">A</span> (one for each of the hash algorithms that Bob supports)</td>
      </tr>
      <tr class="body">
        <td align="" colspan="" rowspan="">signKeys<span class="sub" style="">A</span>, signKeys<span class="sub" style="">B</span>
</td>
        <td align="" colspan="" rowspan="">All the private keys that Alice or Bob is able to use to create signatures</td>
      </tr>
    </table>
  </div>

  <div class="indent">
<h3>5.2 <a name="synopses-online">Online Esession Negotiation</a>
</h3>
    <p class="" style="">Alice uses this protocol when Bob is Online. She offers him a choice of algorithms and other parameters.</p>
    
    <pre>
<span style="font-weight: bold">ALICE</span>                                 <span style="font-weight: bold">BOB</span> 

C<span class="sub" style="">A</span> = random()
form<span class="sub" style="">A</span> = {C<span class="sub" style="">A</span>, options, pubKeys<span class="sub" style="">B</span>}

                             form<span class="sub" style="">A</span>
                            ------&gt;
                                      chosen ∈ options (p,g,HASH,CIPHER...)
                                      C<span class="sub" style="">A</span> = C<span class="sub" style="">A</span> AND 2<span class="super" style="">n</span>-1 
                                      C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span>
                                      y = random()
                                      d = g<span class="super" style="">y</span> mod p
                                      hash<span class="sub" style="">A</span> = HASH(form<span class="sub" style="">A</span>)
                                      pubKey<span class="sub" style="">B</span> ∈ pubKeys<span class="sub" style="">B</span> 
                                      form<span class="sub" style="">B</span> = {chosen, d, hash<span class="sub" style="">A</span>, pubKey<span class="sub" style="">B</span>, pubKeys<span class="sub" style="">A</span>}
                                      sign<span class="sub" style="">B</span> = <span style="font-style: italic">sign</span>(signKey<span class="sub" style="">B</span>, form<span class="sub" style="">B</span>)
                             form<span class="sub" style="">B</span>
                            &lt;------
                             sign<span class="sub" style="">B</span> 
<span style="font-style: italic">assert</span> hash<span class="sub" style="">A</span> = HASH(form<span class="sub" style="">A</span>)
<span style="font-style: italic">assert</span> chosen ∈ options
<span style="font-style: italic">assert</span> d &gt; 1
<span style="font-style: italic">verify</span>(sign<span class="sub" style="">B</span>, pubKey<span class="sub" style="">B</span>, form<span class="sub" style="">B</span>)
C<span class="sub" style="">A</span> = C<span class="sub" style="">A</span> AND 2<span class="super" style="">n</span>-1 
C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span>
x = random()
e = g<span class="super" style="">x</span> mod p
K = d<span class="super" style="">x</span> mod p
K-C<span class="sub" style="">A</span> = HASH(K, JID<span class="sub" style="">A</span>)
K-M<span class="sub" style="">A</span> = HASH(K-C<span class="sub" style="">A</span>, JID<span class="sub" style="">B</span>)
K-C<span class="sub" style="">B</span> = HASH(K, JID<span class="sub" style="">B</span>)
K-M<span class="sub" style="">B</span> = HASH(K-C<span class="sub" style="">B</span>, JID<span class="sub" style="">A</span>)
hash<span class="sub" style="">B</span> = HASH(form<span class="sub" style="">B</span>)
pubKey<span class="sub" style="">A</span> ∈ pubKeys<span class="sub" style="">A</span> 
form<span class="sub" style="">C</span> = {e, hash<span class="sub" style="">B</span>, pubKey<span class="sub" style="">A</span>}
sign<span class="sub" style="">C</span> = <span style="font-style: italic">sign</span>(signKey<span class="sub" style="">A</span>, form<span class="sub" style="">C</span>)
                             form<span class="sub" style="">C</span>
                            ------&gt;
                             sign<span class="sub" style="">C</span> 
                                      <span style="font-style: italic">assert</span> hash<span class="sub" style="">B</span> = HASH(form<span class="sub" style="">B</span>)
                                      <span style="font-style: italic">verify</span>(sign<span class="sub" style="">C</span>, pubKey<span class="sub" style="">A</span>, form<span class="sub" style="">C</span>)
                                      <span style="font-style: italic">assert</span> e &gt; 1
                                      K = e<span class="super" style="">y</span> mod p
                                      K-C<span class="sub" style="">A</span> = HASH(K, JID<span class="sub" style="">A</span>)
                                      K-M<span class="sub" style="">A</span> = HASH(K-C<span class="sub" style="">A</span>, JID<span class="sub" style="">B</span>)
                                      K-C<span class="sub" style="">B</span> = HASH(K, JID<span class="sub" style="">B</span>)
                                      K-M<span class="sub" style="">B</span> = HASH(K-C<span class="sub" style="">B</span>, JID<span class="sub" style="">A</span>)
    </pre>
  </div>

  <div class="indent">
<h3>5.3 <a name="synopses-offline">Offline Esession Negotiation</a>
</h3>
    <p class="" style="">Alice uses this protocol when Bob is Offline. The diagram is split into three phases. First Bob publishes his Esession options before going offline, later Alice completes the key exchange (and sends him encrypted stanzas that are not shown below), finally when Bob comes online again he verifies and calculates the decryption key.</p>
    <pre>
<span style="font-weight: bold">BOB</span>                                  <span style="font-weight: bold">BOB'S SERVER</span>                     <span style="font-weight: bold">ALICE</span> 

y = random()
d = g<span class="super" style="">y</span> mod p
form<span class="sub" style="">A</span> = {p, g, d, options, pubKeys<span class="sub" style="">B</span>}
signs<span class="sub" style="">A</span> = <span style="font-style: italic">multi_sign</span>(signKeys<span class="sub" style="">B</span>, form<span class="sub" style="">A</span>)
hashes<span class="sub" style="">A</span> = <span style="font-style: italic">multi_hash</span>(form<span class="sub" style="">A</span>)
private = {y, hashes<span class="sub" style="">A</span>}
<span style="font-style: italic">store</span>(private)
                           form<span class="sub" style="">A</span>
                          -------&gt;
                           signs<span class="sub" style="">A</span> 
                                     <span style="font-style: italic">store</span>(form<span class="sub" style="">A</span>, signs<span class="sub" style="">A</span>)
-------------------------------------------------------------------------------------------------------------
                                                            form<span class="sub" style="">A</span>
                                                           -------&gt;
                                                            signs<span class="sub" style="">A</span> 
                                                                      <span style="font-style: italic">verify_one</span>(signs<span class="sub" style="">A</span>, pubKeys<span class="sub" style="">B</span>, form<span class="sub" style="">A</span>)
                                                                      <span style="font-style: italic">assert</span> d &gt; 1
                                                                      chosen ∈ options (HASH,CIPHER...)
                                                                      C<span class="sub" style="">A</span> = random()
                                                                      C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span>
                                                                      x = random()
                                                                      e = g<span class="super" style="">x</span> mod p
                                                                      K = d<span class="super" style="">x</span> mod p
                                                                      K-C<span class="sub" style="">A</span> = HASH(K, JID<span class="sub" style="">A</span>)
                                                                      K-M<span class="sub" style="">A</span> = HASH(K-C<span class="sub" style="">A</span>, JID<span class="sub" style="">B</span>)
                                                                      K-C<span class="sub" style="">B</span> = HASH(K, JID<span class="sub" style="">B</span>)
                                                                      K-M<span class="sub" style="">B</span> = HASH(K-C<span class="sub" style="">B</span>, JID<span class="sub" style="">A</span>)
                                                                      hash<span class="sub" style="">A</span> = HASH(form<span class="sub" style="">A</span>)
                                                                      form<span class="sub" style="">B</span> = {chosen, C<span class="sub" style="">A</span>, e, hash<span class="sub" style="">A</span>, pubKeys<span class="sub" style="">A</span>}
                                                                      signs<span class="sub" style="">B</span> = <span style="font-style: italic">multi_sign</span>(signKeys<span class="sub" style="">A</span>, form<span class="sub" style="">B</span>)
                                                            form<span class="sub" style="">B</span>
                                                           &lt;-------
                                                            signs<span class="sub" style="">B</span> 
                                     <span style="font-style: italic">store</span>(form<span class="sub" style="">B</span>, signs<span class="sub" style="">B</span>)
-------------------------------------------------------------------------------------------------------------
                           form<span class="sub" style="">B</span>
                          &lt;-------
                           signs<span class="sub" style="">B</span> 
<span style="font-style: italic">retrieve</span>(private)
<span style="font-style: italic">assert</span> hash<span class="sub" style="">A</span> ∈ hashes<span class="sub" style="">A</span> 
<span style="font-style: italic">assert</span> chosen ∈ options
<span style="font-style: italic">assert</span> e &gt; 1
<span style="font-style: italic">verify_one</span>(signs<span class="sub" style="">B</span>, pubKeys<span class="sub" style="">A</span>, form<span class="sub" style="">B</span>)
C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> 
K = e<span class="super" style="">y</span> mod p
K-C<span class="sub" style="">A</span> = HASH(K, JID<span class="sub" style="">A</span>)
K-M<span class="sub" style="">A</span> = HASH(K-C<span class="sub" style="">A</span>, JID<span class="sub" style="">B</span>)
K-C<span class="sub" style="">B</span> = HASH(K, JID<span class="sub" style="">B</span>)
K-M<span class="sub" style="">B</span> = HASH(K-C<span class="sub" style="">B</span>, JID<span class="sub" style="">A</span>)
    </pre>
  </div>
<h2>6.
       <a name="disco">Discovering Support</a>
</h2>
  <p class="" style="">Before attempting to engage in an ESession with Bob, Alice SHOULD discover whether he supports this protocol, using either <span class="ref" style="">Service Discovery</span>  [<a href="#nt-id2259458">17</a>] or the presence-based profile of <span style="font-weight: bold">JEP-0030</span> specified in <span class="ref" style="">Entity Capabilities</span>  [<a href="#nt-id2259484">18</a>].</p>
  <p class="" style="">The normal course of events is for Alice to authenticate with her server, retrieve her roster (see <span style="font-weight: bold">RFC 3921</span>), send initial presence to her server, and then receive presence information from all the contacts in her roster. If the presence information she receives from some contacts does not include capabilities data (per <span style="font-weight: bold">JEP-0115</span>), Alice SHOULD then send a service discovery information ("disco#info") request to each of those contacts (in accordance with <span style="font-weight: bold">JEP-0030</span>). Such initial service discovery stanzas MUST NOT be considered part of encrypted communication sessions for the purposes of this JEP, since they perform a "bootstrapping" function that is a prerequisite to encrypted communications. The disco#info request sent from Alice to Bob might look as follows:</p>
  <p class="caption">Example 1. Alice Queries Bob for Esession Support via Disco</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='alice@example.org/pda'
    to='bob@example.com/laptop'
    id='disco1'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'/&gt;
&lt;/iq&gt;
  </pre></div>
  <p class="" style="">If Bob sends a disco#info reply and he supports the protocol defined herein, then he MUST include a service discovery feature variable of "http://jabber.org/protocol/esession".</p>
  <p class="caption">Example 2. Bob Returns disco#info Data</p>
<div class="indent"><pre>
&lt;iq type='result'
    from='bob@example.com/laptop'
    to='alice@example.org/pda'
    id='disco1'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'&gt;
    &lt;identity category='client' type='pc'/&gt;
    ...
    &lt;feature var='http://jabber.org/protocol/esession'/&gt;
    ...
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
<h2>7.
       <a name="init">ESession Initiation</a>
</h2>
  <p class="" style="">The process for establishing an ESession is essentially a translation into XMPP syntax of the SSH transport mechanism for establishing a secure session over an insecure transport (see <span style="font-weight: bold">SSH Transport Layer Protocol</span>). Specifically, as in SSH, ESession uses a Diffie-Hellman key exchange algorithm (see <span class="ref" style="">RFC 2631</span>  [<a href="#nt-id2259580">19</a>]) in the initial negotation (although, as we shall see, it does not use SHA-1 as the hashing algorithm).</p>
  <p class="" style="">When Alice wishes to establish an ESession with Bob, Alice may choose between two different methods of performing the initial Diffie-Hellman key exchange, depending on whether Bob is online or not. Note: Alice MUST NOT initiate a new Esession with Bob if she already has one established with him.</p>

  <div class="indent">
<h3>7.1 <a name="init-online">Online Diffie-Hellman Key Exchange</a>
</h3>
    <p class="" style="">If Alice believes Bob may be online then she SHOULD retrieve Bob's long-term public signature-verification keys (see <a href="#keys">Public Key Publication and Retrieval</a>) and then use the protocol specified in <span class="ref" style="">Chat Session Negotiation</span>  [<a href="#nt-id2259646">20</a>] and Diffie-Hellman to negotiate the Esession options and the shared secret.</p>
    <div class="indent">
<h3>7.1.1 <a name="init-online-request">Esession Request</a>
</h3>
      <p class="" style="">In addition to the "accept" and "logging" fields specified in <span style="font-weight: bold">Chat Session Negotiation</span>, Alice MUST specify each of the Esession options (algorithms etc.) she is willing to use, in her order of preference (see <a href="#sec-mandatory">Mandatory to Implement Technologies</a>). Note: Alice SHOULD NOT include a "reason" field since Aunt Tillie may not be aware the Esession request is not encrypted.</p>
      <ol start="1" type="">
        <li><p class="" style="">The list of Modular Exponential (MODP) group numbers (as specified in <span class="ref" style="">RFC 2409</span>  [<a href="#nt-id2259713">21</a>] or <span class="ref" style="">RFC 3526</span>  [<a href="#nt-id2259736">22</a>]) she is willing to use for Diffie-Hellman key exchange (valid group numbers include 1,2,3,4,5,14,15,16,17 and 18)</p></li>
        <li><p class="" style="">Symmetric block cipher algorithm names</p></li>
        <li><p class="" style="">Hash algorithm names</p></li>
        <li><p class="" style="">Compression algorithm names</p></li>
        <li><p class="" style="">The list of stanza types she is willing to encrypt and decrypt</p></li>
        <li><p class="" style="">Whether or not both entities MUST be connected securely to their servers (see Section 5 of <span style="font-weight: bold">RFC 3920</span>)</p></li>
        <li><p class="" style="">The minimum number of stanzas that MUST be exchanged before an entity MAY initiate a key re-exchange (1 - every stanza, 100 - every hundred stanzas). This value MUST be less than 2<span class="super" style="">32</span> (see <a href="#sec-rekey">Re-Keying Limits</a>)</p></li>
        <li><p class="" style="">The Base64 encoded (in accordance with Section 3 of <span class="ref" style="">RFC 3548</span>  [<a href="#nt-id2259813">23</a>]) SHA-256 fingerprint (PKID) of each of Bob's public signature-verification keys that she found acceptable (see <a href="#sec-keys">Verifying Keys</a>). Note: Alice SHOULD facilitate <a href="#sign-normal">XML Normalization</a> by <span style="font-style: italic">not</span> including an empty "accept_pkids" field.</p></li>
      </ol>
      <p class="" style="">Alice MUST also specify a randomly generated  [<a href="#nt-id2259838">24</a>] initial value of C<span class="sub" style="">A</span>, the block cipher counter for stanzas sent from Alice to Bob. The number of bits in C<span class="sub" style="">A</span> MUST be greater than or equal to the block sizes of all the block cipher options she proposes.</p>
    <p class="caption">Example 3. Alice Requests an ESession</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x type='form' xmlns='jabber:x:data'&gt;
      &lt;field type="hidden" var="FORM_TYPE"&gt;
        &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
      &lt;/field&gt;
      &lt;field type="boolean" var="accept"&gt;
        &lt;value&gt;1&lt;/value&gt;
      &lt;/field&gt;
      &lt;field type="boolean" var="logging"&gt;
        &lt;value&gt;1&lt;/value&gt;
      &lt;/field&gt;
      &lt;field type="list-single" var="modp"&gt;
        &lt;option&gt;&lt;value&gt;5&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;14&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;2&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type="list-single" var="crypt_algs"&gt;
        &lt;option&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;twofish256-ctr&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;aes128-ctr&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type="list-single" var="hash_algs"&gt;
        &lt;option&gt;&lt;value&gt;whirlpool&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type="list-single" var="compress"&gt;
        &lt;option&gt;&lt;value&gt;none&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type="list-multi" var="stanzas"&gt;
        &lt;option&gt;&lt;value&gt;message&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;iq&lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt;presence&lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
      &lt;field type="boolean" var="secure"&gt;
        &lt;value&gt;0&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="counter"&gt;
        &lt;value&gt; ** Base64 encoded block counter ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field type="text-single" var="rekey_freq"&gt;
        &lt;value&gt;1&lt;/value&gt;
      &lt;/field&gt;
      &lt;field type="list-multi" var="accept_pkids"&gt;
        &lt;option&gt;&lt;value&gt; ** PKID ** &lt;/value&gt;&lt;/option&gt;
        &lt;option&gt;&lt;value&gt; ** PKID ** &lt;/value&gt;&lt;/option&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/feature&gt;
  &lt;amp xmlns='http://jabber.org/protocol/amp' per-hop='true'&gt;
    &lt;rule action='drop' condition='deliver' value='stored'/&gt;
  &lt;/amp&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">If Bob does not support one or more of the options in each Esession field (except the 'accept_pkids' field), then he SHOULD return a &lt;feature-not-implemented/&gt; error (but he MAY return no error if, for example, he does not want to reveal his presence to Alice for whatever reason):</p>
    <p class="caption">Example 4. Bob Informs Alice that Her Options Are Not Supported</p>
<div class="indent"><pre>
&lt;message type='error'
         from='bob@example.com/laptop'
         to='alice@example.org/pda'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    ...
  &lt;/feature&gt;
  &lt;error type='cancel'&gt;
    &lt;feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
    &lt;unsupported-options xmlns='http://jabber.org/protocol/esession#error'/&gt;
  &lt;/error&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">Either Bob or Alice MAY attempt to initiate a new ESession after any error during the initiation process. However, both MUST consider the previous negotiation to have failed and MUST discard any information learned through the previous negotiation.</p>
    </div>
    <div class="indent">
<h3>7.1.2 <a name="init-online-bobprep">Diffie-Hellman Preparation (Bob)</a>
</h3>
      <p class="" style="">If Bob is willing to start an ESession with Alice, he SHOULD retrieve Alice's long-term public signature-verification keys. He MUST select one of the options from each of the Esession fields he received from Alice including one hash algorithm ("HASH") and one of the MODP groups (see <span class="ref" style="">RFC 3766</span>  [<a href="#nt-id2250274">25</a>] or <span style="font-weight: bold">RFC 3526</span> for recommendations regarding balancing the sizes of symmetric cipher blocks and Diffie-Hellman moduli). Each MODP group has at least two well known constants: a large prime number p, and a generator g for a subgroup of GF(p). Bob MUST then perform the following computations (where n is the number of bits per cipher block for the selected block cipher algorithm):</p>
      <ol start="1" type="">
        <li><p class="" style="">Set C<span class="sub" style="">A</span> = C<span class="sub" style="">A</span> AND 2<span class="super" style="">n</span>-1 (i.e. truncate C<span class="sub" style="">A</span> to the block size)</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> (where C<span class="sub" style="">B</span> is the block counter for stanzas sent from Bob to Alice)</p></li>
        <li><p class="" style="">Generate a secret random number y (where 2<span class="super" style="">2n-1</span> &lt; y &lt; p - 1)</p></li>
        <li><p class="" style="">Calculate d = g<span class="super" style="">y</span> mod p</p></li>
      </ol>
    </div>
    <div class="indent">
<h3>7.1.3 <a name="init-online-response">Esession Response</a>
</h3>
    <p class="" style="">Bob responds to Alice specifying the Esession options he selected.</p>
    <p class="" style="">If Bob is willing to start an ESession with Alice, then instead of providing the PKID of his public key that he selected, Bob MUST specify the Base64 encoded SHA-256 fingerprint (PKID) of each of Alice's public signature-verification keys that he finds acceptable (see <a href="#sec-keys">Verifying Keys</a>). Note: The values Bob submits in the "accept_pkids" field are not selected from the options he received.</p>
    <p class="" style="">Note: The value of the 'rekey_freq' field MUST be less than 2<span class="super" style="">32</span> and greater than or equal to the value specified by Alice.</p>
    <p class="" style="">In addition to the fields he received from Alice, Bob MUST include the Base64 encoded value of d. If Alice selected one or more of his public keys, and if Bob has access to a long-lived private signing key that corresponds to one of those keys  [<a href="#nt-id2260372">26</a>], then he MUST also include the PKID. Otherwise (for example, if Bob is unable to publish keys to his server or if Alice is unable to access keys published via his server  [<a href="#nt-id2260380">27</a>]), Bob MAY include one of his Base64 encoded public keys. In either case, Bob MUST include the signature (see <a href="#sign">Signature Generation</a>) of the <span style="font-style: italic">content</span> of the data form (excluding the 'signs' field). He MUST also include the Base64 encoded HASH of the <a href="#sign-normal">Normalized</a> <span style="font-style: italic">content</span> of the data form from Alice's Esession request.</p>
    <p class="" style="">Note: Bob SHOULD facilitate <a href="#sign-normal">XML Normalization</a> by <span style="font-style: italic">not</span> including empty "accept_pkids", "pkids" or "signs" fields.</p>
    <p class="" style="">However, if Bob is unwilling to start an ESession, but he is ready to initiate a one-to-one chat session with Alice (see <span style="font-weight: bold">Chat Session Negotiation</span>), then he SHOULD terminate the Esession negotiation by not specifying any of the five extra values in his response.</p>
    <p class="caption">Example 5. Bob Responds to Alice (with PKID)</p>
<div class="indent"><pre>
&lt;message from='bob@example.com/laptop' to='alice@example.org/pda'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      &lt;field var="FORM_TYPE"&gt;
        &lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="accept"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/field&gt;
      &lt;field var="logging"&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var="modp"&gt;&lt;value&gt;5&lt;/value&gt;&lt;/field&gt;
      &lt;field var="crypt_algs"&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/field&gt;
      &lt;field var="hash_algs"&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/field&gt;
      &lt;field var="compress"&gt;&lt;value&gt;none&lt;/value&gt;&lt;/field&gt;
      &lt;field var="stanzas"&gt;&lt;value&gt;message&lt;/value&gt;&lt;/field&gt;
      &lt;field var="secure"&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var="rekey_freq"&gt;&lt;value&gt;50&lt;/value&gt;&lt;/field&gt;
      &lt;field var="accept_pkids"&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="key"&gt;
        &lt;value&gt; ** Base64 encoded value of d ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="prev_hash"&gt;
        &lt;value&gt; ** Base64 encoded HASH of Alice's previous form ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="pkids"&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="signs"&gt;
        &lt;value&gt; ** signature of form ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/feature&gt;
&lt;/message&gt;
    </pre></div>
    <p class="caption">Example 6. Bob Responds to Alice (with Public Key)</p>
<div class="indent"><pre>
&lt;message from='bob@example.com/laptop' to='alice@example.org/pda'&gt;
  &lt;feature xmlns='http://jabber.org/protocol/feature-neg'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      ...
      &lt;field var="prev_hash"&gt;
        &lt;value&gt; ** Base64 encoded HASH of Alice's previous form ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="pkey"&gt;
        &lt;value&gt; ** Base64 encoded public key ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="signs"&gt;
        &lt;value&gt; ** signature of form ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/feature&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">If the value of d is less than two or if Bob provided an invalid signature (see <a href="#sign">Signature Verification</a>) then Alice MUST NOT proceed. If Alice provided a PKID but Bob did not provide a signature, or if Bob sent Alice a public key but she could not verify it belongs to him via secure out-of-band communication (see <a href="#sec-keys">Verifying Keys</a>) then she SHOULD send a &lt;not-acceptable/&gt; error to him.</p>
    <p class="caption">Example 7. Alice Signals an Unacceptable or Missing Signature</p>
<div class="indent"><pre>
&lt;message type='error'
         from='alice@example.org/pda'
         to='bob@example.com/laptop'&gt;
  &lt;error type='cancel'&gt;
    &lt;not-acceptable xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;
    &lt;invalid-signature xmlns='http://jabber.org/protocol/esession#error'/&gt;
  &lt;/error&gt;
&lt;/message&gt;
    </pre></div>
    </div>
    <div class="indent">
<h3>7.1.4 <a name="init-online-aliceprep">Diffie-Hellman Preparation (Alice)</a>
</h3>
      <p class="" style="">After verifying Bob's signature and his HASH of her request form, Alice can be certain that the value of d was actually generated by Bob in response to her Esession request. Alice MUST use the value of d and the Esession options specified in Bob's response to perform the following steps (where n is the number of bits per cipher block for the agreed block cipher algorithm):</p>
      <ol start="1" type="">
        <li><p class="" style="">Set C<span class="sub" style="">A</span> = C<span class="sub" style="">A</span> AND 2<span class="super" style="">n</span>-1</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span></p></li>
        <li><p class="" style="">Generate a secret random number x (where 2<span class="super" style="">2n-1</span> &lt; x &lt; p - 1)</p></li>
        <li><p class="" style="">Calculate e = g<span class="super" style="">x</span> mod p</p></li>
        <li><p class="" style="">Calculate K = d<span class="super" style="">x</span> mod p (this is the shared secret)</p></li>
      </ol>
    </div>
    <div class="indent">
<h3>7.1.5 <a name="init-online-complete">Diffie-Hellman Completion</a>
</h3>
    <p class="" style="">Alice then completes the Diffie-Hellman negotiation by sending Bob the Base64 encoded value of e. If Bob selected one or more of her public keys, and if Alice has access to a long-lived private signing key that corresponds to one of those keys, then she MUST also include the PKID. Otherwise, Alice MAY include one of her Base64 encoded public keys (see the <a href="#init-response">Esession Response</a> example).</p>
    <p class="" style="">In either case, Alice MUST include the signature (see <a href="#sign">Signature Generation</a>) of the <span style="font-style: italic">content</span> of the data form (excluding the 'signs' field). She MUST also include the Base64 encoded HASH of the <a href="#sign-normal">Normalized</a> <span style="font-style: italic">content</span> of the data form from Bob's Esession response.</p>
    <p class="" style="">Note: Alice SHOULD facilitate <a href="#sign-normal">XML Normalization</a> by <span style="font-style: italic">not</span> including empty "pkids" or "signs" fields.</p>
    <p class="" style="">Alice MAY also send encrypted content (see <a href="#exchange">Exchanging Stanzas</a>) in the same stanza as the Diffie-Hellman completion. Note: If she also includes a &lt;terminate/&gt; element (see <a href="#terminate">Esession Termination</a>) within the &lt;encrypted/&gt; element then the Esession is terminated immediately. This special case, where a single stanza is encrypted and sent in isolation, is equivalent to object encryption (or object signing if no encryption is specified).</p>
    <p class="caption">Example 8. Alice Completes Diffie-Hellman Negotitation (with PKID)</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;init xmlns='http://jabber.org/protocol/esession#init'&gt;
    &lt;x type='result' xmlns='jabber:x:data'&gt;
      &lt;field var="FORM_TYPE"&gt;&lt;value&gt;http://jabber.org/protocol/chatneg&lt;/value&gt;&lt;/field&gt;
      &lt;field var="key"&gt;&lt;value&gt; ** Base64 encoded value of e ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var="prev_hash"&gt;&lt;value&gt; ** Base64 encoded HASH of Bob's previous form ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var="pkids"&gt;&lt;value&gt; ** PKID ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var="signs"&gt;&lt;value&gt; ** signature of this form ** &lt;/value&gt;&lt;/field&gt;
    &lt;/x&gt;
  &lt;/init&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">If Bob provided a PKID but Alice did not provide a signature then he MAY send a failure notice to her. If Alice sent Bob a public key but he could not verify it belongs to her via secure out-of-band communication (see <a href="#sec-keys">Verifying Keys</a>) then he SHOULD send a failure notice to her. If Alice provided an invalid signature (see <a href="#sign">Signature Verification</a>), or an invalid HASH of his response form, or a value of e less than two, then he MUST send a failure notice to her. If Bob sends a failure notice then he SHOULD ignore any encrypted content in the stanza.</p>
    <p class="" style="">If no error occurs, Bob MUST calculate K = e<span class="super" style="">y</span> mod p (the shared secret). Alice and Bob then have the same value for K and the key exchange is complete.</p>
    </div>
  </div>

<div class="indent">
<h3>7.2 <a name="init-offline">Offline Diffie-Hellman Key Exchange</a>
</h3>
  <p class="" style="">As described below, offline negotiation of an Esession is in essence a special case of online negotiation. Bob MAY publish a set of Esession options just before he goes offline (see <a href="#sec-offline">Offline Esessions</a> Security Considerations) to allow entities that subscribe to his presence to initiate Esessions and send encrypted stanzas to him while he is offline. He MAY also publish <span style="font-style: italic">another</span> similar set of relatively long-lived  [<a href="#nt-id2260890">28</a>] Esession options that any entity MAY use for the same purpose.</p>
    <div class="indent">
<h3>7.2.1 <a name="init-offline-publish">Publishing Esession Options</a>
</h3>
      <p class="" style="">In order to publish either set of his offline Esession options Bob MUST perform the following steps:</p>
      <ol start="1" type="">
        <li><p class="" style="">Select a MODP group (that defines the constants p and g)</p></li>
        <li><p class="" style="">Generate a secret random number y (where 2<span class="super" style="">2n-1</span> &lt; y &lt; p - 1, where n is the largest number of bits per cipher block for the block cipher algorithms he is willing to use)</p></li>
        <li><p class="" style="">Calculate d = g<span class="super" style="">y</span> mod p</p></li>
        <li><p class="" style="">Publish each of the Esession options he is willing to use (see <a href="#init-request">Esession Request</a>) including the value of d. He SHOULD do this through his own server using the disco#publish-info feature (as <a href="http://mail.jabber.org/pipermail/standards-jig/2005-July/008131.html">NOT SPECIFIED</a> in <span style="font-weight: bold">JEP-0030</span>) or a similar protocol (out of scope for this JEP).</p></li>
        <li><p class="" style="">Calculate one or more hashes ("HASHES") of the <a href="#sign-normal">Normalized</a> <span style="font-style: italic">content</span> of the published data form (one for each of the hash algoritms he specified).</p></li>
        <li><p class="" style="">Store the value of y and the HASHES in a secure way, so that he can retrieve them when he comes back online (idealy even if that is using a different client and/or a different machine)</p></li>
      </ol>
      <p class="" style="">If Bob will not be able to decrypt stanzas if he comes back online using a different client and/or a different machine then he SHOULD publish the resource of this client in the 'match_resource' field of his Esession options.</p>
      <p class="" style="">Note: The single specified MODP group MUST be the one Bob used to generate d. The list of stanza types he is willing to decrypt MUST NOT include the value 'iq', and if he specifies a value in the 'match_resource' field then he MUST include only 'message'. Bob MUST also include the list of the PKIDs of all his public signature-verification keys that he can sign for, and the corresponding list of signatures (see <a href="#sign">Signature Generation</a>) of the <span style="font-style: italic">content</span> of the data form (excluding the 'signs' field).</p>
      <p class="" style=""><span style="font-style: italic">Note: This publishing protocol is highly preliminary and depends on a separate proposal.</span></p>
      <p class="caption">Example 9. Bob Publishes His Esession Options for His Subscribers</p>
<div class="indent"><pre>
&lt;iq type='set' from='bob@example.com/laptop' id='es2'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info-subscription'
         node='http://jabber.org/protocol/esession#subscription'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      &lt;field var="FORM_TYPE"&gt;
        &lt;value&gt;http://jabber.org/protocol/esession&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="match_resource"&gt;
        &lt;value&gt;laptop&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="logging"&gt;
        &lt;value&gt;0&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="modp"&gt;
        &lt;value&gt;2&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="crypt_algs"&gt;
        &lt;value&gt;aes256-ctr&lt;/value&gt;
        &lt;value&gt;twofish256-ctr&lt;/value&gt;
        &lt;value&gt;aes128-ctr&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="hash_algs"&gt;
        &lt;value&gt;whirlpool&lt;/value&gt;
        &lt;value&gt;sha256&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="compress"&gt;
        &lt;value&gt;none&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="stanzas"&gt;
        &lt;value&gt;message&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="secure"&gt;
        &lt;value&gt;0&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="rekey_freq"&gt;
        &lt;value&gt;1&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="key"&gt;
        &lt;value&gt; ** Base64 encoded value of d ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="pkids"&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="signs"&gt;
        &lt;value&gt; ** signature of form ** &lt;/value&gt;
        &lt;value&gt; ** signature of form ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
      <p class="" style="">Bob MAY publish his Esession options for all entities using the same protocol except for the 'xmlns' and 'node' attributes of the &lt;query/&gt; element:</p>
      <p class="caption">Example 10. Bob Publishes His Esession Options for All Entities</p>
<div class="indent"><pre>
&lt;iq type='set' from='bob@example.com/laptop' id='es2'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/esession'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      ...
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
    </div>
    <div class="indent">
<h3>7.2.2 <a name="init-offline-request">Requesting Offline Esession Options</a>
</h3>
      <p class="" style="">If Alice believes Bob is offline she SHOULD request his Esession options and his long-term public signature-verification keys (see <a href="#keys">Public Key Publication and Retrieval</a>) from his server.</p>
      <p class="" style="">If Alice is subscribing to Bob's presence she MUST request his Esession Options exclusively for subscribers.</p>
      <p class="caption">Example 11. Alice asks Bob's Server for his Esession Options (Subscribers)</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='alice@example.org/pda'
    to='bob@example.com'
    id='es3'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/esession#subscription'/&gt;
&lt;/iq&gt;
  </pre></div>
      <p class="" style="">If Alice is not subscribing to Bob's presence (or if Bob has no Esession Options exclusively for subscribers) she MUST use the following request instead.</p>
      <p class="caption">Example 12. Alice asks Bob's Server for his Esession Options (All Entities)</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='alice@example.org/pda'
    to='bob@example.com'
    id='es3'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/esession'/&gt;
&lt;/iq&gt;
  </pre></div>
      <p class="" style="">If, after receiving Bob's public keys and Esession options, Alice is unable to verify any of Bob's signatures (see <a href="#sign">Signature Verification</a>) then she MAY decide to proceed no further, since she cannot be sure who will be able to decrypt her stanzas.</p>
    </div>
    <div class="indent">
<h3>7.2.3 <a name="init-offline-prep">Diffie-Hellman Preparation (Offline)</a>
</h3>
      <p class="" style="">Alice MUST select one of the options from each of Bob's Esession fields including one hash algorithm ("HASH"). If she cannot support any of the options in a field (except the 'pkids' and 'signs' fields), or if the value of d is less than two, then she MUST NOT send encrypted stanzas to Bob while he is offline.</p>
      <p class="" style="">Alice MUST use the value of d and the MODP group specified in Bob's Esession options to perform the following steps (where n is the number of bits per cipher block for the selected block cipher algorithm):</p>
      <ol start="1" type="">
        <li><p class="" style="">Generate the initial value of C<span class="sub" style="">A</span> with n random bits (C<span class="sub" style="">A</span> is the block cipher counter for stanzas sent from Alice to Bob)</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> (where C<span class="sub" style="">B</span> is the block counter for stanzas sent from Bob to Alice  [<a href="#nt-id2261339">29</a>])</p></li>
        <li><p class="" style="">Generate a secret random number x (where 2<span class="super" style="">2n-1</span> &lt; x &lt; p - 1)</p></li>
        <li><p class="" style="">Calculate e = g<span class="super" style="">x</span> mod p</p></li>
        <li><p class="" style="">Calculate K = d<span class="super" style="">x</span> mod p (the shared secret)</p></li>
      </ol>
    </div>
    <div class="indent">
<h3>7.2.4 <a name="init-offline-start">Starting an Offline Esession</a>
</h3>
      <p class="" style="">Alice then sends Bob the Base64 encoded values of e and C<span class="sub" style="">A</span>. She SHOULD also include the list of the PKIDs of all her public signature-verification keys that she can sign for, and the corresponding list of signatures (see <a href="#sign">Signature Generation</a>) of the <span style="font-style: italic">content</span> of the data form (excluding the 'signs' field). She MUST also include the Base64 encoded HASH of the <a href="#sign-normal">Normalized</a> <span style="font-style: italic">content</span> of the data form from Bob's published Esession options.</p>
      <p class="" style="">She also specifies which of Bob's Esession options she selected. Note: The value of the 'rekey_freq' field MUST be less than 2<span class="super" style="">32</span> and greater than or equal to the value specified by Bob.</p>
      <p class="" style="">Alice MAY also send encrypted content (see the <a href="#exchange">Exchanging Stanzas</a> section of this document) in the same stanza. Note: If she also includes a &lt;terminate/&gt; element (see <a href="#terminate">Esession Termination</a>) within the &lt;encrypted/&gt; element then the Esession is terminated immediately. This special case, where a single stanza is encrypted and sent in isolation, is equivalent to object encryption (or object signing if no encryption is specified).</p>
      <p class="" style="">If Bob included a value in the 'match_resource' field of his Esession options, then Alice MUST address all the stanzas she sends within the offline Esession to the specified resource and use the <span style="font-weight: bold">Advanced Message Processing</span> protocol to ensure that they are not delivered to any other resource.</p>
      <p class="caption">Example 13. Alice Establishes an ESession Without Negotiation</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop' type='chat'&gt;
  &lt;init xmlns='http://jabber.org/protocol/esession#init'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      &lt;field var="FORM_TYPE"&gt;&lt;value&gt;http://jabber.org/protocol/esession&lt;/value&gt;&lt;/field&gt;
      &lt;field var="logging"&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var="modp"&gt;&lt;value&gt;2&lt;/value&gt;&lt;/field&gt;
      &lt;field var="crypt_algs"&gt;&lt;value&gt;aes256-ctr&lt;/value&gt;&lt;/field&gt;
      &lt;field var="hash_algs"&gt;&lt;value&gt;sha256&lt;/value&gt;&lt;/field&gt;
      &lt;field var="compress"&gt;&lt;value&gt;none&lt;/value&gt;&lt;/field&gt;
      &lt;field var="rekey_freq"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/field&gt;
      &lt;field var="stanzas"&gt;&lt;value&gt;message&lt;/value&gt;&lt;/field&gt;
      &lt;field var="secure"&gt;&lt;value&gt;0&lt;/value&gt;&lt;/field&gt;
      &lt;field var="counter"&gt;&lt;value&gt; ** Base64 encoded block counter ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var="key"&gt;&lt;value&gt; ** Base64 encoded value of e ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var="prev_hash"&gt;&lt;value&gt; ** Base64 encoded HASH of Bob's published form ** &lt;/value&gt;&lt;/field&gt;
      &lt;field var="pkids"&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
        &lt;value&gt; ** PKID ** &lt;/value&gt;
      &lt;/field&gt;
      &lt;field var="signs"&gt;
        &lt;value&gt; ** signature of form ** &lt;/value&gt;
        &lt;value&gt; ** signature of form ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/init&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
  &lt;amp xmlns='http://jabber.org/protocol/amp'&gt;
    &lt;rule action='??????' condition='match-resource' value='exact'/&gt;
  &lt;/amp&gt;
&lt;/message&gt;
    </pre></div>
      <p class="" style="">Alice can assume that she and Bob have the same value for K and that the key exchange is complete.</p>
    </div>
    <div class="indent">
<h3>7.2.5 <a name="init-offline-accept">Accepting Offline Esessions</a>
</h3>
      <p class="" style="">When Bob comes online he MUST perform the following steps:</p>
      <ol start="1" type="">
        <li>
<p class="" style="">Ensure he is no longer publishing offline Esession options exclusively for entities that are subscribing to his presence</p>
            <p class="caption">Example 14. Bob Stops Publishing His Esession Options</p>
<div class="indent"><pre>
&lt;iq type='set' from='bob@example.com/laptop' id='es4'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/esession#subscription'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'/&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
        </li>
        <li><p class="" style="">Retrieve any values of y and HASHES that he stored before going offline, and destroy in a secure way any persistently stored copies that correspond to Esession options exclusively for subscribers</p></li>
      </ol>
      <p class="" style="">When Bob receives a key exchange stanza from Alice then he MUST perform the following steps:</p>
      <ol start="1" type="">
        <li><p class="" style="">Confirm that her HASH of his published options form matches one of the HASHES he retrieved and select the associated value of y.  [<a href="#nt-id2261648">30</a>]</p></li>
        <li><p class="" style="">Confirm that he is prepared to support all the Esession options he received from Alice  [<a href="#nt-id2261664">31</a>]</p></li>
        <li><p class="" style="">Confirm that the value of e is greater than one</p></li>
        <li><p class="" style="">Confirm that he has not already received a key exchange stanza from Alice with the same value of e since he published his Esession options (see <a href="#sec-replay">Replay Attacks</a>). If the options were for subscribers, that means since he came online.</p></li>
        <li><p class="" style="">Request Alice's public keys and, if possible, verify one of her signatures (see <a href="#sign">Signature Verification</a>; if he is unable to verify any of her signatures then he MAY decide to proceed no further, since he cannot be sure who started the Esession)</p></li>
        <li><p class="" style="">Set the initial value of C<span class="sub" style="">A</span> to the counter value he received from Alice</p></li>
        <li><p class="" style="">Set C<span class="sub" style="">B</span> = C<span class="sub" style="">A</span> XOR 2<span class="super" style="">n-1</span> (to allow him to terminate the offline Esession)</p></li>
        <li><p class="" style="">Calculate K = e<span class="super" style="">y</span> mod p (the shared secret)</p></li>
      </ol>
    </div>
  </div>

  <div class="indent">
<h3>7.3 <a name="init-keys">Generating Session Keys</a>
</h3>
    <p class="" style="">Whichever method Alice used to perform the Diffie-Hellman key exchange (online or offline), once it is complete, then before Alice and Bob can start encrypting and decrypting stanzas they MUST both use the agreed hash algorithm ("HASH") and their full JIDs to generate two pairs of keys, one for each direction of the ESession. Note: JID<span class="sub" style="">B</span> MUST be Bob's bare JID throughout an offline Esession, even if he comes online in the middle of the Esession and the key is re-exchanged.</p>
    <p class="" style="">For stanzas that Alice will send to Bob, the keys are calculated as:</p>
    <ol start="1" type="">
      <li><p class="" style="">Encryption key K-C<span class="sub" style="">A</span> = HASH(K, JID<span class="sub" style="">A</span>)</p></li>
      <li><p class="" style="">Integrity key K-M<span class="sub" style="">A</span> = HASH(K-C<span class="sub" style="">A</span>, JID<span class="sub" style="">B</span>)  [<a href="#nt-id2261908">32</a>]</p></li>
    </ol>
    <p class="" style="">For stanzas that Bob will send to Alice the keys are calculated as:</p>
    <ol start="4" type="">
      <li><p class="" style="">Encryption key K-C<span class="sub" style="">B</span> = HASH(K, JID<span class="sub" style="">B</span>)</p></li>
      <li><p class="" style="">Integrity key K-M<span class="sub" style="">B</span> = HASH(K-C<span class="sub" style="">B</span>, JID<span class="sub" style="">A</span>)</p></li>
    </ol>
    <p class="" style="">Once the two pairs of keys have been calculated the value of K MUST be securely destroyed.</p>
    <p class="" style="">As many bits of key data as are needed MUST be taken from the least significant bits of the hash output. When negotiating a hash, entities MUST ensure that the hash output is no shorter than the required key data. For algorithms with variable-length keys the maximum length (up to the hash output length) SHOULD be used.</p>

    <p class="" style="">With these keys computed and the algorithms agreed upon, ESession initiation is now complete. From this point forward, Alice and Bob MUST exchange only encrypted forms of the one-to-one stanza types they agreed upon (e.g., &lt;message/&gt; and &lt;iq/&gt; stanzas).</p>
  </div>
<h2>8.
       <a name="exchange">Exchanging Stanzas</a>
</h2>
  <div class="indent">
<h3>8.1 <a name="exchange-separate">Encryptable Content</a>
</h3>
    <p class="" style="">Once an Esession has been established, whenever Alice wants to send Bob an encrypted stanza she MUST only encrypt the XML content that would normally be ignored by the intermediate servers. She MUST NOT encrypt stanza wrapper elements or <span style="font-weight: bold">Advanced Message Processing</span> elements.</p>
    <p class="" style="">If this is an offline Esession then Alice SHOULD include a 'Created' SHIM header in the encrypted content. Bob SHOULD trust this header and ignore the unencrypted <span class="ref" style="">Delayed Delivery</span>  [<a href="#nt-id2262113">33</a>] element inserted by his server.</p>

  <p class="caption">Example 15. Unencrypted Stanza</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda'
         to='bob@example.com/laptop'
         type='chat'&gt;
  &lt;body&gt;Hello, Bob!&lt;/body&gt;
  &lt;amp xmlns='http://jabber.org/protocol/amp'&gt;
    &lt;rule action='error' condition='match-resource' value='exact'/&gt;
  &lt;/amp&gt;
  &lt;headers xmlns='http://jabber.org/protocol/shim'&gt;
    &lt;header name='Created'&gt;2005-02-10T03:01:52Z&lt;/header&gt;
  &lt;/headers&gt;
  &lt;active xmlns='http://jabber.org/protocol/chatstates'/&gt;
&lt;/message&gt;
</pre></div>

  <p class="caption">Example 16. XML Content to be Encrypted</p>
<div class="indent"><pre>
&lt;body&gt;Hello, Bob!&lt;/body&gt;
&lt;headers xmlns='http://jabber.org/protocol/shim'&gt;
  &lt;header name='Created'&gt;2005-02-10T03:01:52Z&lt;/header&gt;
&lt;/headers&gt;
&lt;active xmlns='http://jabber.org/protocol/chatstates'/&gt;
</pre></div>
  </div>
  <div class="indent">
<h3>8.2 <a name="exchange-encrypt">Encryption</a>
</h3>

    <p class="" style="">Alice MUST perform the following steps to encrypt the XML content. Note: if there is no XML content to be encrypted (e.g. if this is an empty <a href="#rekey">Re-Keying</a> or <a href="#terminate">Termination</a> stanza), then C<span class="sub" style="">A</span> MUST be incremented by 1 (see below), and only the last two steps (normalization and MAC calculation) should be performed.</p>
    <ol start="1" type="">
      <li><p class="" style="">Serialize the XML content she wishes to send into an array of UTF-8 bytes, m.  [<a href="#nt-id2262192">34</a>]</p></li>
      <li>
        <p class="" style="">Compress m using the negotiated algorithm. If a compression algorithm other than 'none' was agreed, the compression context is typically initialized after key exchange and passed from one stanza to the next, with only a partial flush at the end of each stanza.  [<a href="#nt-id2262211">35</a>]</p>
        <p class="caption"></p>
<div class="indent"><pre>m_compressed = compress(m)</pre></div>
      </li>
      <li>
        <p class="" style="">Encrypt the data with the agreed algorithm in counter mode (see <span class="ref" style=""> Recommendation for Block Cipher Modes of Operation</span>  [<a href="#nt-id2262253">36</a>]), using the encryption key K-C<span class="sub" style="">A</span>. Note: C<span class="sub" style="">A</span> MUST be incremented by 1 for each encrypted block or partial block (i.e. C<span class="sub" style="">A</span> = (C<span class="sub" style="">A</span> + 1) mod 2<span class="super" style="">n</span>, where n is the number of bits per cipher block for the agreed block cipher algorithm). Note: if the block cipher algorithm 'none' was agreed (see <a href="#sec-unencrypted">Unencrypted Esessions</a>) then encryption MUST NOT be performed and C<span class="sub" style="">A</span> MUST be incremented by 1 (for replay protection).</p>
        <p class="caption"></p>
<div class="indent"><pre>m_final = encrypt(K-C<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, m_compressed)</pre></div>
      </li>
      <li>
        <p class="" style="">Alice MUST now create the <a href="#sign-normal">Normalized</a> XML <span style="font-style: italic">content</span> of the &lt;encrypted/&gt; XML element. If there is encrypted XML content, the XML MUST include the Base64 encoded value of m_final wrapped in a &lt;data/&gt; element. Note: it MAY also contain one &lt;terminate/&gt; element (see <a href="#terminate">Termination</a>), one &lt;key/&gt; element and one or more &lt;old/&gt; elements (see <a href="#rekey">Re-Keying</a>).</p>
        <p class="caption"></p>
<div class="indent"><pre>m_content = '&lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;'</pre></div>
      </li>
      <li>
        <p class="" style="">The XML content and the value of Alice's block cipher counter C<span class="sub" style="">A</span> <span style="font-style: italic">before</span> the data was encrypted, are now processed through the HMAC algorithm (as defined in Section 2 of <span class="ref" style="">RFC 2104</span>  [<a href="#nt-id2262441">37</a>]), along with the agreed hash algorithm ("HASH") and the integrity key K-M<span class="sub" style="">A</span>.</p>
        <p class="caption"></p>
<div class="indent"><pre>a_mac = HMAC(HASH, K-M<span class="sub" style="">A</span>, m_content, C<span class="sub" style="">A</span>)</pre></div>
      </li>
    </ol>

  </div>
  <div class="indent">
<h3>8.3 <a name="exchange-send">Sending an Encrypted Stanza</a>
</h3>
    <p class="" style="">Before sending the stanza to Bob, Alice MUST wrap m_content and the Base64 encoded value of a_mac (wrapped in a &lt;mac/&gt; element) inside an &lt;encrypted/&gt; element and insert it into the stanza in place of the original content. There MUST NOT be more than one &lt;encrypted/&gt; element per stanza.</p>
    <p class="caption">Example 17. Message Stanza with Encrypted Content</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda'
         to='bob@example.com/laptop'
         type='chat'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
  &lt;amp xmlns='http://jabber.org/protocol/amp' per-hop='true'&gt;
    &lt;rule action='error' condition='match-resource' value='exact'/&gt;
  &lt;/amp&gt;
&lt;/message&gt;
    </pre></div>
  </div>
  <div class="indent">
<h3>8.4 <a name="exchange-decrypt">Decryption</a>
</h3>

    <p class="" style="">When Bob receives the stanza from Alice, he extracts and Base64 decodes the values of m_final and a_mac from the content and performs the following steps.</p>
    <ol start="1" type="">
      <li>
        <p class="" style="">Remove the &lt;mac/&gt; element from the &lt;encrypted/&gt; element and <a href="#sign-normal">Normalize</a> the remaining XML <span style="font-style: italic">content</span>. Calculate the Message Authentication Code (MAC) for the content.</p>
        <p class="caption"></p>
<div class="indent"><pre>b_mac = HMAC(HASH, K-M<span class="sub" style="">A</span>, m_content, C<span class="sub" style="">A</span>)</pre></div>
      </li>
      <li>
        <p class="" style="">Verify that b_mac and a_mac match. If they are not identical, the content has been tampered with and Bob MUST terminate the ESession, he MAY send a &lt;not-acceptable/&gt; error to Alice.  [<a href="#nt-id2260693">38</a>]</p>
      </li>
      <li>
        <p class="" style="">Decrypt m_final using the agreed algorithm, K-C<span class="sub" style="">A</span> and C<span class="sub" style="">A</span>. Note: C<span class="sub" style="">A</span> MUST be incremented by 1 for each decrypted block (see <a href="#exchange-encrypt">Encryption</a>). Note: if the block cipher algorithm 'none' was agreed decryption MUST NOT be performed and C<span class="sub" style="">A</span> MUST be incremented by 1.</p>
        <p class="caption"></p>
<div class="indent"><pre>m_compressed = decrypt(K-C<span class="sub" style="">A</span>, C<span class="sub" style="">A</span>, m_final)</pre></div>
      </li>
      <li>
        <p class="" style="">Decompress m_compressed using the negotiated algorithm (usually 'none').</p>
        <p class="caption"></p>
<div class="indent"><pre>m = decompress(m_compressed)</pre></div>
      </li>
      <li>
        <p class="" style="">Replace the &lt;encrypted/&gt; element in the serialized XML stanza with m and feed the stanza into an XML parser. If the parser returns an XML format error then Bob MUST terminate the ESession, he MAY send a &lt;not-acceptable/&gt; error to Alice.  [<a href="#nt-id2262598">39</a>]</p>
      </li>
    </ol>
  </div>
  <h2>9.
       <a name="rekey">Re-Key Exchange</a>
</h2>
<p class="" style="">Once an attacker has discovered an encryption key it could be used to decrypt all stanzas within a session, including stanzas that were intercepted <span style="font-style: italic">before</span> the key was discovered. To reduce the window of vulnerability, both Alice and Bob SHOULD change their values of x and y and re-exchange the encryption key as regularly as possible. They MUST also destroy all copies of keys as soon as they are no longer needed.</p>
<p class="" style="">Note: Although most entities are capable of re-keying after each stanza, clients running in constrained runtime environments may require a few seconds to re-key. During Esession initiation these clients MAY negotiate the minimum number of stanzas to be exchanged between re-keys at the cost of a larger window of vulnerability. Entities MUST NOT initiate key re-exchanges more frequently than the agreed limit.</p>

  <div class="indent">
<h3>9.1 <a name="rekey-init">Re-Key Initiation</a>
</h3>
    <p class="" style="">Either Alice or Bob MAY initiate a key re-exchange. Here we describe the process initiated by Alice. First she MUST calculate new values for the encryption parameters:</p>
    <ol start="1" type="">
      <li><p class="" style="">Generate a secret random number x (where 2<span class="super" style="">2n-1</span> &lt; x &lt; p - 1, where n is the number of bits per cipher block for the agreed block cipher algorithm)</p></li>
      <li><p class="" style="">Calculate e = g<span class="super" style="">x</span> mod p</p></li>
      <li><p class="" style="">Calculate K = d<span class="super" style="">x</span> mod p (the new shared secret)</p></li>
      <li><p class="" style="">Calculate K-C<span class="sub" style="">A</span>, K-M<span class="sub" style="">A</span>, K-C<span class="sub" style="">B</span>, K-M<span class="sub" style="">B</span> (see <a href="#init-keys">Generating Session Keys</a>)</p></li>
    </ol>
    <p class="" style="">To avoid extra stanzas, the new value of e SHOULD be sent to Bob along with an encrypted stanza. Note: Alice MUST NOT use the new K-C<span class="sub" style="">A</span> and K-M<span class="sub" style="">A</span> to encrypt this stanza or to calculate the MAC. However, she MUST use them when sending subsequent stanzas.</p>
    <p class="" style="">Note: There is no need for Alice to provide a signature because the calculation of the MAC includes the new value of e, see <a href="#exchange">Exchanging Stanzas</a>).</p>
    <p class="caption">Example 18. Alice Sends Re-Key Stanza</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;key&gt; ** Base64 encoded value of new e ** &lt;/key&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">Note: Bob may not receive the new key before he sends his next stanzas (they may cross in transit). So, before destroying her old values of K-C<span class="sub" style="">B</span> and K-M<span class="sub" style="">B</span>, Alice MUST wait until either she receives a stanza encrypted with the new key, or a reasonable time has passed (60 seconds should cover a network round-trip and calculations by a constrained client). Similarly she MUST wait before destroying her old value of x, in case Bob sends two stanzas before receiving Alice's new key (the first stanza might include a re-key).</p>
  </div>
  <div class="indent">
<h3>9.2 <a name="rekey-accept">Re-Key Acceptance</a>
</h3>
    <p class="" style="">After Bob receives a stanza with a new value of e and confirmed it is greater than one, and he has decrypted the stanza with the old value of K-C<span class="sub" style="">A</span>, he MUST securely destroy all copies of K-C<span class="sub" style="">A</span> and K-C<span class="sub" style="">B</span> and perform the following calculations with the new value of e:</p>
    <ol start="1" type="">
      <li><p class="" style="">Calculate K = e<span class="super" style="">y</span> mod p</p></li>
      <li><p class="" style="">Calculate K-C<span class="sub" style="">A</span>, K-M<span class="sub" style="">A</span>, K-C<span class="sub" style="">B</span>, K-M<span class="sub" style="">B</span> (see <a href="#init-keys">Generating Session Keys</a>)</p></li>
    </ol>
    <p class="" style="">He MUST use these new values to encrypt and decrypt all subsequent stanzas.  [<a href="#nt-id2263143">40</a>]</p>
    <p class="" style="">The next time Bob sends Alice a stanza he MUST specify the number of rekeys he has received from her since he sent her his last stanza. He does that by setting the 'rekeys' attribute of the &lt;data/&gt; element. Note: The default value of the 'rekeys' attribute is zero.</p>
    <p class="caption">Example 19. Bob's First Stanza After Receiving a Re-Key</p>
<div class="indent"><pre>
&lt;message from='bob@example.com/laptop' to='alice@example.org/pda'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data rekeys='1'&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;mac&gt; ** Base64 encoded b_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">When Alice receives the stanza from Bob she MUST use the 'rekeys' attribute to decide which of her values of K-C<span class="sub" style="">B</span> and K-M<span class="sub" style="">B</span> (or x) she should use to decrypt the stanza - otherwise she would not know if Bob received her rekey(s) before he sent the stanza. Once she is sure Bob has received her rekey(s) she MUST discard all her older values of K-C<span class="sub" style="">B</span>, K-M<span class="sub" style="">B</span> and x.</p>
  </div>
  <div class="indent">
<h3>9.3 <a name="rekey-publish">Publishing Old MAC Values</a>
</h3>
    <p class="" style="">Once the expired MAC keys have been published, anyone could create valid arbitrary stanzas with them. This prevents anyone being able to prove the authenticity of a transcript of the Esession in the future.</p>
    <p class="" style="">Either entity MAY publish old values of K-M<span class="sub" style="">A</span> and/or K-M<span class="sub" style="">B</span> within any encrypted stanza as long as it knows that all the stanzas that MAY use the old values have been received and validated. Note: A 'man-in-the-middle' could delay the delivery of stanzas indefinitely. So, before Alice publishes K-M<span class="sub" style="">A</span> (and K-M<span class="sub" style="">B</span>), she MUST wait until she has both sent a re-key to Bob and received a stanza from Bob encrypted with her new key. (She MAY also publish K-M<span class="sub" style="">B</span> after she has received a re-key from Bob.)</p>
    <p class="caption">Example 20. Publishing Expired MAC Keys</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;data&gt; ** Base64 encoded m_final ** &lt;/data&gt;
    &lt;old&gt; ** Base64 encoded old MAC key ** &lt;/old&gt;
    &lt;old&gt; ** Base64 encoded old MAC key ** &lt;/old&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">Entities SHOULD ignore any &lt;old/&gt; elements they receive.</p>
  </div>
  <h2>10.
       <a name="terminate">Esession Termination</a>
</h2>
    <p class="" style="">Either entity MAY terminate an Esession at any time. Entities MUST terminate all open Esessions before they go offline. To terminate an Esession Alice MUST send a stanza to Bob including a &lt;terminate/&gt; element with content "1"  [<a href="#nt-id2263350">41</a>]. Note: She MAY publish old values of K-M<span class="sub" style="">A</span> and/or K-M<span class="sub" style="">B</span> within her termination stanza as long as she is sure all the stanzas that MAY use the old values have been received and validated (see <a href="#rekey-publish">Publishing Old MAC Values</a>). She MUST then securely destroy all keys associated with the Esession.</p>
    <p class="caption">Example 21. Alice Terminates an Esession</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;terminate&gt;1&lt;/terminate&gt;
    &lt;old&gt; ** Base64 encoded old MAC key ** &lt;/old&gt;
    &lt;mac&gt; ** Base64 encoded a_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">When Bob receives a termination stanza he MUST verify the MAC (to be sure he received all the stanzas Alice sent him during the Esession) and, if the stanza was sent to him while he was online, immediately send a termination stanza back to Alice. Note: He MAY publish <span style="font-style: italic">any</span> old values of K-M<span class="sub" style="">A</span> or K-M<span class="sub" style="">B</span> within the termination stanza. He MUST then securely destroy all keys associated with the Esession.</p>
    <p class="caption">Example 22. Bob Confirms Esession Termination</p>
<div class="indent"><pre>
&lt;message from='alice@example.org/pda' to='bob@example.com/laptop'&gt;
  &lt;encrypted xmlns='http://jabber.org/protocol/esession'&gt;
    &lt;terminate&gt;1&lt;/terminate&gt;
    &lt;old&gt; ** Base64 encoded old MAC key ** &lt;/old&gt;
    &lt;mac&gt; ** Base64 encoded b_mac ** &lt;/mac&gt;
  &lt;/encrypted&gt;
&lt;/message&gt;
    </pre></div>
    <p class="" style="">When Alice receives the stanza she MUST verify the MAC to be sure she received all the stanzas Bob sent her during the Esession. Once an entity has sent a termination stanza it MUST NOT send another stanza within the Esession.</p>
    <p class="" style="">Note: If Alice notices that Bob comes online during her offline Esession with him then she MUST terminate the Esession immediately. If required she may then negotiate a new (more secure) online Esession.</p>
    <p class="" style="">Note: Bob MUST NOT send encrypted content within an Esession started by Alice. If Alice is conducting an offline Esession with Bob when he is online (e.g., if she is not subscribing to his presence), then if Bob wants to send a stanza to Alice, he MUST terminate the offline Esession and start a new online Esession first.</p>
  <h2>11.
       <a name="sign">Signature Generation and Verification</a>
</h2>
  <div class="indent">
<h3>11.1 <a name="sign-normal">XML Normalization</a>
</h3>
    <p class="" style="">Before the signature or MAC of a block of XML is generated or verified, all character data <span style="font-style: italic">between</span> all elements MUST be removed and the XML MUST be converted to canonical form (see <span class="ref" style="">Canonical XML</span>  [<a href="#nt-id2263537">42</a>]).</p>
    <p class="" style="">All the XML this protocol requires to be signed or MACed is very simple, so in this case, canonicalization SHOULD only require the following changes:</p>
    <ul>
      <li>Set attribute value delimiters to quotation marks (i.e. simply replace all single quotes in the serialized XML with double quotes)</li>
      <li>Impose lexicographic order on the attributes of "field" elements (i.e. ensure "type" is before "var")</li>
    </ul>
    <p class="" style="">Implementations MAY conceivably also need to make the following changes. Note: Empty elements and special characters SHOULD NOT appear in the signed or MACed XML specified in this protocol.</p>
    <ul>
      <li>Ensure there are no character references</li>
      <li>Convert empty elements to start-end tag pairs</li>
      <li>Ensure there is no whitespace except for single spaces before attributes</li>
    </ul>
  </div>
  <div class="indent">
<h3>11.2 <a name="sign-hash">Hash</a>
</h3>
    <p class="" style="">Before the signature or MAC of a block of XML is generated or verified, the agreed hash algorithm MUST be used to generate the hash of the normalized XML.</p>
    <p class="caption"></p>
<div class="indent"><pre>m_hash = HASH(m_content)</pre></div>
  </div>
  <div class="indent">
<h3>11.3 <a name="sign-calc">Generation</a>
</h3>
    <p class="" style="">The signature generation depends on the type of private key being used.</p>
    <div class="indent">
<h3>11.3.1 <a name="sign-rsa-gen">RSA</a>
</h3>
      <p class="caption"></p>
<div class="indent"><pre>signature_rsa = rsa_sign(rsa_private_key, m_hash, hashOID)</pre></div>
      <p class="" style="">The multiprecision integer signature_rsa is the signature (see <span class="ref" style="">RFC 3447</span>  [<a href="#nt-id2263662">43</a>]).</p>
    </div>
    <div class="indent">
<h3>11.3.2 <a name="sign-dsa-gen">DSA</a>
</h3>
      <p class="caption"></p>
<div class="indent"><pre>sig_dsa_r, sig_dsa_s = dsa_sign(dsa_private_key, m_hash)</pre></div>
      <p class="" style="">The multiprecision integers sig_dsa_r and sig_dsa_s are the signature (see <span class="ref" style="">Digital Signature Standard</span>  [<a href="#nt-id2263715">44</a>]).</p>
    </div>
  </div>
  <div class="indent">
<h3>11.4 <a name="sign-format">Signature Format</a>
</h3>
    <p class="" style="">The signature formats are the same for all public key formats. All integers are stored in big-endian byte order.</p>
    <div class="indent">
<h3>11.4.1 <a name="sign-rsa-format">RSA</a>
</h3>
      <p class="" style="">Base64 encoding of the signature_rsa multiprecision integer (without any header or length prefix).</p>
    </div>
    <div class="indent">
<h3>11.4.2 <a name="sign-dsa-format">DSA</a>
</h3>
      <p class="" style="">Base64 encoding of the following structure:</p>
      <ul>
        <li>number of bytes in sig_dsa_r (2-byte integer)</li>
        <li>sig_dsa_r</li>
        <li>number of bytes in sig_dsa_s (2-byte integer)</li>
        <li>sig_dsa_s</li>
      </ul>
    </div>
  </div>
  <div class="indent">
<h3>11.5 <a name="sign-calc">Verification</a>
</h3>
    <p class="" style="">The signature verification depends on the type of public key being used.</p>
    <div class="indent">
<h3>11.5.1 <a name="sign-rsa-verify">RSA</a>
</h3>
      <p class="" style="">The rsa_modulus and rsa_public_exponent multiprecision integers are extracted from the other entity's authenticated public key. The signature_rsa multiprecision integer is the signature received from the other entity.</p>
      <p class="caption"></p>
<div class="indent"><pre>boolean = rsa_verify(signature_rsa, m_hash, hashOID, rsa_modulus, rsa_public_exponent)</pre></div>
    </div>
    <div class="indent">
<h3>11.5.2 <a name="sign-dsa-verify">DSA</a>
</h3>
      <p class="" style="">The dsa_p, dsa_q, dsa_g and dsa_y multiprecision integers are extracted from the other entity's authenticated public key. The sig_dsa_r and sig_dsa_s multiprecision integers are the signature received from the other entity.</p>
      <p class="caption"></p>
<div class="indent"><pre>boolean = dsa_verify(sig_dsa_r, sig_dsa_s, m_hash, dsa_p, dsa_q, dsa_g, dsa_y)</pre></div>
    </div>
  </div>
  <h2>12.
       <a name="sec">Security Considerations</a>
</h2>
  <div class="indent">
<h3>12.1 <a name="sec-prng">Random Numbers</a>
</h3>
    <p class="" style="">Weak pseudo-random number generators (PRNG) enable successful attacks. Implementors MUST use a cryptographically strong PRNG to generate all random numbers (see <span class="ref" style="">RFC 1750</span>  [<a href="#nt-id2263895">45</a>]).</p>
  </div>
  <div class="indent">
<h3>12.2 <a name="sec-rekey">Re-Keying Limits</a>
</h3>
    <p class="" style="">After a key exchange an entity MUST NOT exchange a total of 2<span class="super" style="">32</span> encrypted blocks before it initiates a key re-exchange (see <span class="ref" style="">SSH Transport Layer Encryption Modes</span>  [<a href="#nt-id2263942">46</a>]). Note: This limitation also ensures the same key and counter values are never used to encrypt two different blocks using counter mode (thus preventing simple attacks).</p>
    <p class="" style="">In order to reduce the Perfect Forward Secrecy window of vulnerability, after an extended period of activity, entities SHOULD either re-key or terminate the Esession.</p>
  </div>
  <div class="indent">
<h3>12.3 <a name="sec-keys">Verifying Keys</a>
</h3>
    <p class="" style="">The trust system outlined in this document is based on Alice trusting that the public key presented by Bob is <span style="font-style: italic">actually</span> Bob's key (and vice versa). Determining this trust may be done in a variety of ways depending on the entities' support for different public key (certificate) formats, signing algorithms and signing authorities. For instance, if Bob publishes a PGP/GPG public key, Alice MAY verify that his key is signed by another key that she knows to be good. Or, if Bob provides an X.509 certificate, she MAY check that his key has been signed by a Certificate Authority that she trusts.</p>
    <p class="" style="">When trust cannot be achieved automatically, methods that are not transparent to the users may be employed. For example, Bob could communicate the SHA-256 fingerprint of his public key to Alice via secure out-of-band communication (e.g. face-to-face). This would enable Alice to confirm that the public key she receives in-band is valid. Note however that very few people bother to verify fingerprints in this way. So this method is exceptionally vulnerable to 'man-in-the-middle' attacks. In order to reduce the window of vulnerability, an entity SHOULD remember the fingerprints of all user-validated public keys and alert the user in the future if ever the fingerprint(s) it stored for an entity do not match any of the received public keys.</p>
    <p class="" style="">Alternatively Alice and Bob could agree a shared secret via secure out-of-band communication, Bob could then use it to create an HMAC of his public key that only Alice could verify.</p>
    <p class="" style="">Note: If no keys are acceptable to Alice (because Alice has never verified any of the keys, and because either the keys are not signed, or Alice does not support the signature algorithms of the keys, or she cannot parse the certificate formats, or she does not recognise the authorities that signed the keys) then, although the Esession can still be encrypted, she cannot be sure she is communicating with Bob.</p>
  </div>
  <div class="indent">
<h3>12.4 <a name="sec-replay">Replay Attacks</a>
</h3>
    <p class="" style="">The block cipher counters maintained implicitly by Alice and Bob (C<span class="sub" style="">A</span> and C<span class="sub" style="">B</span>) prevent stanzas being replayed within any Esession. They ensure that the MAC will be different for all stanzas, even if the HMAC key and the content of the stanza are identical.</p>
    <p class="" style="">Alice and Bob MUST ensure that the value of e or d they provide when negotiating each online Esession is unique. This prevents complete online Esessions being replayed.</p>
    <p class="" style="">Since Bob supplies the same value of d for all offline Esessions, to prevent complete offline Esessions being replayed to him, he MUST take care to securely store <span style="font-style: italic">new</span> values (or destroy existing values) of y and HASHES for subscribers whenever he goes offline (see <a href="#init-publish">Publishing Esession Options</a>). Also, when Bob comes online again, he MUST remember all the values of e he receives in offline Esession initiation stanzas, and reject any offline Esessions that specify a value of e he has already received (see <a href="#init-accept">Accepting an Offline Esession</a>).</p>
    <p class="" style="">Note: If Bob publishes Esession options for non-subscribers, and if he does not update them whenever he comes online then, until he updates the options, he MUST save all the values of e he receives to secure persistent storage (along with the values of y and HASHES).</p>
  </div>
  <div class="indent">
<h3>12.5 <a name="sec-unencrypted">Unencrypted Esessions</a>
</h3>
    <p class="" style="">Organisations with full disclosure policies may require entities to disable encryption to enable the logging of all messages on their server. Unencrypted Esessions meet all the <a href="#reqs-sec">Security Requirements</a> except for Confidentiality. This enables Alice to use the 'secure' Esession option to confirm securely with Bob that both client-server connections are secure.</p>
  </div>
  <div class="indent">
<h3>12.6 <a name="sec-storage">Storage</a>
</h3>
    <p class="" style="">If either entity stores a (re-encrypted) transcript of an Esession for future consultation then the Perfect Forward Secrecy offered by this protocol is lost. If the negotiated value of the 'logging' <span style="font-weight: bold">Chat Session Negotiation</span> field is false the entities SHOULD NOT store any part of the Esession content (not even in encrypted form).</p>
  </div>
  <div class="indent">
<h3>12.7 <a name="sec-offline">Offline Esessions</a>
</h3>
    <p class="" style="">Bob MAY decide not to support Offline Esessions since they are significantly less secure than online Esessions. The Perfect Forward Secrecy window of vulnerability is much longer. More seriously, Bob MUST store his private Diffie-Hellman key, y, to local disk or to a server (perhaps symmetrically encrypted with a password). It is <span style="font-style: italic">really</span> hard to securely erase something from a disk. Note: If Bob does not support Offline Esessions then, while he is offline, Alice will probably send him completely unprotected messages!</p>
  </div>
  <div class="indent">
<h3>12.8 <a name="sec-general">Extra Responsabilities of Implementors</a>
</h3>
    <p class="" style="">Cryptography plays only a small part in an entity's security. Even if it implements this protocol perfectly it may still be vulnerable to other attacks. For examples, an implementation might store Esession keys on swap space or save private keys to a file in cleartext! Implementors MUST take very great care when developing applications with secure technologies.</p>
  </div>
  <div class="indent">
<h3>12.9 <a name="sec-mandatory">Mandatory to Implement Technologies</a>
</h3>
    <p class="" style="">An implementation of ESession MUST support the Diffie-Hellman Key Agreement and HMAC algorithms. Note: The parameter names mentioned below are related to secure shell; see <span style="font-weight: bold">SSH Transport Layer Encryption Modes</span> for block cipher algorithm details; see the <span class="ref" style="">IANA Secure Shell Protocol Parameters Registry</span>  [<a href="#nt-id2264270">47</a>] for other names.</p>
    <div class="indent">
<h3>12.9.1 <a name="sec-mandatory-encryption">Block Cipher Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support at least the following block cipher algorithm:</p>
      <ul>
        <li>aes128-ctr (see <span class="ref" style="">Advanced Encryption Standard</span>  [<a href="#nt-id2264318">48</a>])</li>
      </ul>
      <p class="" style="">The block length of an block cipher algorithm's cipher SHOULD be at least 128 bits. An implementation of ESession MAY also support the following block cipher algorithms:</p>
      <ul>
        <li>aes256-ctr</li>
        <li>aes192-ctr</li>
        <li>twofish256-ctr (see <span class="ref" style="">Twofish</span>  [<a href="#nt-id2264362">49</a>])</li>
        <li>twofish192-ctr</li>
        <li>twofish128-ctr</li>
        <li>serpent256-ctr (see <span class="ref" style="">Serpent</span>  [<a href="#nt-id2264399">50</a>])</li>
        <li>serpent192-ctr</li>
        <li>serpent128-ctr</li>
        <li>none (no encryption, only signing)</li>
      </ul>
    </div>
    <div class="indent">
<h3>12.9.2 <a name="sec-mandatory-sign">Key Signing Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support at least the following signing algorithm:</p>
      <ul>
        <li>rsa (see <span style="font-weight: bold">RFC 3447</span>)</li>
      </ul>
      <p class="" style="">An implementation of ESession SHOULD also support at least the following signing algorithm:</p>
      <ul>
        <li>dsa (see <span style="font-weight: bold">Digital Signature Standard</span>)</li>
      </ul>
    </div>
    <div class="indent">
<h3>12.9.3 <a name="sec-mandatory-public">Public Signature-Verification-Key Formats</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support the following public key formats:</p>
      <ul>
        <li>ssh-rsa</li>
      </ul>
      <p class="" style="">An implementation of ESession SHOULD also support at least the following public key formats:</p>
      <ul>
        <li>ssh-dss</li>
        <li>x509v3-sign-rsa (see <span class="ref" style="">X.509 Authentication in SSH2</span>  [<a href="#nt-id2264514">51</a>])</li>
        <li>x509v3-sign-dss</li>
        <li>pgp-sign-rsa</li>
        <li>pgp-sign-dss</li>
      </ul>
      <p class="" style="">An implementation of ESession MAY also support the following public key formats:</p>
      <ul>
        <li>spki-sign-rsa</li>
        <li>spki-sign-dss</li>
      </ul>
    </div>
    <div class="indent">
<h3>12.9.4 <a name="sec-mandatory-hash">Hash Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support the following hash algorithm:</p>
      <ul>
        <li>sha256 (see <span class="ref" style="">Secure Hash Standard</span>  [<a href="#nt-id2264591">52</a>])</li>
      </ul>
      <p class="" style="">An implementation of ESession SHOULD also support at least the following hash algorithm (sha1 and md5 are NOT RECOMMENDED):</p>
      <ul>
        <li>whirlpool (see <span class="ref" style="">Whirlpool</span>  [<a href="#nt-id2264634">53</a>])</li>
      </ul>
    </div>
    <div class="indent">
<h3>12.9.5 <a name="sec-mandatory-compress">Compression Algorithms</a>
</h3>
      <p class="" style="">An implementation of ESession MUST support the following compression algorithm:</p>
      <ul>
        <li>none (no compression, the output MUST be the same as the input)</li>
      </ul>
      <p class="" style="">Support for other algorithms is NOT RECOMMENDED since compression partially defeats the <a href="#reqs-repudiate">Repudiability</a> requirement of this JEP by making it more difficult for a third party (with some knowledge of the plaintext) to modify a transcript of an encrypted session in a meaningful way. However, encrypted content is pseudo-random and cannot be compressed, so, in those cases where bandwidth is severely constrained, an implementation of ESession MAY support the following algorithm to compress content before it is encrypted:</p>
      <ul>
        <li>zlib (see <span class="ref" style="">RFC 1950</span>  [<a href="#nt-id2264704">54</a>])</li>
      </ul>
    </div>
  </div>
<h2>13.
       <a name="iana">IANA Considerations</a>
</h2>
  <p class="" style="">This JEP requires no interaction with the <span class="ref" style="">Internet Assigned Numbers Authority (IANA)</span>  [<a href="#nt-id2264745">55</a>]. </p>
<h2>14.
       <a name="registrar">Jabber Registrar Considerations</a>
</h2>
  <div class="indent">
<h3>14.1 <a name="registrar-ns">Namespaces</a>
</h3>
    <p class="" style="">Upon approval of this JEP, the <span class="ref" style="">Jabber Registrar</span>  [<a href="#nt-id2264792">56</a>] shall register the following namespaces:</p>
    <ul>
      <li>http://jabber.org/protocol/esession</li>
      <li>http://jabber.org/protocol/esession#init</li>
      <li>http://jabber.org/protocol/esession#error</li>
    </ul>
  </div>
  <div class="indent">
<h3>14.2 <a name="registrar-formtype">Field Standardization</a>
</h3>
    <p class="" style=""><span class="ref" style="">Field Standardization for Data Forms</span>  [<a href="#nt-id2264853">57</a>] defines a process for standardizing the fields used within Data Forms qualified by a particular namespace. The following fields shall be registered for use in <span style="font-style: italic">both</span> Encrypted Sessions and Chat Session Negotiation:</p>
    <p class="caption">Registry Submission</p>
<div class="indent"><pre>
&lt;form_type&gt;
  &lt;name&gt;http://jabber.org/protocol/esession&lt;/name&gt;
  &lt;jep&gt;JEP-0116&lt;/jep&gt;
  &lt;desc&gt;ESession negotiation forms&lt;/desc&gt;
  &lt;field
      var='match_resource'
      type='text-single'
      label='Target resource for offline Esessions'/&gt;
  &lt;field
      var='modp'
      type='list-single'
      label='MODP group number'/&gt;
  &lt;field
      var='crypt_algs'
      type='list-single'
      label='Symmetric block cipher options'/&gt;
  &lt;field
      var='hash_algs'
      type='list-single'
      label='Hash algorithm options'/&gt;
  &lt;field
      var='compress'
      type='list-single'
      label='Compression algorithm options'/&gt;
  &lt;field
      var='stanzas'
      type='list-multi'
      label='Stanzas types to encrypt'/&gt;
  &lt;field
      var='secure'
      type='boolean'
      label='Require encrypted client-server streams'/&gt;
  &lt;field
      var='rekey_freq'
      type='text-single'
      label='Minimum number of stanzas between key exchanges'/&gt;
  &lt;field
      var='accept_pkids'
      type='list-multi'
      label='Acceptable public key IDs'/&gt;
  &lt;field
      var='counter'
      type='hidden'
      label='Initial block counter'/&gt;
  &lt;field
      var='key'
      type='hidden'
      label='Diffie-Hellman key'/&gt;
  &lt;field
      var='pkey'
      type='hidden'
      label='Public key'/&gt;
  &lt;field
      var='pkids'
      type='list-single'
      label='Public key IDs'/&gt;
  &lt;field
      var='signs'
      type='list-single'
      label='Data form signatures'/&gt;
  &lt;field
      var='prev_hash'
      type='hidden'
      label='HASH of previous data form'/&gt;
&lt;/form_type&gt;

&lt;form_type&gt;
  &lt;name&gt;http://jabber.org/protocol/chatneg&lt;/name&gt;
  &lt;jep&gt;JEP-0155&lt;/jep&gt;
  ...
&lt;/form_type&gt;
    </pre></div>
  </div>
<h2>15.
       <a name="schema">XML Schemas</a>
</h2>
  <p class="" style="">To follow.</p>
<h2>16.
       <a name="keys">Public Key Publication and Retrieval</a>
</h2>
  <p class="" style=""><span style="font-style: italic">Note: This section is highly preliminary and will be specified in a separate proposal before this document reaches draft status.</span></p>
  <p class="" style="">Entities SHOULD publish their long-term public signature-verification keys to all entities through their own server using the disco#publish-info feature (as <a href="http://mail.jabber.org/pipermail/standards-jig/2005-July/008131.html">NOT SPECIFIED</a> in <span style="font-weight: bold">JEP-0030</span>).</p>

  <p class="caption">Example 23. Entity Publishes Public Keys to Server</p>
<div class="indent"><pre>
&lt;iq type='set' from='alice@example.org/pda' id='dp1'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/publickeys'&gt;
    &lt;x type='submit' xmlns='jabber:x:data'&gt;
      &lt;field var='FORM_TYPE'&gt;
        &lt;value&gt;http://jabber.org/protocol/publickeys&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='types'&gt;
        &lt;value&gt;x509v3-sign-rsa&lt;/value&gt;
        &lt;value&gt;pgp-sign-dss&lt;/value&gt;
        &lt;value&gt;ssh-rsa&lt;/value&gt;
        &lt;value&gt;ssh-dss&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='keys'&gt;
        &lt;value&gt; ** Base64 encoded x509 certificate containing RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded OpenPGP certificate containing DSS public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded unsigned RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded unsigned DSS public key ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>

  <p class="" style="">Before initiating an ESession, if Bob does not already possess one of Alice's signature-verification keys, he SHOULD retrieve them from Alice's server.</p>
  <p class="caption">Example 24. Bob Requests Public Keys from Alice's Server</p>
<div class="indent"><pre>
&lt;iq type='get'
    from='bob@example.com/laptop'
    to='alice@example.org'
    id='dp2'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/publickeys'/&gt;
&lt;/iq&gt;
  </pre></div>

  <p class="caption">Example 25. Server Returns Public Keys</p>
<div class="indent"><pre>
&lt;iq type='result'
    from='alice@example.org'
    to='bob@example.com/laptop'
    id='dp2'&gt;
  &lt;query xmlns='http://jabber.org/protocol/disco#info'
         node='http://jabber.org/protocol/publickeys'&gt;
    &lt;x type='result' xmlns='jabber:x:data'&gt;
      &lt;field var='FORM_TYPE'&gt;
        &lt;value&gt;http://jabber.org/protocol/publickeys&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='types'&gt;
        &lt;value&gt;x509v3-sign-rsa&lt;/value&gt;
        &lt;value&gt;pgp-sign-dss&lt;/value&gt;
        &lt;value&gt;ssh-rsa&lt;/value&gt;
        &lt;value&gt;ssh-dss&lt;/value&gt;
      &lt;/field&gt;
      &lt;field var='keys'&gt;
        &lt;value&gt; ** Base64 encoded x509 certificate containing RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded OpenPGP certificate containing DSS public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded unsigned RSA public key ** &lt;/value&gt;
        &lt;value&gt; ** Base64 encoded unsigned DSS public key ** &lt;/value&gt;
      &lt;/field&gt;
    &lt;/x&gt;
  &lt;/query&gt;
&lt;/iq&gt;
  </pre></div>
  <p class="" style="">Bob should examine all the public keys and identify which ones are acceptable (see <a href="#sec-keys">Verifying Keys</a>).</p>
<h2>17.
       <a name="open">Open Issues</a>
</h2>
  <div class="indent">
<h3>17.1 <a name="open-tothink">To Think About</a>
</h3>
    <ol start="" type="">
      <li>Split Offline Esessions into another JEP?</li>
      <li>Standardise on the X.509 public key and signature formats?</li>
      <li>What challenges exist to make the OTR Gaim Plugin use this protocol natively when talking to Jabber entities? Can these be mitigated by 'non-critical' protocol changes?</li>
      <li>Would anything in this protocol (e.g., its dependency on in-order stanza delivery) prevent an XMPP entity using it to exchange encrypted messages and presence with a user of a non-XMPP messaging system, assuming that the gateway both supports this protocol and is compatible with a purpose-built security plugin on the other user's client (e.g. a Gaim plugin connects to the gateway via a non-XMPP network)?</li>
      <li>Could the protocol approximate SSH (or IPsec) more closely without losing the benefits of OTR?</li>
      <li>Could use <span class="ref" style="">Flexible Offline Message Retrieval</span>  [<a href="#nt-id2265097">58</a>] (FOMR) instead of AMP to prevent any offline Esessions Bob can't decrypt being delivered to him. (Each &lt;item/&gt; that corresponds to an Esession message would have to contain a &lt;prev_hash/&gt; child, to allow Bob to discover via his stored HASHES which of his stored values of y was used to encrypt the message.)</li>
    </ol>
  </div>
  <div class="indent">
<h3>17.2 <a name="open-todo">To Do</a>
</h3>
    <ol start="" type="">
      <li>Ask the authors of AMP to explain how to achieve the match_resource functionality to be specified here.</li>
      <li>Separate public key publishing into another JEP. Should there be a disco item for each key?</li>
      <li>Define names for X.509 SubjectPublicKeyInfo public key formats (different to X.509 certificates). This format must be used when keys are distributed within session initiation.</li>
      <li>Add non-repudiable signing option</li>
      <li>Move "secure" field to JEP-0155</li>
      <li>Perhaps the JEP needs to specify more carefully how block counters are handled between messages, especially in the event of partial blocks?</li>
      <li>Give examples of specific errors and discuss error scenarios throughout document (e.g., what should Bob do if he is not offline and he receives an offline key exchange stanza?).</li>
      <li>Update Dependencies list</li>
      <li>Define an <span style="font-style: italic">optional</span> protocol that would allow Bob to store y and HASHES (and the PKIDs he trusts) 'securely' on his own server (before he goes offline).</li>
    </ol>
  </div>
<p><hr></p>
<a name="notes"></a><h2>Notes</h2>
<div class="indent">
<p><a name="nt-id2250835">1</a>. JEP-0027: Current Jabber OpenPGP Usage &lt;<a href="http://www.jabber.org/jeps/jep-0027.html">http://www.jabber.org/jeps/jep-0027.html</a>&gt;.</p>
<p><a name="nt-id2250790">2</a>. RFC 3862: Common Presence and Instant Messaging (CPIM): Message Format &lt;<a href="http://www.ietf.org/rfc/rfc3862.txt">http://www.ietf.org/rfc/rfc3862.txt</a>&gt;.</p>
<p><a name="nt-id2250818">3</a>. RFC 3863: Presence Information Data Format (PIDF) &lt;<a href="http://www.ietf.org/rfc/rfc3863.txt">http://www.ietf.org/rfc/rfc3863.txt</a>&gt;.</p>
<p><a name="nt-id2250566">4</a>. RFC 3923: End-to-End Signing and Object Encryption for the Extensible Messaging and Presence Protocol (XMPP) &lt;<a href="http://www.ietf.org/rfc/rfc3923.txt">http://www.ietf.org/rfc/rfc3923.txt</a>&gt;.</p>
<p><a name="nt-id2250609">5</a>. Off-the-Record Communication, or, Why Not to Use PGP &lt;<a href="http://www.isaac.cs.berkeley.edu/~iang/pubs/otr-wpes.pdf">http://www.isaac.cs.berkeley.edu/~iang/pubs/otr-wpes.pdf</a>&gt;.</p>
<p><a name="nt-id2250676">6</a>. RFC 3920: Extensible Messaging and Presence Protocol (XMPP): Core &lt;<a href="http://www.ietf.org/rfc/rfc3920.txt">http://www.ietf.org/rfc/rfc3920.txt</a>&gt;.</p>
<p><a name="nt-id2250646">7</a>. RFC 3921: Extensible Messaging and Presence Protocol (XMPP): Instant Messaging and Presence &lt;<a href="http://www.ietf.org/rfc/rfc3921.txt">http://www.ietf.org/rfc/rfc3921.txt</a>&gt;.</p>
<p><a name="nt-id2256421">8</a>. RFC 2246: The TLS Protocol Version 1.0 &lt;<a href="http://www.ietf.org/rfc/rfc2246.txt">http://www.ietf.org/rfc/rfc2246.txt</a>&gt;.</p>
<p><a name="nt-id2256470">9</a>. JEP-0096: File Transfer &lt;<a href="http://www.jabber.org/jeps/jep-0096.html">http://www.jabber.org/jeps/jep-0096.html</a>&gt;.</p>
<p><a name="nt-id2256493">10</a>. JEP-0079: Advanced Message Processing &lt;<a href="http://www.jabber.org/jeps/jep-0079.html">http://www.jabber.org/jeps/jep-0079.html</a>&gt;.</p>
<p><a name="nt-id2256529">11</a>. JEP-0045: Multi-User Chat &lt;<a href="http://www.jabber.org/jeps/jep-0045.html">http://www.jabber.org/jeps/jep-0045.html</a>&gt;.</p>
<p><a name="nt-id2256558">12</a>. JEP-0060: Publish-Subscribe &lt;<a href="http://www.jabber.org/jeps/jep-0060.html">http://www.jabber.org/jeps/jep-0060.html</a>&gt;.</p>
<p><a name="nt-id2256688">13</a>. SSH Protocol Architecture &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-architecture-22.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-architecture-22.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2256661">14</a>. SSH Transport Layer Protocol &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-transport-24.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-transport-24.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2256898">15</a>. The reliable association between an entity and its public keys is beyond the scope of this JEP.</p>
<p><a name="nt-id2256925">16</a>. Naturally, it is possible that Alice or Bob may retain cleartext versions of the exchanged communications; however, that threat is out of scope for this JEP.</p>
<p><a name="nt-id2259458">17</a>. JEP-0030: Service Discovery &lt;<a href="http://www.jabber.org/jeps/jep-0030.html">http://www.jabber.org/jeps/jep-0030.html</a>&gt;.</p>
<p><a name="nt-id2259484">18</a>. JEP-0115: Entity Capabilities &lt;<a href="http://www.jabber.org/jeps/jep-0115.html">http://www.jabber.org/jeps/jep-0115.html</a>&gt;.</p>
<p><a name="nt-id2259580">19</a>. RFC 2631: Diffie-Hellman Key Agreement Method &lt;<a href="http://www.ietf.org/rfc/rfc2631.txt">http://www.ietf.org/rfc/rfc2631.txt</a>&gt;.</p>
<p><a name="nt-id2259646">20</a>. JEP-0155: Chat Session Negotiation &lt;<a href="http://www.jabber.org/jeps/jep-0155.html">http://www.jabber.org/jeps/jep-0155.html</a>&gt;.</p>
<p><a name="nt-id2259713">21</a>. RFC 2409: The Internet Key Exchange (IKE) &lt;<a href="http://www.ietf.org/rfc/rfc2409.txt">http://www.ietf.org/rfc/rfc2409.txt</a>&gt;.</p>
<p><a name="nt-id2259736">22</a>. RFC 3526: More Modular Exponential (MODP) Diffie-Hellman Groups &lt;<a href="http://www.ietf.org/rfc/rfc3526.txt">http://www.ietf.org/rfc/rfc3526.txt</a>&gt;.</p>
<p><a name="nt-id2259813">23</a>. RFC 3548: The Base16, Base32, and Base64 Data Encodings &lt;<a href="http://www.ietf.org/rfc/rfc3548.txt">http://www.ietf.org/rfc/rfc3548.txt</a>&gt;.</p>
<p><a name="nt-id2259838">24</a>. The inclusion of a random element in Alice's Esession request will enable Alice to verify that Bob's response is not a 'replay'.</p>
<p><a name="nt-id2250274">25</a>. RFC 3766: Determining Strengths For Public Keys Used For Exchanging Symmetric Keys &lt;<a href="http://www.ietf.org/rfc/rfc3766.txt">http://www.ietf.org/rfc/rfc3766.txt</a>&gt;.</p>
<p><a name="nt-id2260372">26</a>. The private signing keys may only be accessible to another of Bob's clients.</p>
<p><a name="nt-id2260380">27</a>. Some servers may not support public key publishing.</p>
<p><a name="nt-id2260890">28</a>. The more often Bob changes his published Esession options, the shorter the Perfect Forward Secrecy window of vulnerability. However, whenever he changes them he divulges his presence to all the entities that are monitoring them.</p>
<p><a name="nt-id2261339">29</a>. Alice only initializes Bob's block counter in case he needs to terminate the Esession.</p>
<p><a name="nt-id2261648">30</a>. The HASH may not match if, for example, Bob went offline using a different client and/or a different machine without publishing a 'match_resource' field. If it does not match then Bob cannot decrypt the offline Esession.</p>
<p><a name="nt-id2261664">31</a>. If Bob has no copy of the options he published then he cannot be sure that Alice chose from those options.</p>
<p><a name="nt-id2261908">32</a>. K-M<span class="sub" style="">A</span> is a hash of K-C<span class="sub" style="">A</span> (not K) to ensure that if an attacker recovers the decryption key she will not be able to cryptographically convince anyone that it was not her who created the stanza.</p>
<p><a name="nt-id2262113">33</a>. JEP-0091: Delayed Delivery &lt;<a href="http://www.jabber.org/jeps/jep-0091.html">http://www.jabber.org/jeps/jep-0091.html</a>&gt;.</p>
<p><a name="nt-id2262192">34</a>. Although counter mode encryption requires no padding, implementations MAY still disguise the length of m by appending a random number of white-space characters.</p>
<p><a name="nt-id2262211">35</a>. If Bob were to receive a stanza out-of-order, then he would fail to decrypt the stanza and be forced to terminate the Esession.</p>
<p><a name="nt-id2262253">36</a>. Recommendation for Block Cipher Modes of Operation: Federal Information Processing Standards Publication 800-38a &lt;<a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">http://csrc.nist.gov/publications/ nistpubs/800-38a/sp800-38a.pdf</a>&gt;.</p>
<p><a name="nt-id2262441">37</a>. RFC 2104: HMAC: Keyed-Hashing for Message Authentication &lt;<a href="http://www.ietf.org/rfc/rfc2104.txt">http://www.ietf.org/rfc/rfc2104.txt</a>&gt;.</p>
<p><a name="nt-id2260693">38</a>. If Bob were to receive a stanza out-of-order, then the MACs would not match because the values of C<span class="sub" style="">A</span> would not be synchronized.</p>
<p><a name="nt-id2262598">39</a>. Bob MUST NOT send a stream error to his server since intermediate entities are not responsible for encoded content.</p>
<p><a name="nt-id2263143">40</a>. If an entity fails to receive any stanza that includes a new key in the correct order, then it will fail to decrypt the next stanza it receives and be forced to terminate the Esession.</p>
<p><a name="nt-id2263350">41</a>. Content is specified for the &lt;terminate/&gt; element to facilitate <a href="#sign-normal">XML Normalization</a>.</p>
<p><a name="nt-id2263537">42</a>. Canonical XML 1.0 &lt;<a href="http://www.w3.org/TR/xml-c14n">http://www.w3.org/TR/xml-c14n</a>&gt;.</p>
<p><a name="nt-id2263662">43</a>. RFC 3447: Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1 &lt;<a href="http://www.ietf.org/rfc/rfc3447.txt">http://www.ietf.org/rfc/rfc3447.txt</a>&gt;.</p>
<p><a name="nt-id2263715">44</a>. Digital Signature Standard: Federal Information Processing Standards Publication 186  &lt;<a href="http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf">http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf</a>&gt;.</p>
<p><a name="nt-id2263895">45</a>. RFC 1750: Randomness Recommendations for Security &lt;<a href="http://www.ietf.org/rfc/rfc1750.txt">http://www.ietf.org/rfc/rfc1750.txt</a>&gt;.</p>
<p><a name="nt-id2263942">46</a>. SSH Transport Layer Encryption Modes &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-05.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-05.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2264270">47</a>. IANA registry of parameters related to secure shell &lt;<a href="http://www.iana.org/assignments/ssh-parameters">http://www.iana.org/assignments/ssh-parameters</a>&gt;.</p>
<p><a name="nt-id2264318">48</a>. Advanced Encryption Standard: Federal Information Processing Standards Publication 197 &lt;<a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf</a>&gt;.</p>
<p><a name="nt-id2264362">49</a>. The Twofish Block Cipher &lt;<a href="http://www.schneier.com/twofish.html">http://www.schneier.com/twofish.html</a>&gt;.</p>
<p><a name="nt-id2264399">50</a>. The Serpent Block Cipher &lt;<a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">http://www.cl.cam.ac.uk/~rja14/serpent.html</a>&gt;.</p>
<p><a name="nt-id2264514">51</a>. X.509 Authentication in SSH2 &lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-x509-02.txt">http://www.ietf.org/internet-drafts/draft-ietf-secsh-x509-02.txt</a>&gt;. Work in progress.</p>
<p><a name="nt-id2264591">52</a>. Secure Hash Standard: Federal Information Processing Standards Publication 180-2  &lt;<a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">http://csrc.nist.gov/publications/fips/fips180-2/fips186-2withchangenotice.pdf</a>&gt;.</p>
<p><a name="nt-id2264634">53</a>. The Whirlpool Hash Function &lt;<a href="http://paginas.terra.com.br/informatica/paulobarreto/WhirlpoolPage.html">http://paginas.terra.com.br/informatica/paulobarreto/WhirlpoolPage.html</a>&gt;.</p>
<p><a name="nt-id2264704">54</a>. RFC 1950: ZLIB Compressed Data Format Specification version 3.3 &lt;<a href="http://www.ietf.org/rfc/rfc1950.txt">http://www.ietf.org/rfc/rfc1950.txt</a>&gt;.</p>
<p><a name="nt-id2264745">55</a>. The Internet Assigned Numbers Authority (IANA) is the central coordinator for the assignment of unique parameter values for Internet protocols, such as port numbers and URI schemes. For further information, see &lt;<a href="http://www.iana.org/">http://www.iana.org/</a>&gt;.</p>
<p><a name="nt-id2264792">56</a>. The Jabber Registrar maintains a list of reserved Jabber protocol namespaces as well as registries of parameters used in the context of protocols approved by the Jabber Software Foundation. For further information, see &lt;<a href="http://www.jabber.org/registrar/">http://www.jabber.org/registrar/</a>&gt;.</p>
<p><a name="nt-id2264853">57</a>. JEP-0068: Field Data Standardization for Data Forms &lt;<a href="http://www.jabber.org/jeps/jep-0068.html">http://www.jabber.org/jeps/jep-0068.html</a>&gt;.</p>
<p><a name="nt-id2265097">58</a>. JEP-0013: Flexible Offline Message Retrieval &lt;<a href="http://www.jabber.org/jeps/jep-0013.html">http://www.jabber.org/jeps/jep-0013.html</a>&gt;.</p>
</div>
<p><hr></p>
<a name="revs"></a><h2>Revision History</h2>
<div class="indent">
<h4>Version 0.8 (2005-09-27)</h4>
<div class="indent">Added diagramatic synopses; Added match_resource field; replaced req_mac and kid fields with prev_hash; Alice specifies initial counter (doubles as nonce); many other improvements (ip)
    </div>
<h4>Version 0.7 (2005-08-26)</h4>
<div class="indent">Simplified XML normalization; added Synopsis and Efficiency requirement; defined signature formats (ip)
    </div>
<h4>Version 0.6 (2005-08-12)</h4>
<div class="indent">Extended termination procedure; added object encryption/signing requirement and special case; clarified expired MAC publishing; added Flexible Offline Message Retrieval to Open Issues. (ip)
    </div>
<h4>Version 0.5 (2005-08-10)</h4>
<div class="indent">Added flexibility requirement; added late signature of initial request; added termination MAC. (ip)
    </div>
<h4>Version 0.4 (2005-08-09)</h4>
<div class="indent">Added (offline) replay protection; required offline Created header; compression is NOT RECOMMENDED; added second set of offline options for subscribers; added JIDs to session key generation; unencrypted sessions; added secure option; sign whole data form; HMAC whole &lt;encrypted/&gt; element; added Esession termination; option to distribute public keys within session initiation; added Integrity requirement; several clarifications (ip)
    </div>
<h4>Version 0.3 (2005-08-02)</h4>
<div class="indent">Restored status to Experimental; complete rewrite; new Introduction, Background, Requirements and Security Considerations; new OTR-inspired protocol; JEP-0155-based negotiation; counter mode encryption; more secure hashes; offline sessions; re-keying; mac publishing; preliminary key and options publishing protocol. (ip/psa)
    </div>
<h4>Version 0.2 (2004-07-26)</h4>
<div class="indent">At the request of the JEP author, changed status to Retracted. (psa)
    </div>
<h4>Version 0.1 (2003-09-09)</h4>
<div class="indent">Initial version. (dss/psa)
    </div>
</div>
<p><hr></p>
<p>END</p>
</body>
</html>
